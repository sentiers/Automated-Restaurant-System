{"ast":null,"code":"'use strict';\n\nvar helpers = require('../helpers/index');\n/**\n * Helper function to get relative position for an event\n * @param {Event|IEvent} event - The event to get the position for\n * @param {Chart} chart - The chart\n * @returns {Point} the event position\n */\n\n\nfunction getRelativePosition(e, chart) {\n  if (e.native) {\n    return {\n      x: e.x,\n      y: e.y\n    };\n  }\n\n  return helpers.getRelativePosition(e, chart);\n}\n/**\n * Helper function to traverse all of the visible elements in the chart\n * @param chart {chart} the chart\n * @param handler {Function} the callback to execute for each visible item\n */\n\n\nfunction parseVisibleItems(chart, handler) {\n  var datasets = chart.data.datasets;\n  var meta, i, j, ilen, jlen;\n\n  for (i = 0, ilen = datasets.length; i < ilen; ++i) {\n    if (!chart.isDatasetVisible(i)) {\n      continue;\n    }\n\n    meta = chart.getDatasetMeta(i);\n\n    for (j = 0, jlen = meta.data.length; j < jlen; ++j) {\n      var element = meta.data[j];\n\n      if (!element._view.skip) {\n        handler(element);\n      }\n    }\n  }\n}\n/**\n * Helper function to get the items that intersect the event position\n * @param items {ChartElement[]} elements to filter\n * @param position {Point} the point to be nearest to\n * @return {ChartElement[]} the nearest items\n */\n\n\nfunction getIntersectItems(chart, position) {\n  var elements = [];\n  parseVisibleItems(chart, function (element) {\n    if (element.inRange(position.x, position.y)) {\n      elements.push(element);\n    }\n  });\n  return elements;\n}\n/**\n * Helper function to get the items nearest to the event position considering all visible items in teh chart\n * @param chart {Chart} the chart to look at elements from\n * @param position {Point} the point to be nearest to\n * @param intersect {Boolean} if true, only consider items that intersect the position\n * @param distanceMetric {Function} function to provide the distance between points\n * @return {ChartElement[]} the nearest items\n */\n\n\nfunction getNearestItems(chart, position, intersect, distanceMetric) {\n  var minDistance = Number.POSITIVE_INFINITY;\n  var nearestItems = [];\n  parseVisibleItems(chart, function (element) {\n    if (intersect && !element.inRange(position.x, position.y)) {\n      return;\n    }\n\n    var center = element.getCenterPoint();\n    var distance = distanceMetric(position, center);\n\n    if (distance < minDistance) {\n      nearestItems = [element];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      // Can have multiple items at the same distance in which case we sort by size\n      nearestItems.push(element);\n    }\n  });\n  return nearestItems;\n}\n/**\n * Get a distance metric function for two points based on the\n * axis mode setting\n * @param {String} axis the axis mode. x|y|xy\n */\n\n\nfunction getDistanceMetricForAxis(axis) {\n  var useX = axis.indexOf('x') !== -1;\n  var useY = axis.indexOf('y') !== -1;\n  return function (pt1, pt2) {\n    var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\n\nfunction indexMode(chart, e, options) {\n  var position = getRelativePosition(e, chart); // Default axis for index mode is 'x' to match old behaviour\n\n  options.axis = options.axis || 'x';\n  var distanceMetric = getDistanceMetricForAxis(options.axis);\n  var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n  var elements = [];\n\n  if (!items.length) {\n    return [];\n  }\n\n  chart.data.datasets.forEach(function (dataset, datasetIndex) {\n    if (chart.isDatasetVisible(datasetIndex)) {\n      var meta = chart.getDatasetMeta(datasetIndex);\n      var element = meta.data[items[0]._index]; // don't count items that are skipped (null data)\n\n      if (element && !element._view.skip) {\n        elements.push(element);\n      }\n    }\n  });\n  return elements;\n}\n/**\n * @interface IInteractionOptions\n */\n\n/**\n * If true, only consider items that intersect the point\n * @name IInterfaceOptions#boolean\n * @type Boolean\n */\n\n/**\n * Contains interaction related functions\n * @namespace Chart.Interaction\n */\n\n\nmodule.exports = {\n  // Helper function for different modes\n  modes: {\n    single: function (chart, e) {\n      var position = getRelativePosition(e, chart);\n      var elements = [];\n      parseVisibleItems(chart, function (element) {\n        if (element.inRange(position.x, position.y)) {\n          elements.push(element);\n          return elements;\n        }\n      });\n      return elements.slice(0, 1);\n    },\n\n    /**\n     * @function Chart.Interaction.modes.label\n     * @deprecated since version 2.4.0\n     * @todo remove at version 3\n     * @private\n     */\n    label: indexMode,\n\n    /**\n     * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n     * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n     * @function Chart.Interaction.modes.index\n     * @since v2.4.0\n     * @param chart {chart} the chart we are returning items from\n     * @param e {Event} the event we are find things at\n     * @param options {IInteractionOptions} options to use during interaction\n     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n     */\n    index: indexMode,\n\n    /**\n     * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n     * If the options.intersect is false, we find the nearest item and return the items in that dataset\n     * @function Chart.Interaction.modes.dataset\n     * @param chart {chart} the chart we are returning items from\n     * @param e {Event} the event we are find things at\n     * @param options {IInteractionOptions} options to use during interaction\n     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n     */\n    dataset: function (chart, e, options) {\n      var position = getRelativePosition(e, chart);\n      options.axis = options.axis || 'xy';\n      var distanceMetric = getDistanceMetricForAxis(options.axis);\n      var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\n      if (items.length > 0) {\n        items = chart.getDatasetMeta(items[0]._datasetIndex).data;\n      }\n\n      return items;\n    },\n\n    /**\n     * @function Chart.Interaction.modes.x-axis\n     * @deprecated since version 2.4.0. Use index mode and intersect == true\n     * @todo remove at version 3\n     * @private\n     */\n    'x-axis': function (chart, e) {\n      return indexMode(chart, e, {\n        intersect: false\n      });\n    },\n\n    /**\n     * Point mode returns all elements that hit test based on the event position\n     * of the event\n     * @function Chart.Interaction.modes.intersect\n     * @param chart {chart} the chart we are returning items from\n     * @param e {Event} the event we are find things at\n     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n     */\n    point: function (chart, e) {\n      var position = getRelativePosition(e, chart);\n      return getIntersectItems(chart, position);\n    },\n\n    /**\n     * nearest mode returns the element closest to the point\n     * @function Chart.Interaction.modes.intersect\n     * @param chart {chart} the chart we are returning items from\n     * @param e {Event} the event we are find things at\n     * @param options {IInteractionOptions} options to use\n     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n     */\n    nearest: function (chart, e, options) {\n      var position = getRelativePosition(e, chart);\n      options.axis = options.axis || 'xy';\n      var distanceMetric = getDistanceMetricForAxis(options.axis);\n      var nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric); // We have multiple items at the same distance from the event. Now sort by smallest\n\n      if (nearestItems.length > 1) {\n        nearestItems.sort(function (a, b) {\n          var sizeA = a.getArea();\n          var sizeB = b.getArea();\n          var ret = sizeA - sizeB;\n\n          if (ret === 0) {\n            // if equal sort by dataset index\n            ret = a._datasetIndex - b._datasetIndex;\n          }\n\n          return ret;\n        });\n      } // Return only 1 item\n\n\n      return nearestItems.slice(0, 1);\n    },\n\n    /**\n     * x mode returns the elements that hit-test at the current x coordinate\n     * @function Chart.Interaction.modes.x\n     * @param chart {chart} the chart we are returning items from\n     * @param e {Event} the event we are find things at\n     * @param options {IInteractionOptions} options to use\n     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n     */\n    x: function (chart, e, options) {\n      var position = getRelativePosition(e, chart);\n      var items = [];\n      var intersectsItem = false;\n      parseVisibleItems(chart, function (element) {\n        if (element.inXRange(position.x)) {\n          items.push(element);\n        }\n\n        if (element.inRange(position.x, position.y)) {\n          intersectsItem = true;\n        }\n      }); // If we want to trigger on an intersect and we don't have any items\n      // that intersect the position, return nothing\n\n      if (options.intersect && !intersectsItem) {\n        items = [];\n      }\n\n      return items;\n    },\n\n    /**\n     * y mode returns the elements that hit-test at the current y coordinate\n     * @function Chart.Interaction.modes.y\n     * @param chart {chart} the chart we are returning items from\n     * @param e {Event} the event we are find things at\n     * @param options {IInteractionOptions} options to use\n     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n     */\n    y: function (chart, e, options) {\n      var position = getRelativePosition(e, chart);\n      var items = [];\n      var intersectsItem = false;\n      parseVisibleItems(chart, function (element) {\n        if (element.inYRange(position.y)) {\n          items.push(element);\n        }\n\n        if (element.inRange(position.x, position.y)) {\n          intersectsItem = true;\n        }\n      }); // If we want to trigger on an intersect and we don't have any items\n      // that intersect the position, return nothing\n\n      if (options.intersect && !intersectsItem) {\n        items = [];\n      }\n\n      return items;\n    }\n  }\n};","map":{"version":3,"sources":["C:/Users/Administrator/.git/asdf/Source Files/node_modules/chart.js/src/core/core.interaction.js"],"names":["helpers","require","getRelativePosition","e","chart","native","x","y","parseVisibleItems","handler","datasets","data","meta","i","j","ilen","jlen","length","isDatasetVisible","getDatasetMeta","element","_view","skip","getIntersectItems","position","elements","inRange","push","getNearestItems","intersect","distanceMetric","minDistance","Number","POSITIVE_INFINITY","nearestItems","center","getCenterPoint","distance","getDistanceMetricForAxis","axis","useX","indexOf","useY","pt1","pt2","deltaX","Math","abs","deltaY","sqrt","pow","indexMode","options","items","forEach","dataset","datasetIndex","_index","module","exports","modes","single","slice","label","index","_datasetIndex","point","nearest","sort","a","b","sizeA","getArea","sizeB","ret","intersectsItem","inXRange","inYRange"],"mappings":"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","sourcesContent":["'use strict';\n\nvar helpers = require('../helpers/index');\n\n/**\n * Helper function to get relative position for an event\n * @param {Event|IEvent} event - The event to get the position for\n * @param {Chart} chart - The chart\n * @returns {Point} the event position\n */\nfunction getRelativePosition(e, chart) {\n\tif (e.native) {\n\t\treturn {\n\t\t\tx: e.x,\n\t\t\ty: e.y\n\t\t};\n\t}\n\n\treturn helpers.getRelativePosition(e, chart);\n}\n\n/**\n * Helper function to traverse all of the visible elements in the chart\n * @param chart {chart} the chart\n * @param handler {Function} the callback to execute for each visible item\n */\nfunction parseVisibleItems(chart, handler) {\n\tvar datasets = chart.data.datasets;\n\tvar meta, i, j, ilen, jlen;\n\n\tfor (i = 0, ilen = datasets.length; i < ilen; ++i) {\n\t\tif (!chart.isDatasetVisible(i)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmeta = chart.getDatasetMeta(i);\n\t\tfor (j = 0, jlen = meta.data.length; j < jlen; ++j) {\n\t\t\tvar element = meta.data[j];\n\t\t\tif (!element._view.skip) {\n\t\t\t\thandler(element);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Helper function to get the items that intersect the event position\n * @param items {ChartElement[]} elements to filter\n * @param position {Point} the point to be nearest to\n * @return {ChartElement[]} the nearest items\n */\nfunction getIntersectItems(chart, position) {\n\tvar elements = [];\n\n\tparseVisibleItems(chart, function(element) {\n\t\tif (element.inRange(position.x, position.y)) {\n\t\t\telements.push(element);\n\t\t}\n\t});\n\n\treturn elements;\n}\n\n/**\n * Helper function to get the items nearest to the event position considering all visible items in teh chart\n * @param chart {Chart} the chart to look at elements from\n * @param position {Point} the point to be nearest to\n * @param intersect {Boolean} if true, only consider items that intersect the position\n * @param distanceMetric {Function} function to provide the distance between points\n * @return {ChartElement[]} the nearest items\n */\nfunction getNearestItems(chart, position, intersect, distanceMetric) {\n\tvar minDistance = Number.POSITIVE_INFINITY;\n\tvar nearestItems = [];\n\n\tparseVisibleItems(chart, function(element) {\n\t\tif (intersect && !element.inRange(position.x, position.y)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar center = element.getCenterPoint();\n\t\tvar distance = distanceMetric(position, center);\n\n\t\tif (distance < minDistance) {\n\t\t\tnearestItems = [element];\n\t\t\tminDistance = distance;\n\t\t} else if (distance === minDistance) {\n\t\t\t// Can have multiple items at the same distance in which case we sort by size\n\t\t\tnearestItems.push(element);\n\t\t}\n\t});\n\n\treturn nearestItems;\n}\n\n/**\n * Get a distance metric function for two points based on the\n * axis mode setting\n * @param {String} axis the axis mode. x|y|xy\n */\nfunction getDistanceMetricForAxis(axis) {\n\tvar useX = axis.indexOf('x') !== -1;\n\tvar useY = axis.indexOf('y') !== -1;\n\n\treturn function(pt1, pt2) {\n\t\tvar deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n\t\tvar deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n\t\treturn Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n\t};\n}\n\nfunction indexMode(chart, e, options) {\n\tvar position = getRelativePosition(e, chart);\n\t// Default axis for index mode is 'x' to match old behaviour\n\toptions.axis = options.axis || 'x';\n\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\tvar elements = [];\n\n\tif (!items.length) {\n\t\treturn [];\n\t}\n\n\tchart.data.datasets.forEach(function(dataset, datasetIndex) {\n\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\tvar element = meta.data[items[0]._index];\n\n\t\t\t// don't count items that are skipped (null data)\n\t\t\tif (element && !element._view.skip) {\n\t\t\t\telements.push(element);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn elements;\n}\n\n/**\n * @interface IInteractionOptions\n */\n/**\n * If true, only consider items that intersect the point\n * @name IInterfaceOptions#boolean\n * @type Boolean\n */\n\n/**\n * Contains interaction related functions\n * @namespace Chart.Interaction\n */\nmodule.exports = {\n\t// Helper function for different modes\n\tmodes: {\n\t\tsingle: function(chart, e) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\tvar elements = [];\n\n\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\telements.push(element);\n\t\t\t\t\treturn elements;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn elements.slice(0, 1);\n\t\t},\n\n\t\t/**\n\t\t * @function Chart.Interaction.modes.label\n\t\t * @deprecated since version 2.4.0\n\t\t * @todo remove at version 3\n\t\t * @private\n\t\t */\n\t\tlabel: indexMode,\n\n\t\t/**\n\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t * @function Chart.Interaction.modes.index\n\t\t * @since v2.4.0\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tindex: indexMode,\n\n\t\t/**\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t * @function Chart.Interaction.modes.dataset\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tdataset: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\toptions.axis = options.axis || 'xy';\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\t\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\n\t\t\tif (items.length > 0) {\n\t\t\t\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\n\t\t\t}\n\n\t\t\treturn items;\n\t\t},\n\n\t\t/**\n\t\t * @function Chart.Interaction.modes.x-axis\n\t\t * @deprecated since version 2.4.0. Use index mode and intersect == true\n\t\t * @todo remove at version 3\n\t\t * @private\n\t\t */\n\t\t'x-axis': function(chart, e) {\n\t\t\treturn indexMode(chart, e, {intersect: false});\n\t\t},\n\n\t\t/**\n\t\t * Point mode returns all elements that hit test based on the event position\n\t\t * of the event\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tpoint: function(chart, e) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\treturn getIntersectItems(chart, position);\n\t\t},\n\n\t\t/**\n\t\t * nearest mode returns the element closest to the point\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tnearest: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\toptions.axis = options.axis || 'xy';\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\t\t\tvar nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric);\n\n\t\t\t// We have multiple items at the same distance from the event. Now sort by smallest\n\t\t\tif (nearestItems.length > 1) {\n\t\t\t\tnearestItems.sort(function(a, b) {\n\t\t\t\t\tvar sizeA = a.getArea();\n\t\t\t\t\tvar sizeB = b.getArea();\n\t\t\t\t\tvar ret = sizeA - sizeB;\n\n\t\t\t\t\tif (ret === 0) {\n\t\t\t\t\t\t// if equal sort by dataset index\n\t\t\t\t\t\tret = a._datasetIndex - b._datasetIndex;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Return only 1 item\n\t\t\treturn nearestItems.slice(0, 1);\n\t\t},\n\n\t\t/**\n\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t * @function Chart.Interaction.modes.x\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tx: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\tvar items = [];\n\t\t\tvar intersectsItem = false;\n\n\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\tif (element.inXRange(position.x)) {\n\t\t\t\t\titems.push(element);\n\t\t\t\t}\n\n\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\tintersectsItem = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t// that intersect the position, return nothing\n\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\titems = [];\n\t\t\t}\n\t\t\treturn items;\n\t\t},\n\n\t\t/**\n\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t * @function Chart.Interaction.modes.y\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\ty: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\tvar items = [];\n\t\t\tvar intersectsItem = false;\n\n\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\tif (element.inYRange(position.y)) {\n\t\t\t\t\titems.push(element);\n\t\t\t\t}\n\n\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\tintersectsItem = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t// that intersect the position, return nothing\n\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\titems = [];\n\t\t\t}\n\t\t\treturn items;\n\t\t}\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}