{"ast":null,"code":"'use strict';\n\nvar defaults = require('./core.defaults');\n\nvar Element = require('./core.element');\n\nvar helpers = require('../helpers/index');\n\nvar Ticks = require('./core.ticks');\n\ndefaults._set('scale', {\n  display: true,\n  position: 'left',\n  offset: false,\n  // grid line settings\n  gridLines: {\n    display: true,\n    color: 'rgba(0, 0, 0, 0.1)',\n    lineWidth: 1,\n    drawBorder: true,\n    drawOnChartArea: true,\n    drawTicks: true,\n    tickMarkLength: 10,\n    zeroLineWidth: 1,\n    zeroLineColor: 'rgba(0,0,0,0.25)',\n    zeroLineBorderDash: [],\n    zeroLineBorderDashOffset: 0.0,\n    offsetGridLines: false,\n    borderDash: [],\n    borderDashOffset: 0.0\n  },\n  // scale label\n  scaleLabel: {\n    // display property\n    display: false,\n    // actual label\n    labelString: '',\n    // line height\n    lineHeight: 1.2,\n    // top/bottom padding\n    padding: {\n      top: 4,\n      bottom: 4\n    }\n  },\n  // label settings\n  ticks: {\n    beginAtZero: false,\n    minRotation: 0,\n    maxRotation: 50,\n    mirror: false,\n    padding: 0,\n    reverse: false,\n    display: true,\n    autoSkip: true,\n    autoSkipPadding: 0,\n    labelOffset: 0,\n    // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n    callback: Ticks.formatters.values,\n    minor: {},\n    major: {}\n  }\n});\n\nfunction labelsFromTicks(ticks) {\n  var labels = [];\n  var i, ilen;\n\n  for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n    labels.push(ticks[i].label);\n  }\n\n  return labels;\n}\n\nfunction getLineValue(scale, index, offsetGridLines) {\n  var lineValue = scale.getPixelForTick(index);\n\n  if (offsetGridLines) {\n    if (index === 0) {\n      lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;\n    }\n  }\n\n  return lineValue;\n}\n\nfunction computeTextSize(context, tick, font) {\n  return helpers.isArray(tick) ? helpers.longestText(context, font, tick) : context.measureText(tick).width;\n}\n\nfunction parseFontOptions(options) {\n  var valueOrDefault = helpers.valueOrDefault;\n  var globalDefaults = defaults.global;\n  var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n  var style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);\n  var family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);\n  return {\n    size: size,\n    style: style,\n    family: family,\n    font: helpers.fontString(size, style, family)\n  };\n}\n\nfunction parseLineHeight(options) {\n  return helpers.options.toLineHeight(helpers.valueOrDefault(options.lineHeight, 1.2), helpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));\n}\n\nmodule.exports = Element.extend({\n  /**\n   * Get the padding needed for the scale\n   * @method getPadding\n   * @private\n   * @returns {Padding} the necessary padding\n   */\n  getPadding: function () {\n    var me = this;\n    return {\n      left: me.paddingLeft || 0,\n      top: me.paddingTop || 0,\n      right: me.paddingRight || 0,\n      bottom: me.paddingBottom || 0\n    };\n  },\n\n  /**\n   * Returns the scale tick objects ({label, major})\n   * @since 2.7\n   */\n  getTicks: function () {\n    return this._ticks;\n  },\n  // These methods are ordered by lifecyle. Utilities then follow.\n  // Any function defined here is inherited by all scale types.\n  // Any function can be extended by the scale type\n  mergeTicksOptions: function () {\n    var ticks = this.options.ticks;\n\n    if (ticks.minor === false) {\n      ticks.minor = {\n        display: false\n      };\n    }\n\n    if (ticks.major === false) {\n      ticks.major = {\n        display: false\n      };\n    }\n\n    for (var key in ticks) {\n      if (key !== 'major' && key !== 'minor') {\n        if (typeof ticks.minor[key] === 'undefined') {\n          ticks.minor[key] = ticks[key];\n        }\n\n        if (typeof ticks.major[key] === 'undefined') {\n          ticks.major[key] = ticks[key];\n        }\n      }\n    }\n  },\n  beforeUpdate: function () {\n    helpers.callback(this.options.beforeUpdate, [this]);\n  },\n  update: function (maxWidth, maxHeight, margins) {\n    var me = this;\n    var i, ilen, labels, label, ticks, tick; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\n    me.beforeUpdate(); // Absorb the master measurements\n\n    me.maxWidth = maxWidth;\n    me.maxHeight = maxHeight;\n    me.margins = helpers.extend({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n    me.longestTextCache = me.longestTextCache || {}; // Dimensions\n\n    me.beforeSetDimensions();\n    me.setDimensions();\n    me.afterSetDimensions(); // Data min/max\n\n    me.beforeDataLimits();\n    me.determineDataLimits();\n    me.afterDataLimits(); // Ticks - `this.ticks` is now DEPRECATED!\n    // Internal ticks are now stored as objects in the PRIVATE `this._ticks` member\n    // and must not be accessed directly from outside this class. `this.ticks` being\n    // around for long time and not marked as private, we can't change its structure\n    // without unexpected breaking changes. If you need to access the scale ticks,\n    // use scale.getTicks() instead.\n\n    me.beforeBuildTicks(); // New implementations should return an array of objects but for BACKWARD COMPAT,\n    // we still support no return (`this.ticks` internally set by calling this method).\n\n    ticks = me.buildTicks() || [];\n    me.afterBuildTicks();\n    me.beforeTickToLabelConversion(); // New implementations should return the formatted tick labels but for BACKWARD\n    // COMPAT, we still support no return (`this.ticks` internally changed by calling\n    // this method and supposed to contain only string values).\n\n    labels = me.convertTicksToLabels(ticks) || me.ticks;\n    me.afterTickToLabelConversion();\n    me.ticks = labels; // BACKWARD COMPATIBILITY\n    // IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!\n    // BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)\n\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      label = labels[i];\n      tick = ticks[i];\n\n      if (!tick) {\n        ticks.push(tick = {\n          label: label,\n          major: false\n        });\n      } else {\n        tick.label = label;\n      }\n    }\n\n    me._ticks = ticks; // Tick Rotation\n\n    me.beforeCalculateTickRotation();\n    me.calculateTickRotation();\n    me.afterCalculateTickRotation(); // Fit\n\n    me.beforeFit();\n    me.fit();\n    me.afterFit(); //\n\n    me.afterUpdate();\n    return me.minSize;\n  },\n  afterUpdate: function () {\n    helpers.callback(this.options.afterUpdate, [this]);\n  },\n  //\n  beforeSetDimensions: function () {\n    helpers.callback(this.options.beforeSetDimensions, [this]);\n  },\n  setDimensions: function () {\n    var me = this; // Set the unconstrained dimension before label rotation\n\n    if (me.isHorizontal()) {\n      // Reset position before calculating rotation\n      me.width = me.maxWidth;\n      me.left = 0;\n      me.right = me.width;\n    } else {\n      me.height = me.maxHeight; // Reset position before calculating rotation\n\n      me.top = 0;\n      me.bottom = me.height;\n    } // Reset padding\n\n\n    me.paddingLeft = 0;\n    me.paddingTop = 0;\n    me.paddingRight = 0;\n    me.paddingBottom = 0;\n  },\n  afterSetDimensions: function () {\n    helpers.callback(this.options.afterSetDimensions, [this]);\n  },\n  // Data limits\n  beforeDataLimits: function () {\n    helpers.callback(this.options.beforeDataLimits, [this]);\n  },\n  determineDataLimits: helpers.noop,\n  afterDataLimits: function () {\n    helpers.callback(this.options.afterDataLimits, [this]);\n  },\n  //\n  beforeBuildTicks: function () {\n    helpers.callback(this.options.beforeBuildTicks, [this]);\n  },\n  buildTicks: helpers.noop,\n  afterBuildTicks: function () {\n    helpers.callback(this.options.afterBuildTicks, [this]);\n  },\n  beforeTickToLabelConversion: function () {\n    helpers.callback(this.options.beforeTickToLabelConversion, [this]);\n  },\n  convertTicksToLabels: function () {\n    var me = this; // Convert ticks to strings\n\n    var tickOpts = me.options.ticks;\n    me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);\n  },\n  afterTickToLabelConversion: function () {\n    helpers.callback(this.options.afterTickToLabelConversion, [this]);\n  },\n  //\n  beforeCalculateTickRotation: function () {\n    helpers.callback(this.options.beforeCalculateTickRotation, [this]);\n  },\n  calculateTickRotation: function () {\n    var me = this;\n    var context = me.ctx;\n    var tickOpts = me.options.ticks;\n    var labels = labelsFromTicks(me._ticks); // Get the width of each grid by calculating the difference\n    // between x offsets between 0 and 1.\n\n    var tickFont = parseFontOptions(tickOpts);\n    context.font = tickFont.font;\n    var labelRotation = tickOpts.minRotation || 0;\n\n    if (labels.length && me.options.display && me.isHorizontal()) {\n      var originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);\n      var labelWidth = originalLabelWidth;\n      var cosRotation, sinRotation; // Allow 3 pixels x2 padding either side for label readability\n\n      var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6; // Max label rotation can be set or default to 90 - also act as a loop counter\n\n      while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\n        var angleRadians = helpers.toRadians(labelRotation);\n        cosRotation = Math.cos(angleRadians);\n        sinRotation = Math.sin(angleRadians);\n\n        if (sinRotation * originalLabelWidth > me.maxHeight) {\n          // go back one step\n          labelRotation--;\n          break;\n        }\n\n        labelRotation++;\n        labelWidth = cosRotation * originalLabelWidth;\n      }\n    }\n\n    me.labelRotation = labelRotation;\n  },\n  afterCalculateTickRotation: function () {\n    helpers.callback(this.options.afterCalculateTickRotation, [this]);\n  },\n  //\n  beforeFit: function () {\n    helpers.callback(this.options.beforeFit, [this]);\n  },\n  fit: function () {\n    var me = this; // Reset\n\n    var minSize = me.minSize = {\n      width: 0,\n      height: 0\n    };\n    var labels = labelsFromTicks(me._ticks);\n    var opts = me.options;\n    var tickOpts = opts.ticks;\n    var scaleLabelOpts = opts.scaleLabel;\n    var gridLineOpts = opts.gridLines;\n    var display = opts.display;\n    var isHorizontal = me.isHorizontal();\n    var tickFont = parseFontOptions(tickOpts);\n    var tickMarkLength = opts.gridLines.tickMarkLength; // Width\n\n    if (isHorizontal) {\n      // subtract the margins to line up with the chartArea if we are a full width scale\n      minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n    } else {\n      minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n    } // height\n\n\n    if (isHorizontal) {\n      minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n    } else {\n      minSize.height = me.maxHeight; // fill all the height\n    } // Are we showing a title for the scale?\n\n\n    if (scaleLabelOpts.display && display) {\n      var scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);\n      var scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);\n      var deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;\n\n      if (isHorizontal) {\n        minSize.height += deltaHeight;\n      } else {\n        minSize.width += deltaHeight;\n      }\n    } // Don't bother fitting the ticks if we are not showing them\n\n\n    if (tickOpts.display && display) {\n      var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);\n      var tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);\n      var lineSpace = tickFont.size * 0.5;\n      var tickPadding = me.options.ticks.padding;\n\n      if (isHorizontal) {\n        // A horizontal axis is more constrained by the height.\n        me.longestLabelWidth = largestTextWidth;\n        var angleRadians = helpers.toRadians(me.labelRotation);\n        var cosRotation = Math.cos(angleRadians);\n        var sinRotation = Math.sin(angleRadians); // TODO - improve this calculation\n\n        var labelHeight = sinRotation * largestTextWidth + tickFont.size * tallestLabelHeightInLines + lineSpace * (tallestLabelHeightInLines - 1) + lineSpace; // padding\n\n        minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\n        me.ctx.font = tickFont.font;\n        var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);\n        var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font); // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n        // which means that the right padding is dominated by the font height\n\n        if (me.labelRotation !== 0) {\n          me.paddingLeft = opts.position === 'bottom' ? cosRotation * firstLabelWidth + 3 : cosRotation * lineSpace + 3; // add 3 px to move away from canvas edges\n\n          me.paddingRight = opts.position === 'bottom' ? cosRotation * lineSpace + 3 : cosRotation * lastLabelWidth + 3;\n        } else {\n          me.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges\n\n          me.paddingRight = lastLabelWidth / 2 + 3;\n        }\n      } else {\n        // A vertical axis is more constrained by the width. Labels are the\n        // dominant factor here, so get that length first and account for padding\n        if (tickOpts.mirror) {\n          largestTextWidth = 0;\n        } else {\n          // use lineSpace for consistency with horizontal axis\n          // tickPadding is not implemented for horizontal\n          largestTextWidth += tickPadding + lineSpace;\n        }\n\n        minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);\n        me.paddingTop = tickFont.size / 2;\n        me.paddingBottom = tickFont.size / 2;\n      }\n    }\n\n    me.handleMargins();\n    me.width = minSize.width;\n    me.height = minSize.height;\n  },\n\n  /**\n   * Handle margins and padding interactions\n   * @private\n   */\n  handleMargins: function () {\n    var me = this;\n\n    if (me.margins) {\n      me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n      me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n      me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n      me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n    }\n  },\n  afterFit: function () {\n    helpers.callback(this.options.afterFit, [this]);\n  },\n  // Shared Methods\n  isHorizontal: function () {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  },\n  isFullWidth: function () {\n    return this.options.fullWidth;\n  },\n  // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n  getRightValue: function (rawValue) {\n    // Null and undefined values first\n    if (helpers.isNullOrUndef(rawValue)) {\n      return NaN;\n    } // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\n\n\n    if (typeof rawValue === 'number' && !isFinite(rawValue)) {\n      return NaN;\n    } // If it is in fact an object, dive in one more level\n\n\n    if (rawValue) {\n      if (this.isHorizontal()) {\n        if (rawValue.x !== undefined) {\n          return this.getRightValue(rawValue.x);\n        }\n      } else if (rawValue.y !== undefined) {\n        return this.getRightValue(rawValue.y);\n      }\n    } // Value is good, return it\n\n\n    return rawValue;\n  },\n\n  /**\n   * Used to get the value to display in the tooltip for the data at the given index\n   * @param index\n   * @param datasetIndex\n   */\n  getLabelForIndex: helpers.noop,\n\n  /**\n   * Returns the location of the given data point. Value can either be an index or a numerical value\n   * The coordinate (0, 0) is at the upper-left corner of the canvas\n   * @param value\n   * @param index\n   * @param datasetIndex\n   */\n  getPixelForValue: helpers.noop,\n\n  /**\n   * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n   * The coordinate (0, 0) is at the upper-left corner of the canvas\n   * @param pixel\n   */\n  getValueForPixel: helpers.noop,\n\n  /**\n   * Returns the location of the tick at the given index\n   * The coordinate (0, 0) is at the upper-left corner of the canvas\n   */\n  getPixelForTick: function (index) {\n    var me = this;\n    var offset = me.options.offset;\n\n    if (me.isHorizontal()) {\n      var innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n      var tickWidth = innerWidth / Math.max(me._ticks.length - (offset ? 0 : 1), 1);\n      var pixel = tickWidth * index + me.paddingLeft;\n\n      if (offset) {\n        pixel += tickWidth / 2;\n      }\n\n      var finalVal = me.left + Math.round(pixel);\n      finalVal += me.isFullWidth() ? me.margins.left : 0;\n      return finalVal;\n    }\n\n    var innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n    return me.top + index * (innerHeight / (me._ticks.length - 1));\n  },\n\n  /**\n   * Utility for getting the pixel location of a percentage of scale\n   * The coordinate (0, 0) is at the upper-left corner of the canvas\n   */\n  getPixelForDecimal: function (decimal) {\n    var me = this;\n\n    if (me.isHorizontal()) {\n      var innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n      var valueOffset = innerWidth * decimal + me.paddingLeft;\n      var finalVal = me.left + Math.round(valueOffset);\n      finalVal += me.isFullWidth() ? me.margins.left : 0;\n      return finalVal;\n    }\n\n    return me.top + decimal * me.height;\n  },\n\n  /**\n   * Returns the pixel for the minimum chart value\n   * The coordinate (0, 0) is at the upper-left corner of the canvas\n   */\n  getBasePixel: function () {\n    return this.getPixelForValue(this.getBaseValue());\n  },\n  getBaseValue: function () {\n    var me = this;\n    var min = me.min;\n    var max = me.max;\n    return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n  },\n\n  /**\n   * Returns a subset of ticks to be plotted to avoid overlapping labels.\n   * @private\n   */\n  _autoSkip: function (ticks) {\n    var skipRatio;\n    var me = this;\n    var isHorizontal = me.isHorizontal();\n    var optionTicks = me.options.ticks.minor;\n    var tickCount = ticks.length;\n    var labelRotationRadians = helpers.toRadians(me.labelRotation);\n    var cosRotation = Math.cos(labelRotationRadians);\n    var longestRotatedLabel = me.longestLabelWidth * cosRotation;\n    var result = [];\n    var i, tick, shouldSkip; // figure out the maximum number of gridlines to show\n\n    var maxTicks;\n\n    if (optionTicks.maxTicksLimit) {\n      maxTicks = optionTicks.maxTicksLimit;\n    }\n\n    if (isHorizontal) {\n      skipRatio = false;\n\n      if ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > me.width - (me.paddingLeft + me.paddingRight)) {\n        skipRatio = 1 + Math.floor((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount / (me.width - (me.paddingLeft + me.paddingRight)));\n      } // if they defined a max number of optionTicks,\n      // increase skipRatio until that number is met\n\n\n      if (maxTicks && tickCount > maxTicks) {\n        skipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));\n      }\n    }\n\n    for (i = 0; i < tickCount; i++) {\n      tick = ticks[i]; // Since we always show the last tick,we need may need to hide the last shown one before\n\n      shouldSkip = skipRatio > 1 && i % skipRatio > 0 || i % skipRatio === 0 && i + skipRatio >= tickCount;\n\n      if (shouldSkip && i !== tickCount - 1) {\n        // leave tick in place but make sure it's not displayed (#4635)\n        delete tick.label;\n      }\n\n      result.push(tick);\n    }\n\n    return result;\n  },\n  // Actually draw the scale on the canvas\n  // @param {rectangle} chartArea : the area of the chart to draw full grid lines on\n  draw: function (chartArea) {\n    var me = this;\n    var options = me.options;\n\n    if (!options.display) {\n      return;\n    }\n\n    var context = me.ctx;\n    var globalDefaults = defaults.global;\n    var optionTicks = options.ticks.minor;\n    var optionMajorTicks = options.ticks.major || optionTicks;\n    var gridLines = options.gridLines;\n    var scaleLabel = options.scaleLabel;\n    var isRotated = me.labelRotation !== 0;\n    var isHorizontal = me.isHorizontal();\n    var ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();\n    var tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);\n    var tickFont = parseFontOptions(optionTicks);\n    var majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);\n    var majorTickFont = parseFontOptions(optionMajorTicks);\n    var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\n    var scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);\n    var scaleLabelFont = parseFontOptions(scaleLabel);\n    var scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);\n    var labelRotationRadians = helpers.toRadians(me.labelRotation);\n    var itemsToDraw = [];\n    var axisWidth = me.options.gridLines.lineWidth;\n    var xTickStart = options.position === 'right' ? me.left : me.right - axisWidth - tl;\n    var xTickEnd = options.position === 'right' ? me.left + tl : me.right;\n    var yTickStart = options.position === 'bottom' ? me.top + axisWidth : me.bottom - tl - axisWidth;\n    var yTickEnd = options.position === 'bottom' ? me.top + axisWidth + tl : me.bottom + axisWidth;\n    helpers.each(ticks, function (tick, index) {\n      // autoskipper skipped this tick (#4635)\n      if (helpers.isNullOrUndef(tick.label)) {\n        return;\n      }\n\n      var label = tick.label;\n      var lineWidth, lineColor, borderDash, borderDashOffset;\n\n      if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {\n        // Draw the first index specially\n        lineWidth = gridLines.zeroLineWidth;\n        lineColor = gridLines.zeroLineColor;\n        borderDash = gridLines.zeroLineBorderDash;\n        borderDashOffset = gridLines.zeroLineBorderDashOffset;\n      } else {\n        lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);\n        lineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);\n        borderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);\n        borderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);\n      } // Common properties\n\n\n      var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;\n      var textAlign = 'middle';\n      var textBaseline = 'middle';\n      var tickPadding = optionTicks.padding;\n\n      if (isHorizontal) {\n        var labelYOffset = tl + tickPadding;\n\n        if (options.position === 'bottom') {\n          // bottom\n          textBaseline = !isRotated ? 'top' : 'middle';\n          textAlign = !isRotated ? 'center' : 'right';\n          labelY = me.top + labelYOffset;\n        } else {\n          // top\n          textBaseline = !isRotated ? 'bottom' : 'middle';\n          textAlign = !isRotated ? 'center' : 'left';\n          labelY = me.bottom - labelYOffset;\n        }\n\n        var xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);\n\n        if (xLineValue < me.left) {\n          lineColor = 'rgba(0,0,0,0)';\n        }\n\n        xLineValue += helpers.aliasPixel(lineWidth);\n        labelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)\n\n        tx1 = tx2 = x1 = x2 = xLineValue;\n        ty1 = yTickStart;\n        ty2 = yTickEnd;\n        y1 = chartArea.top;\n        y2 = chartArea.bottom + axisWidth;\n      } else {\n        var isLeft = options.position === 'left';\n        var labelXOffset;\n\n        if (optionTicks.mirror) {\n          textAlign = isLeft ? 'left' : 'right';\n          labelXOffset = tickPadding;\n        } else {\n          textAlign = isLeft ? 'right' : 'left';\n          labelXOffset = tl + tickPadding;\n        }\n\n        labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;\n        var yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);\n\n        if (yLineValue < me.top) {\n          lineColor = 'rgba(0,0,0,0)';\n        }\n\n        yLineValue += helpers.aliasPixel(lineWidth);\n        labelY = me.getPixelForTick(index) + optionTicks.labelOffset;\n        tx1 = xTickStart;\n        tx2 = xTickEnd;\n        x1 = chartArea.left;\n        x2 = chartArea.right + axisWidth;\n        ty1 = ty2 = y1 = y2 = yLineValue;\n      }\n\n      itemsToDraw.push({\n        tx1: tx1,\n        ty1: ty1,\n        tx2: tx2,\n        ty2: ty2,\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        labelX: labelX,\n        labelY: labelY,\n        glWidth: lineWidth,\n        glColor: lineColor,\n        glBorderDash: borderDash,\n        glBorderDashOffset: borderDashOffset,\n        rotation: -1 * labelRotationRadians,\n        label: label,\n        major: tick.major,\n        textBaseline: textBaseline,\n        textAlign: textAlign\n      });\n    }); // Draw all of the tick labels, tick marks, and grid lines at the correct places\n\n    helpers.each(itemsToDraw, function (itemToDraw) {\n      if (gridLines.display) {\n        context.save();\n        context.lineWidth = itemToDraw.glWidth;\n        context.strokeStyle = itemToDraw.glColor;\n\n        if (context.setLineDash) {\n          context.setLineDash(itemToDraw.glBorderDash);\n          context.lineDashOffset = itemToDraw.glBorderDashOffset;\n        }\n\n        context.beginPath();\n\n        if (gridLines.drawTicks) {\n          context.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n          context.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n        }\n\n        if (gridLines.drawOnChartArea) {\n          context.moveTo(itemToDraw.x1, itemToDraw.y1);\n          context.lineTo(itemToDraw.x2, itemToDraw.y2);\n        }\n\n        context.stroke();\n        context.restore();\n      }\n\n      if (optionTicks.display) {\n        // Make sure we draw text in the correct color and font\n        context.save();\n        context.translate(itemToDraw.labelX, itemToDraw.labelY);\n        context.rotate(itemToDraw.rotation);\n        context.font = itemToDraw.major ? majorTickFont.font : tickFont.font;\n        context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;\n        context.textBaseline = itemToDraw.textBaseline;\n        context.textAlign = itemToDraw.textAlign;\n        var label = itemToDraw.label;\n\n        if (helpers.isArray(label)) {\n          var lineCount = label.length;\n          var lineHeight = tickFont.size * 1.5;\n          var y = me.isHorizontal() ? 0 : -lineHeight * (lineCount - 1) / 2;\n\n          for (var i = 0; i < lineCount; ++i) {\n            // We just make sure the multiline element is a string here..\n            context.fillText('' + label[i], 0, y); // apply same lineSpacing as calculated @ L#320\n\n            y += lineHeight;\n          }\n        } else {\n          context.fillText(label, 0, 0);\n        }\n\n        context.restore();\n      }\n    });\n\n    if (scaleLabel.display) {\n      // Draw the scale label\n      var scaleLabelX;\n      var scaleLabelY;\n      var rotation = 0;\n      var halfLineHeight = parseLineHeight(scaleLabel) / 2;\n\n      if (isHorizontal) {\n        scaleLabelX = me.left + (me.right - me.left) / 2; // midpoint of the width\n\n        scaleLabelY = options.position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;\n      } else {\n        var isLeft = options.position === 'left';\n        scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;\n        scaleLabelY = me.top + (me.bottom - me.top) / 2;\n        rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n      }\n\n      context.save();\n      context.translate(scaleLabelX, scaleLabelY);\n      context.rotate(rotation);\n      context.textAlign = 'center';\n      context.textBaseline = 'middle';\n      context.fillStyle = scaleLabelFontColor; // render in correct colour\n\n      context.font = scaleLabelFont.font;\n      context.fillText(scaleLabel.labelString, 0, 0);\n      context.restore();\n    }\n\n    if (gridLines.drawBorder) {\n      // Draw the line at the edge of the axis\n      context.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);\n      context.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);\n      var x1 = me.left;\n      var x2 = me.right + axisWidth;\n      var y1 = me.top;\n      var y2 = me.bottom + axisWidth;\n      var aliasPixel = helpers.aliasPixel(context.lineWidth);\n\n      if (isHorizontal) {\n        y1 = y2 = options.position === 'top' ? me.bottom : me.top;\n        y1 += aliasPixel;\n        y2 += aliasPixel;\n      } else {\n        x1 = x2 = options.position === 'left' ? me.right : me.left;\n        x1 += aliasPixel;\n        x2 += aliasPixel;\n      }\n\n      context.beginPath();\n      context.moveTo(x1, y1);\n      context.lineTo(x2, y2);\n      context.stroke();\n    }\n  }\n});","map":{"version":3,"sources":["C:/Users/Administrator/.git/asdf/Source Files/node_modules/chart.js/src/core/core.scale.js"],"names":["defaults","require","Element","helpers","Ticks","_set","display","position","offset","gridLines","color","lineWidth","drawBorder","drawOnChartArea","drawTicks","tickMarkLength","zeroLineWidth","zeroLineColor","zeroLineBorderDash","zeroLineBorderDashOffset","offsetGridLines","borderDash","borderDashOffset","scaleLabel","labelString","lineHeight","padding","top","bottom","ticks","beginAtZero","minRotation","maxRotation","mirror","reverse","autoSkip","autoSkipPadding","labelOffset","callback","formatters","values","minor","major","labelsFromTicks","labels","i","ilen","length","push","label","getLineValue","scale","index","lineValue","getPixelForTick","computeTextSize","context","tick","font","isArray","longestText","measureText","width","parseFontOptions","options","valueOrDefault","globalDefaults","global","size","fontSize","defaultFontSize","style","fontStyle","defaultFontStyle","family","fontFamily","defaultFontFamily","fontString","parseLineHeight","toLineHeight","module","exports","extend","getPadding","me","left","paddingLeft","paddingTop","right","paddingRight","paddingBottom","getTicks","_ticks","mergeTicksOptions","key","beforeUpdate","update","maxWidth","maxHeight","margins","longestTextCache","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","beforeBuildTicks","buildTicks","afterBuildTicks","beforeTickToLabelConversion","convertTicksToLabels","afterTickToLabelConversion","beforeCalculateTickRotation","calculateTickRotation","afterCalculateTickRotation","beforeFit","fit","afterFit","afterUpdate","minSize","isHorizontal","height","noop","tickOpts","map","userCallback","ctx","tickFont","labelRotation","originalLabelWidth","labelWidth","cosRotation","sinRotation","tickWidth","angleRadians","toRadians","Math","cos","sin","opts","scaleLabelOpts","gridLineOpts","isFullWidth","scaleLabelLineHeight","scaleLabelPadding","toPadding","deltaHeight","largestTextWidth","tallestLabelHeightInLines","numberOfLabelLines","lineSpace","tickPadding","longestLabelWidth","labelHeight","min","firstLabelWidth","lastLabelWidth","handleMargins","max","fullWidth","getRightValue","rawValue","isNullOrUndef","NaN","isFinite","x","undefined","y","getLabelForIndex","getPixelForValue","getValueForPixel","innerWidth","pixel","finalVal","round","innerHeight","getPixelForDecimal","decimal","valueOffset","getBasePixel","getBaseValue","_autoSkip","skipRatio","optionTicks","tickCount","labelRotationRadians","longestRotatedLabel","result","shouldSkip","maxTicks","maxTicksLimit","floor","draw","chartArea","optionMajorTicks","isRotated","tickFontColor","fontColor","defaultFontColor","majorTickFontColor","majorTickFont","tl","scaleLabelFontColor","scaleLabelFont","itemsToDraw","axisWidth","xTickStart","xTickEnd","yTickStart","yTickEnd","each","lineColor","zeroLineIndex","valueAtIndexOrDefault","tx1","ty1","tx2","ty2","x1","y1","x2","y2","labelX","labelY","textAlign","textBaseline","labelYOffset","xLineValue","aliasPixel","isLeft","labelXOffset","yLineValue","glWidth","glColor","glBorderDash","glBorderDashOffset","rotation","itemToDraw","save","strokeStyle","setLineDash","lineDashOffset","beginPath","moveTo","lineTo","stroke","restore","translate","rotate","fillStyle","lineCount","fillText","scaleLabelX","scaleLabelY","halfLineHeight","PI"],"mappings":"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","sourcesContent":["'use strict';\n\nvar defaults = require('./core.defaults');\nvar Element = require('./core.element');\nvar helpers = require('../helpers/index');\nvar Ticks = require('./core.ticks');\n\ndefaults._set('scale', {\n\tdisplay: true,\n\tposition: 'left',\n\toffset: false,\n\n\t// grid line settings\n\tgridLines: {\n\t\tdisplay: true,\n\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\tlineWidth: 1,\n\t\tdrawBorder: true,\n\t\tdrawOnChartArea: true,\n\t\tdrawTicks: true,\n\t\ttickMarkLength: 10,\n\t\tzeroLineWidth: 1,\n\t\tzeroLineColor: 'rgba(0,0,0,0.25)',\n\t\tzeroLineBorderDash: [],\n\t\tzeroLineBorderDashOffset: 0.0,\n\t\toffsetGridLines: false,\n\t\tborderDash: [],\n\t\tborderDashOffset: 0.0\n\t},\n\n\t// scale label\n\tscaleLabel: {\n\t\t// display property\n\t\tdisplay: false,\n\n\t\t// actual label\n\t\tlabelString: '',\n\n\t\t// line height\n\t\tlineHeight: 1.2,\n\n\t\t// top/bottom padding\n\t\tpadding: {\n\t\t\ttop: 4,\n\t\t\tbottom: 4\n\t\t}\n\t},\n\n\t// label settings\n\tticks: {\n\t\tbeginAtZero: false,\n\t\tminRotation: 0,\n\t\tmaxRotation: 50,\n\t\tmirror: false,\n\t\tpadding: 0,\n\t\treverse: false,\n\t\tdisplay: true,\n\t\tautoSkip: true,\n\t\tautoSkipPadding: 0,\n\t\tlabelOffset: 0,\n\t\t// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n\t\tcallback: Ticks.formatters.values,\n\t\tminor: {},\n\t\tmajor: {}\n\t}\n});\n\nfunction labelsFromTicks(ticks) {\n\tvar labels = [];\n\tvar i, ilen;\n\n\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\tlabels.push(ticks[i].label);\n\t}\n\n\treturn labels;\n}\n\nfunction getLineValue(scale, index, offsetGridLines) {\n\tvar lineValue = scale.getPixelForTick(index);\n\n\tif (offsetGridLines) {\n\t\tif (index === 0) {\n\t\t\tlineValue -= (scale.getPixelForTick(1) - lineValue) / 2;\n\t\t} else {\n\t\t\tlineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;\n\t\t}\n\t}\n\treturn lineValue;\n}\n\nfunction computeTextSize(context, tick, font) {\n\treturn helpers.isArray(tick) ?\n\t\thelpers.longestText(context, font, tick) :\n\t\tcontext.measureText(tick).width;\n}\n\nfunction parseFontOptions(options) {\n\tvar valueOrDefault = helpers.valueOrDefault;\n\tvar globalDefaults = defaults.global;\n\tvar size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n\tvar style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);\n\tvar family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);\n\n\treturn {\n\t\tsize: size,\n\t\tstyle: style,\n\t\tfamily: family,\n\t\tfont: helpers.fontString(size, style, family)\n\t};\n}\n\nfunction parseLineHeight(options) {\n\treturn helpers.options.toLineHeight(\n\t\thelpers.valueOrDefault(options.lineHeight, 1.2),\n\t\thelpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));\n}\n\nmodule.exports = Element.extend({\n\t/**\n\t * Get the padding needed for the scale\n\t * @method getPadding\n\t * @private\n\t * @returns {Padding} the necessary padding\n\t */\n\tgetPadding: function() {\n\t\tvar me = this;\n\t\treturn {\n\t\t\tleft: me.paddingLeft || 0,\n\t\t\ttop: me.paddingTop || 0,\n\t\t\tright: me.paddingRight || 0,\n\t\t\tbottom: me.paddingBottom || 0\n\t\t};\n\t},\n\n\t/**\n\t * Returns the scale tick objects ({label, major})\n\t * @since 2.7\n\t */\n\tgetTicks: function() {\n\t\treturn this._ticks;\n\t},\n\n\t// These methods are ordered by lifecyle. Utilities then follow.\n\t// Any function defined here is inherited by all scale types.\n\t// Any function can be extended by the scale type\n\n\tmergeTicksOptions: function() {\n\t\tvar ticks = this.options.ticks;\n\t\tif (ticks.minor === false) {\n\t\t\tticks.minor = {\n\t\t\t\tdisplay: false\n\t\t\t};\n\t\t}\n\t\tif (ticks.major === false) {\n\t\t\tticks.major = {\n\t\t\t\tdisplay: false\n\t\t\t};\n\t\t}\n\t\tfor (var key in ticks) {\n\t\t\tif (key !== 'major' && key !== 'minor') {\n\t\t\t\tif (typeof ticks.minor[key] === 'undefined') {\n\t\t\t\t\tticks.minor[key] = ticks[key];\n\t\t\t\t}\n\t\t\t\tif (typeof ticks.major[key] === 'undefined') {\n\t\t\t\t\tticks.major[key] = ticks[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tbeforeUpdate: function() {\n\t\thelpers.callback(this.options.beforeUpdate, [this]);\n\t},\n\n\tupdate: function(maxWidth, maxHeight, margins) {\n\t\tvar me = this;\n\t\tvar i, ilen, labels, label, ticks, tick;\n\n\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\tme.beforeUpdate();\n\n\t\t// Absorb the master measurements\n\t\tme.maxWidth = maxWidth;\n\t\tme.maxHeight = maxHeight;\n\t\tme.margins = helpers.extend({\n\t\t\tleft: 0,\n\t\t\tright: 0,\n\t\t\ttop: 0,\n\t\t\tbottom: 0\n\t\t}, margins);\n\t\tme.longestTextCache = me.longestTextCache || {};\n\n\t\t// Dimensions\n\t\tme.beforeSetDimensions();\n\t\tme.setDimensions();\n\t\tme.afterSetDimensions();\n\n\t\t// Data min/max\n\t\tme.beforeDataLimits();\n\t\tme.determineDataLimits();\n\t\tme.afterDataLimits();\n\n\t\t// Ticks - `this.ticks` is now DEPRECATED!\n\t\t// Internal ticks are now stored as objects in the PRIVATE `this._ticks` member\n\t\t// and must not be accessed directly from outside this class. `this.ticks` being\n\t\t// around for long time and not marked as private, we can't change its structure\n\t\t// without unexpected breaking changes. If you need to access the scale ticks,\n\t\t// use scale.getTicks() instead.\n\n\t\tme.beforeBuildTicks();\n\n\t\t// New implementations should return an array of objects but for BACKWARD COMPAT,\n\t\t// we still support no return (`this.ticks` internally set by calling this method).\n\t\tticks = me.buildTicks() || [];\n\n\t\tme.afterBuildTicks();\n\n\t\tme.beforeTickToLabelConversion();\n\n\t\t// New implementations should return the formatted tick labels but for BACKWARD\n\t\t// COMPAT, we still support no return (`this.ticks` internally changed by calling\n\t\t// this method and supposed to contain only string values).\n\t\tlabels = me.convertTicksToLabels(ticks) || me.ticks;\n\n\t\tme.afterTickToLabelConversion();\n\n\t\tme.ticks = labels;   // BACKWARD COMPATIBILITY\n\n\t\t// IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!\n\n\t\t// BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)\n\t\tfor (i = 0, ilen = labels.length; i < ilen; ++i) {\n\t\t\tlabel = labels[i];\n\t\t\ttick = ticks[i];\n\t\t\tif (!tick) {\n\t\t\t\tticks.push(tick = {\n\t\t\t\t\tlabel: label,\n\t\t\t\t\tmajor: false\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\ttick.label = label;\n\t\t\t}\n\t\t}\n\n\t\tme._ticks = ticks;\n\n\t\t// Tick Rotation\n\t\tme.beforeCalculateTickRotation();\n\t\tme.calculateTickRotation();\n\t\tme.afterCalculateTickRotation();\n\t\t// Fit\n\t\tme.beforeFit();\n\t\tme.fit();\n\t\tme.afterFit();\n\t\t//\n\t\tme.afterUpdate();\n\n\t\treturn me.minSize;\n\n\t},\n\tafterUpdate: function() {\n\t\thelpers.callback(this.options.afterUpdate, [this]);\n\t},\n\n\t//\n\n\tbeforeSetDimensions: function() {\n\t\thelpers.callback(this.options.beforeSetDimensions, [this]);\n\t},\n\tsetDimensions: function() {\n\t\tvar me = this;\n\t\t// Set the unconstrained dimension before label rotation\n\t\tif (me.isHorizontal()) {\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.left = 0;\n\t\t\tme.right = me.width;\n\t\t} else {\n\t\t\tme.height = me.maxHeight;\n\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.top = 0;\n\t\t\tme.bottom = me.height;\n\t\t}\n\n\t\t// Reset padding\n\t\tme.paddingLeft = 0;\n\t\tme.paddingTop = 0;\n\t\tme.paddingRight = 0;\n\t\tme.paddingBottom = 0;\n\t},\n\tafterSetDimensions: function() {\n\t\thelpers.callback(this.options.afterSetDimensions, [this]);\n\t},\n\n\t// Data limits\n\tbeforeDataLimits: function() {\n\t\thelpers.callback(this.options.beforeDataLimits, [this]);\n\t},\n\tdetermineDataLimits: helpers.noop,\n\tafterDataLimits: function() {\n\t\thelpers.callback(this.options.afterDataLimits, [this]);\n\t},\n\n\t//\n\tbeforeBuildTicks: function() {\n\t\thelpers.callback(this.options.beforeBuildTicks, [this]);\n\t},\n\tbuildTicks: helpers.noop,\n\tafterBuildTicks: function() {\n\t\thelpers.callback(this.options.afterBuildTicks, [this]);\n\t},\n\n\tbeforeTickToLabelConversion: function() {\n\t\thelpers.callback(this.options.beforeTickToLabelConversion, [this]);\n\t},\n\tconvertTicksToLabels: function() {\n\t\tvar me = this;\n\t\t// Convert ticks to strings\n\t\tvar tickOpts = me.options.ticks;\n\t\tme.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);\n\t},\n\tafterTickToLabelConversion: function() {\n\t\thelpers.callback(this.options.afterTickToLabelConversion, [this]);\n\t},\n\n\t//\n\n\tbeforeCalculateTickRotation: function() {\n\t\thelpers.callback(this.options.beforeCalculateTickRotation, [this]);\n\t},\n\tcalculateTickRotation: function() {\n\t\tvar me = this;\n\t\tvar context = me.ctx;\n\t\tvar tickOpts = me.options.ticks;\n\t\tvar labels = labelsFromTicks(me._ticks);\n\n\t\t// Get the width of each grid by calculating the difference\n\t\t// between x offsets between 0 and 1.\n\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\tcontext.font = tickFont.font;\n\n\t\tvar labelRotation = tickOpts.minRotation || 0;\n\n\t\tif (labels.length && me.options.display && me.isHorizontal()) {\n\t\t\tvar originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);\n\t\t\tvar labelWidth = originalLabelWidth;\n\t\t\tvar cosRotation, sinRotation;\n\n\t\t\t// Allow 3 pixels x2 padding either side for label readability\n\t\t\tvar tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\n\n\t\t\t// Max label rotation can be set or default to 90 - also act as a loop counter\n\t\t\twhile (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\n\t\t\t\tvar angleRadians = helpers.toRadians(labelRotation);\n\t\t\t\tcosRotation = Math.cos(angleRadians);\n\t\t\t\tsinRotation = Math.sin(angleRadians);\n\n\t\t\t\tif (sinRotation * originalLabelWidth > me.maxHeight) {\n\t\t\t\t\t// go back one step\n\t\t\t\t\tlabelRotation--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlabelRotation++;\n\t\t\t\tlabelWidth = cosRotation * originalLabelWidth;\n\t\t\t}\n\t\t}\n\n\t\tme.labelRotation = labelRotation;\n\t},\n\tafterCalculateTickRotation: function() {\n\t\thelpers.callback(this.options.afterCalculateTickRotation, [this]);\n\t},\n\n\t//\n\n\tbeforeFit: function() {\n\t\thelpers.callback(this.options.beforeFit, [this]);\n\t},\n\tfit: function() {\n\t\tvar me = this;\n\t\t// Reset\n\t\tvar minSize = me.minSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\n\t\tvar labels = labelsFromTicks(me._ticks);\n\n\t\tvar opts = me.options;\n\t\tvar tickOpts = opts.ticks;\n\t\tvar scaleLabelOpts = opts.scaleLabel;\n\t\tvar gridLineOpts = opts.gridLines;\n\t\tvar display = opts.display;\n\t\tvar isHorizontal = me.isHorizontal();\n\n\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\tvar tickMarkLength = opts.gridLines.tickMarkLength;\n\n\t\t// Width\n\t\tif (isHorizontal) {\n\t\t\t// subtract the margins to line up with the chartArea if we are a full width scale\n\t\t\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n\t\t} else {\n\t\t\tminSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t}\n\n\t\t// height\n\t\tif (isHorizontal) {\n\t\t\tminSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t} else {\n\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t}\n\n\t\t// Are we showing a title for the scale?\n\t\tif (scaleLabelOpts.display && display) {\n\t\t\tvar scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);\n\t\t\tvar scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);\n\t\t\tvar deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize.height += deltaHeight;\n\t\t\t} else {\n\t\t\t\tminSize.width += deltaHeight;\n\t\t\t}\n\t\t}\n\n\t\t// Don't bother fitting the ticks if we are not showing them\n\t\tif (tickOpts.display && display) {\n\t\t\tvar largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);\n\t\t\tvar tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);\n\t\t\tvar lineSpace = tickFont.size * 0.5;\n\t\t\tvar tickPadding = me.options.ticks.padding;\n\n\t\t\tif (isHorizontal) {\n\t\t\t\t// A horizontal axis is more constrained by the height.\n\t\t\t\tme.longestLabelWidth = largestTextWidth;\n\n\t\t\t\tvar angleRadians = helpers.toRadians(me.labelRotation);\n\t\t\t\tvar cosRotation = Math.cos(angleRadians);\n\t\t\t\tvar sinRotation = Math.sin(angleRadians);\n\n\t\t\t\t// TODO - improve this calculation\n\t\t\t\tvar labelHeight = (sinRotation * largestTextWidth)\n\t\t\t\t\t+ (tickFont.size * tallestLabelHeightInLines)\n\t\t\t\t\t+ (lineSpace * (tallestLabelHeightInLines - 1))\n\t\t\t\t\t+ lineSpace; // padding\n\n\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\n\n\t\t\t\tme.ctx.font = tickFont.font;\n\t\t\t\tvar firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);\n\t\t\t\tvar lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font);\n\n\t\t\t\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n\t\t\t\t// which means that the right padding is dominated by the font height\n\t\t\t\tif (me.labelRotation !== 0) {\n\t\t\t\t\tme.paddingLeft = opts.position === 'bottom' ? (cosRotation * firstLabelWidth) + 3 : (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\tme.paddingRight = opts.position === 'bottom' ? (cosRotation * lineSpace) + 3 : (cosRotation * lastLabelWidth) + 3;\n\t\t\t\t} else {\n\t\t\t\t\tme.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\tme.paddingRight = lastLabelWidth / 2 + 3;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// A vertical axis is more constrained by the width. Labels are the\n\t\t\t\t// dominant factor here, so get that length first and account for padding\n\t\t\t\tif (tickOpts.mirror) {\n\t\t\t\t\tlargestTextWidth = 0;\n\t\t\t\t} else {\n\t\t\t\t\t// use lineSpace for consistency with horizontal axis\n\t\t\t\t\t// tickPadding is not implemented for horizontal\n\t\t\t\t\tlargestTextWidth += tickPadding + lineSpace;\n\t\t\t\t}\n\n\t\t\t\tminSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);\n\n\t\t\t\tme.paddingTop = tickFont.size / 2;\n\t\t\t\tme.paddingBottom = tickFont.size / 2;\n\t\t\t}\n\t\t}\n\n\t\tme.handleMargins();\n\n\t\tme.width = minSize.width;\n\t\tme.height = minSize.height;\n\t},\n\n\t/**\n\t * Handle margins and padding interactions\n\t * @private\n\t */\n\thandleMargins: function() {\n\t\tvar me = this;\n\t\tif (me.margins) {\n\t\t\tme.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n\t\t\tme.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n\t\t\tme.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n\t\t\tme.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n\t\t}\n\t},\n\n\tafterFit: function() {\n\t\thelpers.callback(this.options.afterFit, [this]);\n\t},\n\n\t// Shared Methods\n\tisHorizontal: function() {\n\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t},\n\tisFullWidth: function() {\n\t\treturn (this.options.fullWidth);\n\t},\n\n\t// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n\tgetRightValue: function(rawValue) {\n\t\t// Null and undefined values first\n\t\tif (helpers.isNullOrUndef(rawValue)) {\n\t\t\treturn NaN;\n\t\t}\n\t\t// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\n\t\tif (typeof rawValue === 'number' && !isFinite(rawValue)) {\n\t\t\treturn NaN;\n\t\t}\n\t\t// If it is in fact an object, dive in one more level\n\t\tif (rawValue) {\n\t\t\tif (this.isHorizontal()) {\n\t\t\t\tif (rawValue.x !== undefined) {\n\t\t\t\t\treturn this.getRightValue(rawValue.x);\n\t\t\t\t}\n\t\t\t} else if (rawValue.y !== undefined) {\n\t\t\t\treturn this.getRightValue(rawValue.y);\n\t\t\t}\n\t\t}\n\n\t\t// Value is good, return it\n\t\treturn rawValue;\n\t},\n\n\t/**\n\t * Used to get the value to display in the tooltip for the data at the given index\n\t * @param index\n\t * @param datasetIndex\n\t */\n\tgetLabelForIndex: helpers.noop,\n\n\t/**\n\t * Returns the location of the given data point. Value can either be an index or a numerical value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param value\n\t * @param index\n\t * @param datasetIndex\n\t */\n\tgetPixelForValue: helpers.noop,\n\n\t/**\n\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param pixel\n\t */\n\tgetValueForPixel: helpers.noop,\n\n\t/**\n\t * Returns the location of the tick at the given index\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t */\n\tgetPixelForTick: function(index) {\n\t\tvar me = this;\n\t\tvar offset = me.options.offset;\n\t\tif (me.isHorizontal()) {\n\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\tvar tickWidth = innerWidth / Math.max((me._ticks.length - (offset ? 0 : 1)), 1);\n\t\t\tvar pixel = (tickWidth * index) + me.paddingLeft;\n\n\t\t\tif (offset) {\n\t\t\t\tpixel += tickWidth / 2;\n\t\t\t}\n\n\t\t\tvar finalVal = me.left + Math.round(pixel);\n\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\treturn finalVal;\n\t\t}\n\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n\t\treturn me.top + (index * (innerHeight / (me._ticks.length - 1)));\n\t},\n\n\t/**\n\t * Utility for getting the pixel location of a percentage of scale\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t */\n\tgetPixelForDecimal: function(decimal) {\n\t\tvar me = this;\n\t\tif (me.isHorizontal()) {\n\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\tvar valueOffset = (innerWidth * decimal) + me.paddingLeft;\n\n\t\t\tvar finalVal = me.left + Math.round(valueOffset);\n\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\treturn finalVal;\n\t\t}\n\t\treturn me.top + (decimal * me.height);\n\t},\n\n\t/**\n\t * Returns the pixel for the minimum chart value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t */\n\tgetBasePixel: function() {\n\t\treturn this.getPixelForValue(this.getBaseValue());\n\t},\n\n\tgetBaseValue: function() {\n\t\tvar me = this;\n\t\tvar min = me.min;\n\t\tvar max = me.max;\n\n\t\treturn me.beginAtZero ? 0 :\n\t\t\tmin < 0 && max < 0 ? max :\n\t\t\tmin > 0 && max > 0 ? min :\n\t\t\t0;\n\t},\n\n\t/**\n\t * Returns a subset of ticks to be plotted to avoid overlapping labels.\n\t * @private\n\t */\n\t_autoSkip: function(ticks) {\n\t\tvar skipRatio;\n\t\tvar me = this;\n\t\tvar isHorizontal = me.isHorizontal();\n\t\tvar optionTicks = me.options.ticks.minor;\n\t\tvar tickCount = ticks.length;\n\t\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\n\t\tvar cosRotation = Math.cos(labelRotationRadians);\n\t\tvar longestRotatedLabel = me.longestLabelWidth * cosRotation;\n\t\tvar result = [];\n\t\tvar i, tick, shouldSkip;\n\n\t\t// figure out the maximum number of gridlines to show\n\t\tvar maxTicks;\n\t\tif (optionTicks.maxTicksLimit) {\n\t\t\tmaxTicks = optionTicks.maxTicksLimit;\n\t\t}\n\n\t\tif (isHorizontal) {\n\t\t\tskipRatio = false;\n\n\t\t\tif ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > (me.width - (me.paddingLeft + me.paddingRight))) {\n\t\t\t\tskipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount) / (me.width - (me.paddingLeft + me.paddingRight)));\n\t\t\t}\n\n\t\t\t// if they defined a max number of optionTicks,\n\t\t\t// increase skipRatio until that number is met\n\t\t\tif (maxTicks && tickCount > maxTicks) {\n\t\t\t\tskipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < tickCount; i++) {\n\t\t\ttick = ticks[i];\n\n\t\t\t// Since we always show the last tick,we need may need to hide the last shown one before\n\t\t\tshouldSkip = (skipRatio > 1 && i % skipRatio > 0) || (i % skipRatio === 0 && i + skipRatio >= tickCount);\n\t\t\tif (shouldSkip && i !== tickCount - 1) {\n\t\t\t\t// leave tick in place but make sure it's not displayed (#4635)\n\t\t\t\tdelete tick.label;\n\t\t\t}\n\t\t\tresult.push(tick);\n\t\t}\n\t\treturn result;\n\t},\n\n\t// Actually draw the scale on the canvas\n\t// @param {rectangle} chartArea : the area of the chart to draw full grid lines on\n\tdraw: function(chartArea) {\n\t\tvar me = this;\n\t\tvar options = me.options;\n\t\tif (!options.display) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar context = me.ctx;\n\t\tvar globalDefaults = defaults.global;\n\t\tvar optionTicks = options.ticks.minor;\n\t\tvar optionMajorTicks = options.ticks.major || optionTicks;\n\t\tvar gridLines = options.gridLines;\n\t\tvar scaleLabel = options.scaleLabel;\n\n\t\tvar isRotated = me.labelRotation !== 0;\n\t\tvar isHorizontal = me.isHorizontal();\n\n\t\tvar ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();\n\t\tvar tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);\n\t\tvar tickFont = parseFontOptions(optionTicks);\n\t\tvar majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);\n\t\tvar majorTickFont = parseFontOptions(optionMajorTicks);\n\n\t\tvar tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\n\n\t\tvar scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);\n\t\tvar scaleLabelFont = parseFontOptions(scaleLabel);\n\t\tvar scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);\n\t\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\n\n\t\tvar itemsToDraw = [];\n\n\t\tvar axisWidth = me.options.gridLines.lineWidth;\n\t\tvar xTickStart = options.position === 'right' ? me.left : me.right - axisWidth - tl;\n\t\tvar xTickEnd = options.position === 'right' ? me.left + tl : me.right;\n\t\tvar yTickStart = options.position === 'bottom' ? me.top + axisWidth : me.bottom - tl - axisWidth;\n\t\tvar yTickEnd = options.position === 'bottom' ? me.top + axisWidth + tl : me.bottom + axisWidth;\n\n\t\thelpers.each(ticks, function(tick, index) {\n\t\t\t// autoskipper skipped this tick (#4635)\n\t\t\tif (helpers.isNullOrUndef(tick.label)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar label = tick.label;\n\t\t\tvar lineWidth, lineColor, borderDash, borderDashOffset;\n\t\t\tif (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {\n\t\t\t\t// Draw the first index specially\n\t\t\t\tlineWidth = gridLines.zeroLineWidth;\n\t\t\t\tlineColor = gridLines.zeroLineColor;\n\t\t\t\tborderDash = gridLines.zeroLineBorderDash;\n\t\t\t\tborderDashOffset = gridLines.zeroLineBorderDashOffset;\n\t\t\t} else {\n\t\t\t\tlineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);\n\t\t\t\tlineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);\n\t\t\t\tborderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);\n\t\t\t\tborderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);\n\t\t\t}\n\n\t\t\t// Common properties\n\t\t\tvar tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;\n\t\t\tvar textAlign = 'middle';\n\t\t\tvar textBaseline = 'middle';\n\t\t\tvar tickPadding = optionTicks.padding;\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tvar labelYOffset = tl + tickPadding;\n\n\t\t\t\tif (options.position === 'bottom') {\n\t\t\t\t\t// bottom\n\t\t\t\t\ttextBaseline = !isRotated ? 'top' : 'middle';\n\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'right';\n\t\t\t\t\tlabelY = me.top + labelYOffset;\n\t\t\t\t} else {\n\t\t\t\t\t// top\n\t\t\t\t\ttextBaseline = !isRotated ? 'bottom' : 'middle';\n\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'left';\n\t\t\t\t\tlabelY = me.bottom - labelYOffset;\n\t\t\t\t}\n\n\t\t\t\tvar xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);\n\t\t\t\tif (xLineValue < me.left) {\n\t\t\t\t\tlineColor = 'rgba(0,0,0,0)';\n\t\t\t\t}\n\t\t\t\txLineValue += helpers.aliasPixel(lineWidth);\n\n\t\t\t\tlabelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)\n\n\t\t\t\ttx1 = tx2 = x1 = x2 = xLineValue;\n\t\t\t\tty1 = yTickStart;\n\t\t\t\tty2 = yTickEnd;\n\t\t\t\ty1 = chartArea.top;\n\t\t\t\ty2 = chartArea.bottom + axisWidth;\n\t\t\t} else {\n\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\tvar labelXOffset;\n\n\t\t\t\tif (optionTicks.mirror) {\n\t\t\t\t\ttextAlign = isLeft ? 'left' : 'right';\n\t\t\t\t\tlabelXOffset = tickPadding;\n\t\t\t\t} else {\n\t\t\t\t\ttextAlign = isLeft ? 'right' : 'left';\n\t\t\t\t\tlabelXOffset = tl + tickPadding;\n\t\t\t\t}\n\n\t\t\t\tlabelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;\n\n\t\t\t\tvar yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);\n\t\t\t\tif (yLineValue < me.top) {\n\t\t\t\t\tlineColor = 'rgba(0,0,0,0)';\n\t\t\t\t}\n\t\t\t\tyLineValue += helpers.aliasPixel(lineWidth);\n\n\t\t\t\tlabelY = me.getPixelForTick(index) + optionTicks.labelOffset;\n\n\t\t\t\ttx1 = xTickStart;\n\t\t\t\ttx2 = xTickEnd;\n\t\t\t\tx1 = chartArea.left;\n\t\t\t\tx2 = chartArea.right + axisWidth;\n\t\t\t\tty1 = ty2 = y1 = y2 = yLineValue;\n\t\t\t}\n\n\t\t\titemsToDraw.push({\n\t\t\t\ttx1: tx1,\n\t\t\t\tty1: ty1,\n\t\t\t\ttx2: tx2,\n\t\t\t\tty2: ty2,\n\t\t\t\tx1: x1,\n\t\t\t\ty1: y1,\n\t\t\t\tx2: x2,\n\t\t\t\ty2: y2,\n\t\t\t\tlabelX: labelX,\n\t\t\t\tlabelY: labelY,\n\t\t\t\tglWidth: lineWidth,\n\t\t\t\tglColor: lineColor,\n\t\t\t\tglBorderDash: borderDash,\n\t\t\t\tglBorderDashOffset: borderDashOffset,\n\t\t\t\trotation: -1 * labelRotationRadians,\n\t\t\t\tlabel: label,\n\t\t\t\tmajor: tick.major,\n\t\t\t\ttextBaseline: textBaseline,\n\t\t\t\ttextAlign: textAlign\n\t\t\t});\n\t\t});\n\n\t\t// Draw all of the tick labels, tick marks, and grid lines at the correct places\n\t\thelpers.each(itemsToDraw, function(itemToDraw) {\n\t\t\tif (gridLines.display) {\n\t\t\t\tcontext.save();\n\t\t\t\tcontext.lineWidth = itemToDraw.glWidth;\n\t\t\t\tcontext.strokeStyle = itemToDraw.glColor;\n\t\t\t\tif (context.setLineDash) {\n\t\t\t\t\tcontext.setLineDash(itemToDraw.glBorderDash);\n\t\t\t\t\tcontext.lineDashOffset = itemToDraw.glBorderDashOffset;\n\t\t\t\t}\n\n\t\t\t\tcontext.beginPath();\n\n\t\t\t\tif (gridLines.drawTicks) {\n\t\t\t\t\tcontext.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n\t\t\t\t\tcontext.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n\t\t\t\t}\n\n\t\t\t\tif (gridLines.drawOnChartArea) {\n\t\t\t\t\tcontext.moveTo(itemToDraw.x1, itemToDraw.y1);\n\t\t\t\t\tcontext.lineTo(itemToDraw.x2, itemToDraw.y2);\n\t\t\t\t}\n\n\t\t\t\tcontext.stroke();\n\t\t\t\tcontext.restore();\n\t\t\t}\n\n\t\t\tif (optionTicks.display) {\n\t\t\t\t// Make sure we draw text in the correct color and font\n\t\t\t\tcontext.save();\n\t\t\t\tcontext.translate(itemToDraw.labelX, itemToDraw.labelY);\n\t\t\t\tcontext.rotate(itemToDraw.rotation);\n\t\t\t\tcontext.font = itemToDraw.major ? majorTickFont.font : tickFont.font;\n\t\t\t\tcontext.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;\n\t\t\t\tcontext.textBaseline = itemToDraw.textBaseline;\n\t\t\t\tcontext.textAlign = itemToDraw.textAlign;\n\n\t\t\t\tvar label = itemToDraw.label;\n\t\t\t\tif (helpers.isArray(label)) {\n\t\t\t\t\tvar lineCount = label.length;\n\t\t\t\t\tvar lineHeight = tickFont.size * 1.5;\n\t\t\t\t\tvar y = me.isHorizontal() ? 0 : -lineHeight * (lineCount - 1) / 2;\n\n\t\t\t\t\tfor (var i = 0; i < lineCount; ++i) {\n\t\t\t\t\t\t// We just make sure the multiline element is a string here..\n\t\t\t\t\t\tcontext.fillText('' + label[i], 0, y);\n\t\t\t\t\t\t// apply same lineSpacing as calculated @ L#320\n\t\t\t\t\t\ty += lineHeight;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcontext.fillText(label, 0, 0);\n\t\t\t\t}\n\t\t\t\tcontext.restore();\n\t\t\t}\n\t\t});\n\n\t\tif (scaleLabel.display) {\n\t\t\t// Draw the scale label\n\t\t\tvar scaleLabelX;\n\t\t\tvar scaleLabelY;\n\t\t\tvar rotation = 0;\n\t\t\tvar halfLineHeight = parseLineHeight(scaleLabel) / 2;\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tscaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width\n\t\t\t\tscaleLabelY = options.position === 'bottom'\n\t\t\t\t\t? me.bottom - halfLineHeight - scaleLabelPadding.bottom\n\t\t\t\t\t: me.top + halfLineHeight + scaleLabelPadding.top;\n\t\t\t} else {\n\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\tscaleLabelX = isLeft\n\t\t\t\t\t? me.left + halfLineHeight + scaleLabelPadding.top\n\t\t\t\t\t: me.right - halfLineHeight - scaleLabelPadding.top;\n\t\t\t\tscaleLabelY = me.top + ((me.bottom - me.top) / 2);\n\t\t\t\trotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n\t\t\t}\n\n\t\t\tcontext.save();\n\t\t\tcontext.translate(scaleLabelX, scaleLabelY);\n\t\t\tcontext.rotate(rotation);\n\t\t\tcontext.textAlign = 'center';\n\t\t\tcontext.textBaseline = 'middle';\n\t\t\tcontext.fillStyle = scaleLabelFontColor; // render in correct colour\n\t\t\tcontext.font = scaleLabelFont.font;\n\t\t\tcontext.fillText(scaleLabel.labelString, 0, 0);\n\t\t\tcontext.restore();\n\t\t}\n\n\t\tif (gridLines.drawBorder) {\n\t\t\t// Draw the line at the edge of the axis\n\t\t\tcontext.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);\n\t\t\tcontext.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);\n\t\t\tvar x1 = me.left;\n\t\t\tvar x2 = me.right + axisWidth;\n\t\t\tvar y1 = me.top;\n\t\t\tvar y2 = me.bottom + axisWidth;\n\n\t\t\tvar aliasPixel = helpers.aliasPixel(context.lineWidth);\n\t\t\tif (isHorizontal) {\n\t\t\t\ty1 = y2 = options.position === 'top' ? me.bottom : me.top;\n\t\t\t\ty1 += aliasPixel;\n\t\t\t\ty2 += aliasPixel;\n\t\t\t} else {\n\t\t\t\tx1 = x2 = options.position === 'left' ? me.right : me.left;\n\t\t\t\tx1 += aliasPixel;\n\t\t\t\tx2 += aliasPixel;\n\t\t\t}\n\n\t\t\tcontext.beginPath();\n\t\t\tcontext.moveTo(x1, y1);\n\t\t\tcontext.lineTo(x2, y2);\n\t\t\tcontext.stroke();\n\t\t}\n\t}\n});\n"]},"metadata":{},"sourceType":"script"}