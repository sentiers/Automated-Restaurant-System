{"ast":null,"code":"'use strict';\n\nvar helpers = require('../helpers/index');\n\nfunction filterByPosition(array, position) {\n  return helpers.where(array, function (v) {\n    return v.position === position;\n  });\n}\n\nfunction sortByWeight(array, reverse) {\n  array.forEach(function (v, i) {\n    v._tmpIndex_ = i;\n    return v;\n  });\n  array.sort(function (a, b) {\n    var v0 = reverse ? b : a;\n    var v1 = reverse ? a : b;\n    return v0.weight === v1.weight ? v0._tmpIndex_ - v1._tmpIndex_ : v0.weight - v1.weight;\n  });\n  array.forEach(function (v) {\n    delete v._tmpIndex_;\n  });\n}\n/**\n * @interface ILayoutItem\n * @prop {String} position - The position of the item in the chart layout. Possible values are\n * 'left', 'top', 'right', 'bottom', and 'chartArea'\n * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down\n * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n * @prop {Function} update - Takes two parameters: width and height. Returns size of item\n * @prop {Function} getPadding -  Returns an object with padding on the edges\n * @prop {Number} width - Width of item. Must be valid after update()\n * @prop {Number} height - Height of item. Must be valid after update()\n * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update\n * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update\n * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update\n * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n */\n// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n// It is this service's responsibility of carrying out that layout.\n\n\nmodule.exports = {\n  defaults: {},\n\n  /**\n   * Register a box to a chart.\n   * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n   * @param {Chart} chart - the chart to use\n   * @param {ILayoutItem} item - the item to add to be layed out\n   */\n  addBox: function (chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    } // initialize item with default values\n\n\n    item.fullWidth = item.fullWidth || false;\n    item.position = item.position || 'top';\n    item.weight = item.weight || 0;\n    chart.boxes.push(item);\n  },\n\n  /**\n   * Remove a layoutItem from a chart\n   * @param {Chart} chart - the chart to remove the box from\n   * @param {Object} layoutItem - the item to remove from the layout\n   */\n  removeBox: function (chart, layoutItem) {\n    var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n\n    if (index !== -1) {\n      chart.boxes.splice(index, 1);\n    }\n  },\n\n  /**\n   * Sets (or updates) options on the given `item`.\n   * @param {Chart} chart - the chart in which the item lives (or will be added to)\n   * @param {Object} item - the item to configure with the given options\n   * @param {Object} options - the new item options.\n   */\n  configure: function (chart, item, options) {\n    var props = ['fullWidth', 'position', 'weight'];\n    var ilen = props.length;\n    var i = 0;\n    var prop;\n\n    for (; i < ilen; ++i) {\n      prop = props[i];\n\n      if (options.hasOwnProperty(prop)) {\n        item[prop] = options[prop];\n      }\n    }\n  },\n\n  /**\n   * Fits boxes of the given chart into the given size by having each box measure itself\n   * then running a fitting algorithm\n   * @param {Chart} chart - the chart\n   * @param {Number} width - the width to fit into\n   * @param {Number} height - the height to fit into\n   */\n  update: function (chart, width, height) {\n    if (!chart) {\n      return;\n    }\n\n    var layoutOptions = chart.options.layout || {};\n    var padding = helpers.options.toPadding(layoutOptions.padding);\n    var leftPadding = padding.left;\n    var rightPadding = padding.right;\n    var topPadding = padding.top;\n    var bottomPadding = padding.bottom;\n    var leftBoxes = filterByPosition(chart.boxes, 'left');\n    var rightBoxes = filterByPosition(chart.boxes, 'right');\n    var topBoxes = filterByPosition(chart.boxes, 'top');\n    var bottomBoxes = filterByPosition(chart.boxes, 'bottom');\n    var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea'); // Sort boxes by weight. A higher weight is further away from the chart area\n\n    sortByWeight(leftBoxes, true);\n    sortByWeight(rightBoxes, false);\n    sortByWeight(topBoxes, true);\n    sortByWeight(bottomBoxes, false); // Essentially we now have any number of boxes on each of the 4 sides.\n    // Our canvas looks like the following.\n    // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n    // B1 is the bottom axis\n    // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n    // These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n    // an error will be thrown.\n    //\n    // |----------------------------------------------------|\n    // |                  T1 (Full Width)                   |\n    // |----------------------------------------------------|\n    // |    |    |                 T2                  |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    | C1 |                           | C2 |    |\n    // |    |    |----|                           |----|    |\n    // |    |    |                                     |    |\n    // | L1 | L2 |           ChartArea (C0)            | R1 |\n    // |    |    |                                     |    |\n    // |    |    |----|                           |----|    |\n    // |    |    | C3 |                           | C4 |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    |                 B1                  |    |\n    // |----------------------------------------------------|\n    // |                  B2 (Full Width)                   |\n    // |----------------------------------------------------|\n    //\n    // What we do to find the best sizing, we do the following\n    // 1. Determine the minimum size of the chart area.\n    // 2. Split the remaining width equally between each vertical axis\n    // 3. Split the remaining height equally between each horizontal axis\n    // 4. Give each layout the maximum size it can be. The layout will return it's minimum size\n    // 5. Adjust the sizes of each axis based on it's minimum reported size.\n    // 6. Refit each axis\n    // 7. Position each axis in the final location\n    // 8. Tell the chart the final location of the chart area\n    // 9. Tell any axes that overlay the chart area the positions of the chart area\n    // Step 1\n\n    var chartWidth = width - leftPadding - rightPadding;\n    var chartHeight = height - topPadding - bottomPadding;\n    var chartAreaWidth = chartWidth / 2; // min 50%\n\n    var chartAreaHeight = chartHeight / 2; // min 50%\n    // Step 2\n\n    var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length); // Step 3\n\n    var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length); // Step 4\n\n    var maxChartAreaWidth = chartWidth;\n    var maxChartAreaHeight = chartHeight;\n    var minBoxSizes = [];\n\n    function getMinimumBoxSize(box) {\n      var minSize;\n      var isHorizontal = box.isHorizontal();\n\n      if (isHorizontal) {\n        minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\n        maxChartAreaHeight -= minSize.height;\n      } else {\n        minSize = box.update(verticalBoxWidth, maxChartAreaHeight);\n        maxChartAreaWidth -= minSize.width;\n      }\n\n      minBoxSizes.push({\n        horizontal: isHorizontal,\n        minSize: minSize,\n        box: box\n      });\n    }\n\n    helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize); // If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\n\n    var maxHorizontalLeftPadding = 0;\n    var maxHorizontalRightPadding = 0;\n    var maxVerticalTopPadding = 0;\n    var maxVerticalBottomPadding = 0;\n    helpers.each(topBoxes.concat(bottomBoxes), function (horizontalBox) {\n      if (horizontalBox.getPadding) {\n        var boxPadding = horizontalBox.getPadding();\n        maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\n        maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\n      }\n    });\n    helpers.each(leftBoxes.concat(rightBoxes), function (verticalBox) {\n      if (verticalBox.getPadding) {\n        var boxPadding = verticalBox.getPadding();\n        maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\n        maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\n      }\n    }); // At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\n    // be if the axes are drawn at their minimum sizes.\n    // Steps 5 & 6\n\n    var totalLeftBoxesWidth = leftPadding;\n    var totalRightBoxesWidth = rightPadding;\n    var totalTopBoxesHeight = topPadding;\n    var totalBottomBoxesHeight = bottomPadding; // Function to fit a box\n\n    function fitBox(box) {\n      var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minBox) {\n        return minBox.box === box;\n      });\n\n      if (minBoxSize) {\n        if (box.isHorizontal()) {\n          var scaleMargin = {\n            left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\n            right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\n            top: 0,\n            bottom: 0\n          }; // Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\n          // on the margin. Sometimes they need to increase in size slightly\n\n          box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\n        } else {\n          box.update(minBoxSize.minSize.width, maxChartAreaHeight);\n        }\n      }\n    } // Update, and calculate the left and right margins for the horizontal boxes\n\n\n    helpers.each(leftBoxes.concat(rightBoxes), fitBox);\n    helpers.each(leftBoxes, function (box) {\n      totalLeftBoxesWidth += box.width;\n    });\n    helpers.each(rightBoxes, function (box) {\n      totalRightBoxesWidth += box.width;\n    }); // Set the Left and Right margins for the horizontal boxes\n\n    helpers.each(topBoxes.concat(bottomBoxes), fitBox); // Figure out how much margin is on the top and bottom of the vertical boxes\n\n    helpers.each(topBoxes, function (box) {\n      totalTopBoxesHeight += box.height;\n    });\n    helpers.each(bottomBoxes, function (box) {\n      totalBottomBoxesHeight += box.height;\n    });\n\n    function finalFitVerticalBox(box) {\n      var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minSize) {\n        return minSize.box === box;\n      });\n      var scaleMargin = {\n        left: 0,\n        right: 0,\n        top: totalTopBoxesHeight,\n        bottom: totalBottomBoxesHeight\n      };\n\n      if (minBoxSize) {\n        box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\n      }\n    } // Let the left layout know the final margin\n\n\n    helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox); // Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\n\n    totalLeftBoxesWidth = leftPadding;\n    totalRightBoxesWidth = rightPadding;\n    totalTopBoxesHeight = topPadding;\n    totalBottomBoxesHeight = bottomPadding;\n    helpers.each(leftBoxes, function (box) {\n      totalLeftBoxesWidth += box.width;\n    });\n    helpers.each(rightBoxes, function (box) {\n      totalRightBoxesWidth += box.width;\n    });\n    helpers.each(topBoxes, function (box) {\n      totalTopBoxesHeight += box.height;\n    });\n    helpers.each(bottomBoxes, function (box) {\n      totalBottomBoxesHeight += box.height;\n    }); // We may be adding some padding to account for rotated x axis labels\n\n    var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\n    totalLeftBoxesWidth += leftPaddingAddition;\n    totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\n    var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\n    totalTopBoxesHeight += topPaddingAddition;\n    totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0); // Figure out if our chart area changed. This would occur if the dataset layout label rotation\n    // changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\n    // without calling `fit` again\n\n    var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\n    var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\n\n    if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\n      helpers.each(leftBoxes, function (box) {\n        box.height = newMaxChartAreaHeight;\n      });\n      helpers.each(rightBoxes, function (box) {\n        box.height = newMaxChartAreaHeight;\n      });\n      helpers.each(topBoxes, function (box) {\n        if (!box.fullWidth) {\n          box.width = newMaxChartAreaWidth;\n        }\n      });\n      helpers.each(bottomBoxes, function (box) {\n        if (!box.fullWidth) {\n          box.width = newMaxChartAreaWidth;\n        }\n      });\n      maxChartAreaHeight = newMaxChartAreaHeight;\n      maxChartAreaWidth = newMaxChartAreaWidth;\n    } // Step 7 - Position the boxes\n\n\n    var left = leftPadding + leftPaddingAddition;\n    var top = topPadding + topPaddingAddition;\n\n    function placeBox(box) {\n      if (box.isHorizontal()) {\n        box.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\n        box.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\n        box.top = top;\n        box.bottom = top + box.height; // Move to next point\n\n        top = box.bottom;\n      } else {\n        box.left = left;\n        box.right = left + box.width;\n        box.top = totalTopBoxesHeight;\n        box.bottom = totalTopBoxesHeight + maxChartAreaHeight; // Move to next point\n\n        left = box.right;\n      }\n    }\n\n    helpers.each(leftBoxes.concat(topBoxes), placeBox); // Account for chart width and height\n\n    left += maxChartAreaWidth;\n    top += maxChartAreaHeight;\n    helpers.each(rightBoxes, placeBox);\n    helpers.each(bottomBoxes, placeBox); // Step 8\n\n    chart.chartArea = {\n      left: totalLeftBoxesWidth,\n      top: totalTopBoxesHeight,\n      right: totalLeftBoxesWidth + maxChartAreaWidth,\n      bottom: totalTopBoxesHeight + maxChartAreaHeight\n    }; // Step 9\n\n    helpers.each(chartAreaBoxes, function (box) {\n      box.left = chart.chartArea.left;\n      box.top = chart.chartArea.top;\n      box.right = chart.chartArea.right;\n      box.bottom = chart.chartArea.bottom;\n      box.update(maxChartAreaWidth, maxChartAreaHeight);\n    });\n  }\n};","map":{"version":3,"sources":["C:/Users/Administrator/.git/asdf/Source Files/node_modules/chart.js/src/core/core.layouts.js"],"names":["helpers","require","filterByPosition","array","position","where","v","sortByWeight","reverse","forEach","i","_tmpIndex_","sort","a","b","v0","v1","weight","module","exports","defaults","addBox","chart","item","boxes","fullWidth","push","removeBox","layoutItem","index","indexOf","splice","configure","options","props","ilen","length","prop","hasOwnProperty","update","width","height","layoutOptions","layout","padding","toPadding","leftPadding","left","rightPadding","right","topPadding","top","bottomPadding","bottom","leftBoxes","rightBoxes","topBoxes","bottomBoxes","chartAreaBoxes","chartWidth","chartHeight","chartAreaWidth","chartAreaHeight","verticalBoxWidth","horizontalBoxHeight","maxChartAreaWidth","maxChartAreaHeight","minBoxSizes","getMinimumBoxSize","box","minSize","isHorizontal","horizontal","each","concat","maxHorizontalLeftPadding","maxHorizontalRightPadding","maxVerticalTopPadding","maxVerticalBottomPadding","horizontalBox","getPadding","boxPadding","Math","max","verticalBox","totalLeftBoxesWidth","totalRightBoxesWidth","totalTopBoxesHeight","totalBottomBoxesHeight","fitBox","minBoxSize","findNextWhere","minBox","scaleMargin","finalFitVerticalBox","leftPaddingAddition","topPaddingAddition","newMaxChartAreaHeight","newMaxChartAreaWidth","placeBox","chartArea"],"mappings":"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","sourcesContent":["'use strict';\n\nvar helpers = require('../helpers/index');\n\nfunction filterByPosition(array, position) {\n\treturn helpers.where(array, function(v) {\n\t\treturn v.position === position;\n\t});\n}\n\nfunction sortByWeight(array, reverse) {\n\tarray.forEach(function(v, i) {\n\t\tv._tmpIndex_ = i;\n\t\treturn v;\n\t});\n\tarray.sort(function(a, b) {\n\t\tvar v0 = reverse ? b : a;\n\t\tvar v1 = reverse ? a : b;\n\t\treturn v0.weight === v1.weight ?\n\t\t\tv0._tmpIndex_ - v1._tmpIndex_ :\n\t\t\tv0.weight - v1.weight;\n\t});\n\tarray.forEach(function(v) {\n\t\tdelete v._tmpIndex_;\n\t});\n}\n\n/**\n * @interface ILayoutItem\n * @prop {String} position - The position of the item in the chart layout. Possible values are\n * 'left', 'top', 'right', 'bottom', and 'chartArea'\n * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down\n * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n * @prop {Function} update - Takes two parameters: width and height. Returns size of item\n * @prop {Function} getPadding -  Returns an object with padding on the edges\n * @prop {Number} width - Width of item. Must be valid after update()\n * @prop {Number} height - Height of item. Must be valid after update()\n * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update\n * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update\n * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update\n * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n */\n\n// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n// It is this service's responsibility of carrying out that layout.\nmodule.exports = {\n\tdefaults: {},\n\n\t/**\n\t * Register a box to a chart.\n\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n\t * @param {Chart} chart - the chart to use\n\t * @param {ILayoutItem} item - the item to add to be layed out\n\t */\n\taddBox: function(chart, item) {\n\t\tif (!chart.boxes) {\n\t\t\tchart.boxes = [];\n\t\t}\n\n\t\t// initialize item with default values\n\t\titem.fullWidth = item.fullWidth || false;\n\t\titem.position = item.position || 'top';\n\t\titem.weight = item.weight || 0;\n\n\t\tchart.boxes.push(item);\n\t},\n\n\t/**\n\t * Remove a layoutItem from a chart\n\t * @param {Chart} chart - the chart to remove the box from\n\t * @param {Object} layoutItem - the item to remove from the layout\n\t */\n\tremoveBox: function(chart, layoutItem) {\n\t\tvar index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n\t\tif (index !== -1) {\n\t\t\tchart.boxes.splice(index, 1);\n\t\t}\n\t},\n\n\t/**\n\t * Sets (or updates) options on the given `item`.\n\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\n\t * @param {Object} item - the item to configure with the given options\n\t * @param {Object} options - the new item options.\n\t */\n\tconfigure: function(chart, item, options) {\n\t\tvar props = ['fullWidth', 'position', 'weight'];\n\t\tvar ilen = props.length;\n\t\tvar i = 0;\n\t\tvar prop;\n\n\t\tfor (; i < ilen; ++i) {\n\t\t\tprop = props[i];\n\t\t\tif (options.hasOwnProperty(prop)) {\n\t\t\t\titem[prop] = options[prop];\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Fits boxes of the given chart into the given size by having each box measure itself\n\t * then running a fitting algorithm\n\t * @param {Chart} chart - the chart\n\t * @param {Number} width - the width to fit into\n\t * @param {Number} height - the height to fit into\n\t */\n\tupdate: function(chart, width, height) {\n\t\tif (!chart) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar layoutOptions = chart.options.layout || {};\n\t\tvar padding = helpers.options.toPadding(layoutOptions.padding);\n\t\tvar leftPadding = padding.left;\n\t\tvar rightPadding = padding.right;\n\t\tvar topPadding = padding.top;\n\t\tvar bottomPadding = padding.bottom;\n\n\t\tvar leftBoxes = filterByPosition(chart.boxes, 'left');\n\t\tvar rightBoxes = filterByPosition(chart.boxes, 'right');\n\t\tvar topBoxes = filterByPosition(chart.boxes, 'top');\n\t\tvar bottomBoxes = filterByPosition(chart.boxes, 'bottom');\n\t\tvar chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\n\n\t\t// Sort boxes by weight. A higher weight is further away from the chart area\n\t\tsortByWeight(leftBoxes, true);\n\t\tsortByWeight(rightBoxes, false);\n\t\tsortByWeight(topBoxes, true);\n\t\tsortByWeight(bottomBoxes, false);\n\n\t\t// Essentially we now have any number of boxes on each of the 4 sides.\n\t\t// Our canvas looks like the following.\n\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n\t\t// B1 is the bottom axis\n\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n\t\t// an error will be thrown.\n\t\t//\n\t\t// |----------------------------------------------------|\n\t\t// |                  T1 (Full Width)                   |\n\t\t// |----------------------------------------------------|\n\t\t// |    |    |                 T2                  |    |\n\t\t// |    |----|-------------------------------------|----|\n\t\t// |    |    | C1 |                           | C2 |    |\n\t\t// |    |    |----|                           |----|    |\n\t\t// |    |    |                                     |    |\n\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\n\t\t// |    |    |                                     |    |\n\t\t// |    |    |----|                           |----|    |\n\t\t// |    |    | C3 |                           | C4 |    |\n\t\t// |    |----|-------------------------------------|----|\n\t\t// |    |    |                 B1                  |    |\n\t\t// |----------------------------------------------------|\n\t\t// |                  B2 (Full Width)                   |\n\t\t// |----------------------------------------------------|\n\t\t//\n\t\t// What we do to find the best sizing, we do the following\n\t\t// 1. Determine the minimum size of the chart area.\n\t\t// 2. Split the remaining width equally between each vertical axis\n\t\t// 3. Split the remaining height equally between each horizontal axis\n\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\n\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\n\t\t// 6. Refit each axis\n\t\t// 7. Position each axis in the final location\n\t\t// 8. Tell the chart the final location of the chart area\n\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\n\n\t\t// Step 1\n\t\tvar chartWidth = width - leftPadding - rightPadding;\n\t\tvar chartHeight = height - topPadding - bottomPadding;\n\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\n\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\n\n\t\t// Step 2\n\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\n\n\t\t// Step 3\n\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\n\n\t\t// Step 4\n\t\tvar maxChartAreaWidth = chartWidth;\n\t\tvar maxChartAreaHeight = chartHeight;\n\t\tvar minBoxSizes = [];\n\n\t\tfunction getMinimumBoxSize(box) {\n\t\t\tvar minSize;\n\t\t\tvar isHorizontal = box.isHorizontal();\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\n\t\t\t\tmaxChartAreaHeight -= minSize.height;\n\t\t\t} else {\n\t\t\t\tminSize = box.update(verticalBoxWidth, maxChartAreaHeight);\n\t\t\t\tmaxChartAreaWidth -= minSize.width;\n\t\t\t}\n\n\t\t\tminBoxSizes.push({\n\t\t\t\thorizontal: isHorizontal,\n\t\t\t\tminSize: minSize,\n\t\t\t\tbox: box,\n\t\t\t});\n\t\t}\n\n\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\n\n\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\n\t\tvar maxHorizontalLeftPadding = 0;\n\t\tvar maxHorizontalRightPadding = 0;\n\t\tvar maxVerticalTopPadding = 0;\n\t\tvar maxVerticalBottomPadding = 0;\n\n\t\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\n\t\t\tif (horizontalBox.getPadding) {\n\t\t\t\tvar boxPadding = horizontalBox.getPadding();\n\t\t\t\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\n\t\t\t\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\n\t\t\t}\n\t\t});\n\n\t\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\n\t\t\tif (verticalBox.getPadding) {\n\t\t\t\tvar boxPadding = verticalBox.getPadding();\n\t\t\t\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\n\t\t\t\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\n\t\t\t}\n\t\t});\n\n\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\n\t\t// be if the axes are drawn at their minimum sizes.\n\t\t// Steps 5 & 6\n\t\tvar totalLeftBoxesWidth = leftPadding;\n\t\tvar totalRightBoxesWidth = rightPadding;\n\t\tvar totalTopBoxesHeight = topPadding;\n\t\tvar totalBottomBoxesHeight = bottomPadding;\n\n\t\t// Function to fit a box\n\t\tfunction fitBox(box) {\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\n\t\t\t\treturn minBox.box === box;\n\t\t\t});\n\n\t\t\tif (minBoxSize) {\n\t\t\t\tif (box.isHorizontal()) {\n\t\t\t\t\tvar scaleMargin = {\n\t\t\t\t\t\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\n\t\t\t\t\t\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\tbottom: 0\n\t\t\t\t\t};\n\n\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\n\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\n\t\t\t\t\tbox.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\n\t\t\t\t} else {\n\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Update, and calculate the left and right margins for the horizontal boxes\n\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\n\n\t\thelpers.each(leftBoxes, function(box) {\n\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t});\n\n\t\thelpers.each(rightBoxes, function(box) {\n\t\t\ttotalRightBoxesWidth += box.width;\n\t\t});\n\n\t\t// Set the Left and Right margins for the horizontal boxes\n\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\n\n\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\n\t\thelpers.each(topBoxes, function(box) {\n\t\t\ttotalTopBoxesHeight += box.height;\n\t\t});\n\n\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t});\n\n\t\tfunction finalFitVerticalBox(box) {\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\n\t\t\t\treturn minSize.box === box;\n\t\t\t});\n\n\t\t\tvar scaleMargin = {\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0,\n\t\t\t\ttop: totalTopBoxesHeight,\n\t\t\t\tbottom: totalBottomBoxesHeight\n\t\t\t};\n\n\t\t\tif (minBoxSize) {\n\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\n\t\t\t}\n\t\t}\n\n\t\t// Let the left layout know the final margin\n\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\n\n\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\n\t\ttotalLeftBoxesWidth = leftPadding;\n\t\ttotalRightBoxesWidth = rightPadding;\n\t\ttotalTopBoxesHeight = topPadding;\n\t\ttotalBottomBoxesHeight = bottomPadding;\n\n\t\thelpers.each(leftBoxes, function(box) {\n\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t});\n\n\t\thelpers.each(rightBoxes, function(box) {\n\t\t\ttotalRightBoxesWidth += box.width;\n\t\t});\n\n\t\thelpers.each(topBoxes, function(box) {\n\t\t\ttotalTopBoxesHeight += box.height;\n\t\t});\n\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t});\n\n\t\t// We may be adding some padding to account for rotated x axis labels\n\t\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\n\t\ttotalLeftBoxesWidth += leftPaddingAddition;\n\t\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\n\n\t\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\n\t\ttotalTopBoxesHeight += topPaddingAddition;\n\t\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\n\n\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\n\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\n\t\t// without calling `fit` again\n\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\n\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\n\n\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\n\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t});\n\n\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t});\n\n\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\tif (!box.fullWidth) {\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\tif (!box.fullWidth) {\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\n\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\n\t\t}\n\n\t\t// Step 7 - Position the boxes\n\t\tvar left = leftPadding + leftPaddingAddition;\n\t\tvar top = topPadding + topPaddingAddition;\n\n\t\tfunction placeBox(box) {\n\t\t\tif (box.isHorizontal()) {\n\t\t\t\tbox.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\n\t\t\t\tbox.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\n\t\t\t\tbox.top = top;\n\t\t\t\tbox.bottom = top + box.height;\n\n\t\t\t\t// Move to next point\n\t\t\t\ttop = box.bottom;\n\n\t\t\t} else {\n\n\t\t\t\tbox.left = left;\n\t\t\t\tbox.right = left + box.width;\n\t\t\t\tbox.top = totalTopBoxesHeight;\n\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\n\n\t\t\t\t// Move to next point\n\t\t\t\tleft = box.right;\n\t\t\t}\n\t\t}\n\n\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\n\n\t\t// Account for chart width and height\n\t\tleft += maxChartAreaWidth;\n\t\ttop += maxChartAreaHeight;\n\n\t\thelpers.each(rightBoxes, placeBox);\n\t\thelpers.each(bottomBoxes, placeBox);\n\n\t\t// Step 8\n\t\tchart.chartArea = {\n\t\t\tleft: totalLeftBoxesWidth,\n\t\t\ttop: totalTopBoxesHeight,\n\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\n\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\n\t\t};\n\n\t\t// Step 9\n\t\thelpers.each(chartAreaBoxes, function(box) {\n\t\t\tbox.left = chart.chartArea.left;\n\t\t\tbox.top = chart.chartArea.top;\n\t\t\tbox.right = chart.chartArea.right;\n\t\t\tbox.bottom = chart.chartArea.bottom;\n\n\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\n\t\t});\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}