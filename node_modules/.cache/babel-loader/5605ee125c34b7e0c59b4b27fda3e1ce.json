{"ast":null,"code":"'use strict';\n\nvar defaults = require('../core/core.defaults');\n\nvar elements = require('../elements/index');\n\nvar helpers = require('../helpers/index');\n\ndefaults._set('bar', {\n  hover: {\n    mode: 'label'\n  },\n  scales: {\n    xAxes: [{\n      type: 'category',\n      // Specific to Bar Controller\n      categoryPercentage: 0.8,\n      barPercentage: 0.9,\n      // offset settings\n      offset: true,\n      // grid line settings\n      gridLines: {\n        offsetGridLines: true\n      }\n    }],\n    yAxes: [{\n      type: 'linear'\n    }]\n  }\n});\n\ndefaults._set('horizontalBar', {\n  hover: {\n    mode: 'index',\n    axis: 'y'\n  },\n  scales: {\n    xAxes: [{\n      type: 'linear',\n      position: 'bottom'\n    }],\n    yAxes: [{\n      position: 'left',\n      type: 'category',\n      // Specific to Horizontal Bar Controller\n      categoryPercentage: 0.8,\n      barPercentage: 0.9,\n      // offset settings\n      offset: true,\n      // grid line settings\n      gridLines: {\n        offsetGridLines: true\n      }\n    }]\n  },\n  elements: {\n    rectangle: {\n      borderSkipped: 'left'\n    }\n  },\n  tooltips: {\n    callbacks: {\n      title: function (item, data) {\n        // Pick first xLabel for now\n        var title = '';\n\n        if (item.length > 0) {\n          if (item[0].yLabel) {\n            title = item[0].yLabel;\n          } else if (data.labels.length > 0 && item[0].index < data.labels.length) {\n            title = data.labels[item[0].index];\n          }\n        }\n\n        return title;\n      },\n      label: function (item, data) {\n        var datasetLabel = data.datasets[item.datasetIndex].label || '';\n        return datasetLabel + ': ' + item.xLabel;\n      }\n    },\n    mode: 'index',\n    axis: 'y'\n  }\n});\n/**\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n * @private\n */\n\n\nfunction computeMinSampleSize(scale, pixels) {\n  var min = scale.isHorizontal() ? scale.width : scale.height;\n  var ticks = scale.getTicks();\n  var prev, curr, i, ilen;\n\n  for (i = 1, ilen = pixels.length; i < ilen; ++i) {\n    min = Math.min(min, pixels[i] - pixels[i - 1]);\n  }\n\n  for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    min = i > 0 ? Math.min(min, curr - prev) : min;\n    prev = curr;\n  }\n\n  return min;\n}\n/**\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\n * @private\n */\n\n\nfunction computeFitCategoryTraits(index, ruler, options) {\n  var thickness = options.barThickness;\n  var count = ruler.stackCount;\n  var curr = ruler.pixels[index];\n  var size, ratio;\n\n  if (helpers.isNullOrUndef(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    // When bar thickness is enforced, category and bar percentages are ignored.\n    // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n    // and deprecate barPercentage since this value is ignored when thickness is absolute.\n    size = thickness * count;\n    ratio = 1;\n  }\n\n  return {\n    chunk: size / count,\n    ratio: ratio,\n    start: curr - size / 2\n  };\n}\n/**\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n * percentage options are 1), based on the previous and following categories. This mode\n * generates bars with different widths when data are not evenly spaced.\n * @private\n */\n\n\nfunction computeFlexCategoryTraits(index, ruler, options) {\n  var pixels = ruler.pixels;\n  var curr = pixels[index];\n  var prev = index > 0 ? pixels[index - 1] : null;\n  var next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  var percent = options.categoryPercentage;\n  var start, size;\n\n  if (prev === null) {\n    // first data: its size is double based on the next point or,\n    // if it's also the last data, we use the scale end extremity.\n    prev = curr - (next === null ? ruler.end - curr : next - curr);\n  }\n\n  if (next === null) {\n    // last data: its size is also double based on the previous point.\n    next = curr + curr - prev;\n  }\n\n  start = curr - (curr - prev) / 2 * percent;\n  size = (next - prev) / 2 * percent;\n  return {\n    chunk: size / ruler.stackCount,\n    ratio: options.barPercentage,\n    start: start\n  };\n}\n\nmodule.exports = function (Chart) {\n  Chart.controllers.bar = Chart.DatasetController.extend({\n    dataElementType: elements.Rectangle,\n    initialize: function () {\n      var me = this;\n      var meta;\n      Chart.DatasetController.prototype.initialize.apply(me, arguments);\n      meta = me.getMeta();\n      meta.stack = me.getDataset().stack;\n      meta.bar = true;\n    },\n    update: function (reset) {\n      var me = this;\n      var rects = me.getMeta().data;\n      var i, ilen;\n      me._ruler = me.getRuler();\n\n      for (i = 0, ilen = rects.length; i < ilen; ++i) {\n        me.updateElement(rects[i], i, reset);\n      }\n    },\n    updateElement: function (rectangle, index, reset) {\n      var me = this;\n      var chart = me.chart;\n      var meta = me.getMeta();\n      var dataset = me.getDataset();\n      var custom = rectangle.custom || {};\n      var rectangleOptions = chart.options.elements.rectangle;\n      rectangle._xScale = me.getScaleForId(meta.xAxisID);\n      rectangle._yScale = me.getScaleForId(meta.yAxisID);\n      rectangle._datasetIndex = me.index;\n      rectangle._index = index;\n      rectangle._model = {\n        datasetLabel: dataset.label,\n        label: chart.data.labels[index],\n        borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,\n        backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),\n        borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),\n        borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)\n      };\n      me.updateElementGeometry(rectangle, index, reset);\n      rectangle.pivot();\n    },\n\n    /**\n     * @private\n     */\n    updateElementGeometry: function (rectangle, index, reset) {\n      var me = this;\n      var model = rectangle._model;\n      var vscale = me.getValueScale();\n      var base = vscale.getBasePixel();\n      var horizontal = vscale.isHorizontal();\n      var ruler = me._ruler || me.getRuler();\n      var vpixels = me.calculateBarValuePixels(me.index, index);\n      var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);\n      model.horizontal = horizontal;\n      model.base = reset ? base : vpixels.base;\n      model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;\n      model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;\n      model.height = horizontal ? ipixels.size : undefined;\n      model.width = horizontal ? undefined : ipixels.size;\n    },\n\n    /**\n     * @private\n     */\n    getValueScaleId: function () {\n      return this.getMeta().yAxisID;\n    },\n\n    /**\n     * @private\n     */\n    getIndexScaleId: function () {\n      return this.getMeta().xAxisID;\n    },\n\n    /**\n     * @private\n     */\n    getValueScale: function () {\n      return this.getScaleForId(this.getValueScaleId());\n    },\n\n    /**\n     * @private\n     */\n    getIndexScale: function () {\n      return this.getScaleForId(this.getIndexScaleId());\n    },\n\n    /**\n     * Returns the stacks based on groups and bar visibility.\n     * @param {Number} [last] - The dataset index\n     * @returns {Array} The stack list\n     * @private\n     */\n    _getStacks: function (last) {\n      var me = this;\n      var chart = me.chart;\n      var scale = me.getIndexScale();\n      var stacked = scale.options.stacked;\n      var ilen = last === undefined ? chart.data.datasets.length : last + 1;\n      var stacks = [];\n      var i, meta;\n\n      for (i = 0; i < ilen; ++i) {\n        meta = chart.getDatasetMeta(i);\n\n        if (meta.bar && chart.isDatasetVisible(i) && (stacked === false || stacked === true && stacks.indexOf(meta.stack) === -1 || stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1))) {\n          stacks.push(meta.stack);\n        }\n      }\n\n      return stacks;\n    },\n\n    /**\n     * Returns the effective number of stacks based on groups and bar visibility.\n     * @private\n     */\n    getStackCount: function () {\n      return this._getStacks().length;\n    },\n\n    /**\n     * Returns the stack index for the given dataset based on groups and bar visibility.\n     * @param {Number} [datasetIndex] - The dataset index\n     * @param {String} [name] - The stack name to find\n     * @returns {Number} The stack index\n     * @private\n     */\n    getStackIndex: function (datasetIndex, name) {\n      var stacks = this._getStacks(datasetIndex);\n\n      var index = name !== undefined ? stacks.indexOf(name) : -1; // indexOf returns -1 if element is not present\n\n      return index === -1 ? stacks.length - 1 : index;\n    },\n\n    /**\n     * @private\n     */\n    getRuler: function () {\n      var me = this;\n      var scale = me.getIndexScale();\n      var stackCount = me.getStackCount();\n      var datasetIndex = me.index;\n      var isHorizontal = scale.isHorizontal();\n      var start = isHorizontal ? scale.left : scale.top;\n      var end = start + (isHorizontal ? scale.width : scale.height);\n      var pixels = [];\n      var i, ilen, min;\n\n      for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {\n        pixels.push(scale.getPixelForValue(null, i, datasetIndex));\n      }\n\n      min = helpers.isNullOrUndef(scale.options.barThickness) ? computeMinSampleSize(scale, pixels) : -1;\n      return {\n        min: min,\n        pixels: pixels,\n        start: start,\n        end: end,\n        stackCount: stackCount,\n        scale: scale\n      };\n    },\n\n    /**\n     * Note: pixel values are not clamped to the scale area.\n     * @private\n     */\n    calculateBarValuePixels: function (datasetIndex, index) {\n      var me = this;\n      var chart = me.chart;\n      var meta = me.getMeta();\n      var scale = me.getValueScale();\n      var datasets = chart.data.datasets;\n      var value = scale.getRightValue(datasets[datasetIndex].data[index]);\n      var stacked = scale.options.stacked;\n      var stack = meta.stack;\n      var start = 0;\n      var i, imeta, ivalue, base, head, size;\n\n      if (stacked || stacked === undefined && stack !== undefined) {\n        for (i = 0; i < datasetIndex; ++i) {\n          imeta = chart.getDatasetMeta(i);\n\n          if (imeta.bar && imeta.stack === stack && imeta.controller.getValueScaleId() === scale.id && chart.isDatasetVisible(i)) {\n            ivalue = scale.getRightValue(datasets[i].data[index]);\n\n            if (value < 0 && ivalue < 0 || value >= 0 && ivalue > 0) {\n              start += ivalue;\n            }\n          }\n        }\n      }\n\n      base = scale.getPixelForValue(start);\n      head = scale.getPixelForValue(start + value);\n      size = (head - base) / 2;\n      return {\n        size: size,\n        base: base,\n        head: head,\n        center: head + size / 2\n      };\n    },\n\n    /**\n     * @private\n     */\n    calculateBarIndexPixels: function (datasetIndex, index, ruler) {\n      var me = this;\n      var options = ruler.scale.options;\n      var range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options) : computeFitCategoryTraits(index, ruler, options);\n      var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);\n      var center = range.start + range.chunk * stackIndex + range.chunk / 2;\n      var size = Math.min(helpers.valueOrDefault(options.maxBarThickness, Infinity), range.chunk * range.ratio);\n      return {\n        base: center - size / 2,\n        head: center + size / 2,\n        center: center,\n        size: size\n      };\n    },\n    draw: function () {\n      var me = this;\n      var chart = me.chart;\n      var scale = me.getValueScale();\n      var rects = me.getMeta().data;\n      var dataset = me.getDataset();\n      var ilen = rects.length;\n      var i = 0;\n      helpers.canvas.clipArea(chart.ctx, chart.chartArea);\n\n      for (; i < ilen; ++i) {\n        if (!isNaN(scale.getRightValue(dataset.data[i]))) {\n          rects[i].draw();\n        }\n      }\n\n      helpers.canvas.unclipArea(chart.ctx);\n    }\n  });\n  Chart.controllers.horizontalBar = Chart.controllers.bar.extend({\n    /**\n     * @private\n     */\n    getValueScaleId: function () {\n      return this.getMeta().xAxisID;\n    },\n\n    /**\n     * @private\n     */\n    getIndexScaleId: function () {\n      return this.getMeta().yAxisID;\n    }\n  });\n};","map":{"version":3,"sources":["C:/Users/Administrator/.git/asdf/Source Files/node_modules/chart.js/src/controllers/controller.bar.js"],"names":["defaults","require","elements","helpers","_set","hover","mode","scales","xAxes","type","categoryPercentage","barPercentage","offset","gridLines","offsetGridLines","yAxes","axis","position","rectangle","borderSkipped","tooltips","callbacks","title","item","data","length","yLabel","labels","index","label","datasetLabel","datasets","datasetIndex","xLabel","computeMinSampleSize","scale","pixels","min","isHorizontal","width","height","ticks","getTicks","prev","curr","i","ilen","Math","getPixelForTick","computeFitCategoryTraits","ruler","options","thickness","barThickness","count","stackCount","size","ratio","isNullOrUndef","chunk","start","computeFlexCategoryTraits","next","percent","end","module","exports","Chart","controllers","bar","DatasetController","extend","dataElementType","Rectangle","initialize","me","meta","prototype","apply","arguments","getMeta","stack","getDataset","update","reset","rects","_ruler","getRuler","updateElement","chart","dataset","custom","rectangleOptions","_xScale","getScaleForId","xAxisID","_yScale","yAxisID","_datasetIndex","_index","_model","backgroundColor","valueAtIndexOrDefault","borderColor","borderWidth","updateElementGeometry","pivot","model","vscale","getValueScale","base","getBasePixel","horizontal","vpixels","calculateBarValuePixels","ipixels","calculateBarIndexPixels","x","head","center","y","undefined","getValueScaleId","getIndexScaleId","getIndexScale","_getStacks","last","stacked","stacks","getDatasetMeta","isDatasetVisible","indexOf","push","getStackCount","getStackIndex","name","left","top","getPixelForValue","value","getRightValue","imeta","ivalue","controller","id","range","stackIndex","valueOrDefault","maxBarThickness","Infinity","draw","canvas","clipArea","ctx","chartArea","isNaN","unclipArea","horizontalBar"],"mappings":"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","sourcesContent":["'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('bar', {\n\thover: {\n\t\tmode: 'label'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'category',\n\n\t\t\t// Specific to Bar Controller\n\t\t\tcategoryPercentage: 0.8,\n\t\t\tbarPercentage: 0.9,\n\n\t\t\t// offset settings\n\t\t\toffset: true,\n\n\t\t\t// grid line settings\n\t\t\tgridLines: {\n\t\t\t\toffsetGridLines: true\n\t\t\t}\n\t\t}],\n\n\t\tyAxes: [{\n\t\t\ttype: 'linear'\n\t\t}]\n\t}\n});\n\ndefaults._set('horizontalBar', {\n\thover: {\n\t\tmode: 'index',\n\t\taxis: 'y'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'linear',\n\t\t\tposition: 'bottom'\n\t\t}],\n\n\t\tyAxes: [{\n\t\t\tposition: 'left',\n\t\t\ttype: 'category',\n\n\t\t\t// Specific to Horizontal Bar Controller\n\t\t\tcategoryPercentage: 0.8,\n\t\t\tbarPercentage: 0.9,\n\n\t\t\t// offset settings\n\t\t\toffset: true,\n\n\t\t\t// grid line settings\n\t\t\tgridLines: {\n\t\t\t\toffsetGridLines: true\n\t\t\t}\n\t\t}]\n\t},\n\n\telements: {\n\t\trectangle: {\n\t\t\tborderSkipped: 'left'\n\t\t}\n\t},\n\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function(item, data) {\n\t\t\t\t// Pick first xLabel for now\n\t\t\t\tvar title = '';\n\n\t\t\t\tif (item.length > 0) {\n\t\t\t\t\tif (item[0].yLabel) {\n\t\t\t\t\t\ttitle = item[0].yLabel;\n\t\t\t\t\t} else if (data.labels.length > 0 && item[0].index < data.labels.length) {\n\t\t\t\t\t\ttitle = data.labels[item[0].index];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn title;\n\t\t\t},\n\n\t\t\tlabel: function(item, data) {\n\t\t\t\tvar datasetLabel = data.datasets[item.datasetIndex].label || '';\n\t\t\t\treturn datasetLabel + ': ' + item.xLabel;\n\t\t\t}\n\t\t},\n\t\tmode: 'index',\n\t\taxis: 'y'\n\t}\n});\n\n/**\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n * @private\n */\nfunction computeMinSampleSize(scale, pixels) {\n\tvar min = scale.isHorizontal() ? scale.width : scale.height;\n\tvar ticks = scale.getTicks();\n\tvar prev, curr, i, ilen;\n\n\tfor (i = 1, ilen = pixels.length; i < ilen; ++i) {\n\t\tmin = Math.min(min, pixels[i] - pixels[i - 1]);\n\t}\n\n\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\tcurr = scale.getPixelForTick(i);\n\t\tmin = i > 0 ? Math.min(min, curr - prev) : min;\n\t\tprev = curr;\n\t}\n\n\treturn min;\n}\n\n/**\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\n * @private\n */\nfunction computeFitCategoryTraits(index, ruler, options) {\n\tvar thickness = options.barThickness;\n\tvar count = ruler.stackCount;\n\tvar curr = ruler.pixels[index];\n\tvar size, ratio;\n\n\tif (helpers.isNullOrUndef(thickness)) {\n\t\tsize = ruler.min * options.categoryPercentage;\n\t\tratio = options.barPercentage;\n\t} else {\n\t\t// When bar thickness is enforced, category and bar percentages are ignored.\n\t\t// Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n\t\t// and deprecate barPercentage since this value is ignored when thickness is absolute.\n\t\tsize = thickness * count;\n\t\tratio = 1;\n\t}\n\n\treturn {\n\t\tchunk: size / count,\n\t\tratio: ratio,\n\t\tstart: curr - (size / 2)\n\t};\n}\n\n/**\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n * percentage options are 1), based on the previous and following categories. This mode\n * generates bars with different widths when data are not evenly spaced.\n * @private\n */\nfunction computeFlexCategoryTraits(index, ruler, options) {\n\tvar pixels = ruler.pixels;\n\tvar curr = pixels[index];\n\tvar prev = index > 0 ? pixels[index - 1] : null;\n\tvar next = index < pixels.length - 1 ? pixels[index + 1] : null;\n\tvar percent = options.categoryPercentage;\n\tvar start, size;\n\n\tif (prev === null) {\n\t\t// first data: its size is double based on the next point or,\n\t\t// if it's also the last data, we use the scale end extremity.\n\t\tprev = curr - (next === null ? ruler.end - curr : next - curr);\n\t}\n\n\tif (next === null) {\n\t\t// last data: its size is also double based on the previous point.\n\t\tnext = curr + curr - prev;\n\t}\n\n\tstart = curr - ((curr - prev) / 2) * percent;\n\tsize = ((next - prev) / 2) * percent;\n\n\treturn {\n\t\tchunk: size / ruler.stackCount,\n\t\tratio: options.barPercentage,\n\t\tstart: start\n\t};\n}\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.bar = Chart.DatasetController.extend({\n\n\t\tdataElementType: elements.Rectangle,\n\n\t\tinitialize: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta;\n\n\t\t\tChart.DatasetController.prototype.initialize.apply(me, arguments);\n\n\t\t\tmeta = me.getMeta();\n\t\t\tmeta.stack = me.getDataset().stack;\n\t\t\tmeta.bar = true;\n\t\t},\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar rects = me.getMeta().data;\n\t\t\tvar i, ilen;\n\n\t\t\tme._ruler = me.getRuler();\n\n\t\t\tfor (i = 0, ilen = rects.length; i < ilen; ++i) {\n\t\t\t\tme.updateElement(rects[i], i, reset);\n\t\t\t}\n\t\t},\n\n\t\tupdateElement: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar rectangleOptions = chart.options.elements.rectangle;\n\n\t\t\trectangle._xScale = me.getScaleForId(meta.xAxisID);\n\t\t\trectangle._yScale = me.getScaleForId(meta.yAxisID);\n\t\t\trectangle._datasetIndex = me.index;\n\t\t\trectangle._index = index;\n\n\t\t\trectangle._model = {\n\t\t\t\tdatasetLabel: dataset.label,\n\t\t\t\tlabel: chart.data.labels[index],\n\t\t\t\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,\n\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),\n\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),\n\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)\n\t\t\t};\n\n\t\t\tme.updateElementGeometry(rectangle, index, reset);\n\n\t\t\trectangle.pivot();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tupdateElementGeometry: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar model = rectangle._model;\n\t\t\tvar vscale = me.getValueScale();\n\t\t\tvar base = vscale.getBasePixel();\n\t\t\tvar horizontal = vscale.isHorizontal();\n\t\t\tvar ruler = me._ruler || me.getRuler();\n\t\t\tvar vpixels = me.calculateBarValuePixels(me.index, index);\n\t\t\tvar ipixels = me.calculateBarIndexPixels(me.index, index, ruler);\n\n\t\t\tmodel.horizontal = horizontal;\n\t\t\tmodel.base = reset ? base : vpixels.base;\n\t\t\tmodel.x = horizontal ? reset ? base : vpixels.head : ipixels.center;\n\t\t\tmodel.y = horizontal ? ipixels.center : reset ? base : vpixels.head;\n\t\t\tmodel.height = horizontal ? ipixels.size : undefined;\n\t\t\tmodel.width = horizontal ? undefined : ipixels.size;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScaleId: function() {\n\t\t\treturn this.getMeta().yAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScaleId: function() {\n\t\t\treturn this.getMeta().xAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScale: function() {\n\t\t\treturn this.getScaleForId(this.getValueScaleId());\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScale: function() {\n\t\t\treturn this.getScaleForId(this.getIndexScaleId());\n\t\t},\n\n\t\t/**\n\t\t * Returns the stacks based on groups and bar visibility.\n\t\t * @param {Number} [last] - The dataset index\n\t\t * @returns {Array} The stack list\n\t\t * @private\n\t\t */\n\t\t_getStacks: function(last) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar scale = me.getIndexScale();\n\t\t\tvar stacked = scale.options.stacked;\n\t\t\tvar ilen = last === undefined ? chart.data.datasets.length : last + 1;\n\t\t\tvar stacks = [];\n\t\t\tvar i, meta;\n\n\t\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\tif (meta.bar && chart.isDatasetVisible(i) &&\n\t\t\t\t\t(stacked === false ||\n\t\t\t\t\t(stacked === true && stacks.indexOf(meta.stack) === -1) ||\n\t\t\t\t\t(stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {\n\t\t\t\t\tstacks.push(meta.stack);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn stacks;\n\t\t},\n\n\t\t/**\n\t\t * Returns the effective number of stacks based on groups and bar visibility.\n\t\t * @private\n\t\t */\n\t\tgetStackCount: function() {\n\t\t\treturn this._getStacks().length;\n\t\t},\n\n\t\t/**\n\t\t * Returns the stack index for the given dataset based on groups and bar visibility.\n\t\t * @param {Number} [datasetIndex] - The dataset index\n\t\t * @param {String} [name] - The stack name to find\n\t\t * @returns {Number} The stack index\n\t\t * @private\n\t\t */\n\t\tgetStackIndex: function(datasetIndex, name) {\n\t\t\tvar stacks = this._getStacks(datasetIndex);\n\t\t\tvar index = (name !== undefined)\n\t\t\t\t? stacks.indexOf(name)\n\t\t\t\t: -1; // indexOf returns -1 if element is not present\n\n\t\t\treturn (index === -1)\n\t\t\t\t? stacks.length - 1\n\t\t\t\t: index;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetRuler: function() {\n\t\t\tvar me = this;\n\t\t\tvar scale = me.getIndexScale();\n\t\t\tvar stackCount = me.getStackCount();\n\t\t\tvar datasetIndex = me.index;\n\t\t\tvar isHorizontal = scale.isHorizontal();\n\t\t\tvar start = isHorizontal ? scale.left : scale.top;\n\t\t\tvar end = start + (isHorizontal ? scale.width : scale.height);\n\t\t\tvar pixels = [];\n\t\t\tvar i, ilen, min;\n\n\t\t\tfor (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {\n\t\t\t\tpixels.push(scale.getPixelForValue(null, i, datasetIndex));\n\t\t\t}\n\n\t\t\tmin = helpers.isNullOrUndef(scale.options.barThickness)\n\t\t\t\t? computeMinSampleSize(scale, pixels)\n\t\t\t\t: -1;\n\n\t\t\treturn {\n\t\t\t\tmin: min,\n\t\t\t\tpixels: pixels,\n\t\t\t\tstart: start,\n\t\t\t\tend: end,\n\t\t\t\tstackCount: stackCount,\n\t\t\t\tscale: scale\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Note: pixel values are not clamped to the scale area.\n\t\t * @private\n\t\t */\n\t\tcalculateBarValuePixels: function(datasetIndex, index) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar scale = me.getValueScale();\n\t\t\tvar datasets = chart.data.datasets;\n\t\t\tvar value = scale.getRightValue(datasets[datasetIndex].data[index]);\n\t\t\tvar stacked = scale.options.stacked;\n\t\t\tvar stack = meta.stack;\n\t\t\tvar start = 0;\n\t\t\tvar i, imeta, ivalue, base, head, size;\n\n\t\t\tif (stacked || (stacked === undefined && stack !== undefined)) {\n\t\t\t\tfor (i = 0; i < datasetIndex; ++i) {\n\t\t\t\t\timeta = chart.getDatasetMeta(i);\n\n\t\t\t\t\tif (imeta.bar &&\n\t\t\t\t\t\timeta.stack === stack &&\n\t\t\t\t\t\timeta.controller.getValueScaleId() === scale.id &&\n\t\t\t\t\t\tchart.isDatasetVisible(i)) {\n\n\t\t\t\t\t\tivalue = scale.getRightValue(datasets[i].data[index]);\n\t\t\t\t\t\tif ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {\n\t\t\t\t\t\t\tstart += ivalue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbase = scale.getPixelForValue(start);\n\t\t\thead = scale.getPixelForValue(start + value);\n\t\t\tsize = (head - base) / 2;\n\n\t\t\treturn {\n\t\t\t\tsize: size,\n\t\t\t\tbase: base,\n\t\t\t\thead: head,\n\t\t\t\tcenter: head + size / 2\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tcalculateBarIndexPixels: function(datasetIndex, index, ruler) {\n\t\t\tvar me = this;\n\t\t\tvar options = ruler.scale.options;\n\t\t\tvar range = options.barThickness === 'flex'\n\t\t\t\t? computeFlexCategoryTraits(index, ruler, options)\n\t\t\t\t: computeFitCategoryTraits(index, ruler, options);\n\n\t\t\tvar stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);\n\t\t\tvar center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n\t\t\tvar size = Math.min(\n\t\t\t\thelpers.valueOrDefault(options.maxBarThickness, Infinity),\n\t\t\t\trange.chunk * range.ratio);\n\n\t\t\treturn {\n\t\t\t\tbase: center - size / 2,\n\t\t\t\thead: center + size / 2,\n\t\t\t\tcenter: center,\n\t\t\t\tsize: size\n\t\t\t};\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar scale = me.getValueScale();\n\t\t\tvar rects = me.getMeta().data;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar ilen = rects.length;\n\t\t\tvar i = 0;\n\n\t\t\thelpers.canvas.clipArea(chart.ctx, chart.chartArea);\n\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\tif (!isNaN(scale.getRightValue(dataset.data[i]))) {\n\t\t\t\t\trects[i].draw();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thelpers.canvas.unclipArea(chart.ctx);\n\t\t},\n\t});\n\n\tChart.controllers.horizontalBar = Chart.controllers.bar.extend({\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScaleId: function() {\n\t\t\treturn this.getMeta().xAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScaleId: function() {\n\t\t\treturn this.getMeta().yAxisID;\n\t\t}\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}