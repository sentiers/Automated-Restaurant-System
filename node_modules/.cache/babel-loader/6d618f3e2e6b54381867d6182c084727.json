{"ast":null,"code":"'use strict';\n\nvar helpers = require('../helpers/index');\n\nvar Scale = require('../core/core.scale');\n\nvar scaleService = require('../core/core.scaleService');\n\nvar Ticks = require('../core/core.ticks');\n/**\n * Generate a set of logarithmic ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {Array<Number>} array of tick values\n */\n\n\nfunction generateTicks(generationOptions, dataRange) {\n  var ticks = [];\n  var valueOrDefault = helpers.valueOrDefault; // Figure out what the max number of ticks we can support it is based on the size of\n  // the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n  // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n  // the graph\n\n  var tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n  var endExp = Math.floor(helpers.log10(dataRange.max));\n  var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n  var exp, significand;\n\n  if (tickVal === 0) {\n    exp = Math.floor(helpers.log10(dataRange.minNotZero));\n    significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n    ticks.push(tickVal);\n    tickVal = significand * Math.pow(10, exp);\n  } else {\n    exp = Math.floor(helpers.log10(tickVal));\n    significand = Math.floor(tickVal / Math.pow(10, exp));\n  }\n\n  var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n\n  do {\n    ticks.push(tickVal);\n    ++significand;\n\n    if (significand === 10) {\n      significand = 1;\n      ++exp;\n      precision = exp >= 0 ? 1 : precision;\n    }\n\n    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n  } while (exp < endExp || exp === endExp && significand < endSignificand);\n\n  var lastTick = valueOrDefault(generationOptions.max, tickVal);\n  ticks.push(lastTick);\n  return ticks;\n}\n\nmodule.exports = function (Chart) {\n  var defaultConfig = {\n    position: 'left',\n    // label settings\n    ticks: {\n      callback: Ticks.formatters.logarithmic\n    }\n  };\n  var LogarithmicScale = Scale.extend({\n    determineDataLimits: function () {\n      var me = this;\n      var opts = me.options;\n      var chart = me.chart;\n      var data = chart.data;\n      var datasets = data.datasets;\n      var isHorizontal = me.isHorizontal();\n\n      function IDMatches(meta) {\n        return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n      } // Calculate Range\n\n\n      me.min = null;\n      me.max = null;\n      me.minNotZero = null;\n      var hasStacks = opts.stacked;\n\n      if (hasStacks === undefined) {\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          if (hasStacks) {\n            return;\n          }\n\n          var meta = chart.getDatasetMeta(datasetIndex);\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {\n            hasStacks = true;\n          }\n        });\n      }\n\n      if (opts.stacked || hasStacks) {\n        var valuesPerStack = {};\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          var meta = chart.getDatasetMeta(datasetIndex);\n          var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n          opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n            if (valuesPerStack[key] === undefined) {\n              valuesPerStack[key] = [];\n            }\n\n            helpers.each(dataset.data, function (rawValue, index) {\n              var values = valuesPerStack[key];\n              var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored\n\n              if (isNaN(value) || meta.data[index].hidden || value < 0) {\n                return;\n              }\n\n              values[index] = values[index] || 0;\n              values[index] += value;\n            });\n          }\n        });\n        helpers.each(valuesPerStack, function (valuesForType) {\n          if (valuesForType.length > 0) {\n            var minVal = helpers.min(valuesForType);\n            var maxVal = helpers.max(valuesForType);\n            me.min = me.min === null ? minVal : Math.min(me.min, minVal);\n            me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n          }\n        });\n      } else {\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          var meta = chart.getDatasetMeta(datasetIndex);\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n            helpers.each(dataset.data, function (rawValue, index) {\n              var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored\n\n              if (isNaN(value) || meta.data[index].hidden || value < 0) {\n                return;\n              }\n\n              if (me.min === null) {\n                me.min = value;\n              } else if (value < me.min) {\n                me.min = value;\n              }\n\n              if (me.max === null) {\n                me.max = value;\n              } else if (value > me.max) {\n                me.max = value;\n              }\n\n              if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n                me.minNotZero = value;\n              }\n            });\n          }\n        });\n      } // Common base implementation to handle ticks.min, ticks.max\n\n\n      this.handleTickRangeOptions();\n    },\n    handleTickRangeOptions: function () {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks;\n      var valueOrDefault = helpers.valueOrDefault;\n      var DEFAULT_MIN = 1;\n      var DEFAULT_MAX = 10;\n      me.min = valueOrDefault(tickOpts.min, me.min);\n      me.max = valueOrDefault(tickOpts.max, me.max);\n\n      if (me.min === me.max) {\n        if (me.min !== 0 && me.min !== null) {\n          me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n          me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n        } else {\n          me.min = DEFAULT_MIN;\n          me.max = DEFAULT_MAX;\n        }\n      }\n\n      if (me.min === null) {\n        me.min = Math.pow(10, Math.floor(helpers.log10(me.max)) - 1);\n      }\n\n      if (me.max === null) {\n        me.max = me.min !== 0 ? Math.pow(10, Math.floor(helpers.log10(me.min)) + 1) : DEFAULT_MAX;\n      }\n\n      if (me.minNotZero === null) {\n        if (me.min > 0) {\n          me.minNotZero = me.min;\n        } else if (me.max < 1) {\n          me.minNotZero = Math.pow(10, Math.floor(helpers.log10(me.max)));\n        } else {\n          me.minNotZero = DEFAULT_MIN;\n        }\n      }\n    },\n    buildTicks: function () {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks;\n      var reverse = !me.isHorizontal();\n      var generationOptions = {\n        min: tickOpts.min,\n        max: tickOpts.max\n      };\n      var ticks = me.ticks = generateTicks(generationOptions, me); // At this point, we need to update our max and min given the tick values since we have expanded the\n      // range of the scale\n\n      me.max = helpers.max(ticks);\n      me.min = helpers.min(ticks);\n\n      if (tickOpts.reverse) {\n        reverse = !reverse;\n        me.start = me.max;\n        me.end = me.min;\n      } else {\n        me.start = me.min;\n        me.end = me.max;\n      }\n\n      if (reverse) {\n        ticks.reverse();\n      }\n    },\n    convertTicksToLabels: function () {\n      this.tickValues = this.ticks.slice();\n      Scale.prototype.convertTicksToLabels.call(this);\n    },\n    // Get the correct tooltip label\n    getLabelForIndex: function (index, datasetIndex) {\n      return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n    },\n    getPixelForTick: function (index) {\n      return this.getPixelForValue(this.tickValues[index]);\n    },\n\n    /**\n     * Returns the value of the first tick.\n     * @param {Number} value - The minimum not zero value.\n     * @return {Number} The first tick value.\n     * @private\n     */\n    _getFirstTickValue: function (value) {\n      var exp = Math.floor(helpers.log10(value));\n      var significand = Math.floor(value / Math.pow(10, exp));\n      return significand * Math.pow(10, exp);\n    },\n    getPixelForValue: function (value) {\n      var me = this;\n      var reverse = me.options.ticks.reverse;\n      var log10 = helpers.log10;\n\n      var firstTickValue = me._getFirstTickValue(me.minNotZero);\n\n      var offset = 0;\n      var innerDimension, pixel, start, end, sign;\n      value = +me.getRightValue(value);\n\n      if (reverse) {\n        start = me.end;\n        end = me.start;\n        sign = -1;\n      } else {\n        start = me.start;\n        end = me.end;\n        sign = 1;\n      }\n\n      if (me.isHorizontal()) {\n        innerDimension = me.width;\n        pixel = reverse ? me.right : me.left;\n      } else {\n        innerDimension = me.height;\n        sign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)\n\n        pixel = reverse ? me.top : me.bottom;\n      }\n\n      if (value !== start) {\n        if (start === 0) {\n          // include zero tick\n          offset = helpers.getValueOrDefault(me.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);\n          innerDimension -= offset;\n          start = firstTickValue;\n        }\n\n        if (value !== 0) {\n          offset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));\n        }\n\n        pixel += sign * offset;\n      }\n\n      return pixel;\n    },\n    getValueForPixel: function (pixel) {\n      var me = this;\n      var reverse = me.options.ticks.reverse;\n      var log10 = helpers.log10;\n\n      var firstTickValue = me._getFirstTickValue(me.minNotZero);\n\n      var innerDimension, start, end, value;\n\n      if (reverse) {\n        start = me.end;\n        end = me.start;\n      } else {\n        start = me.start;\n        end = me.end;\n      }\n\n      if (me.isHorizontal()) {\n        innerDimension = me.width;\n        value = reverse ? me.right - pixel : pixel - me.left;\n      } else {\n        innerDimension = me.height;\n        value = reverse ? pixel - me.top : me.bottom - pixel;\n      }\n\n      if (value !== start) {\n        if (start === 0) {\n          // include zero tick\n          var offset = helpers.getValueOrDefault(me.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);\n          value -= offset;\n          innerDimension -= offset;\n          start = firstTickValue;\n        }\n\n        value *= log10(end) - log10(start);\n        value /= innerDimension;\n        value = Math.pow(10, log10(start) + value);\n      }\n\n      return value;\n    }\n  });\n  scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\n};","map":{"version":3,"sources":["C:/Users/Administrator/.git/asdf/Source Files/node_modules/chart.js/src/scales/scale.logarithmic.js"],"names":["helpers","require","Scale","scaleService","Ticks","generateTicks","generationOptions","dataRange","ticks","valueOrDefault","tickVal","min","Math","pow","floor","log10","endExp","max","endSignificand","ceil","exp","significand","minNotZero","push","precision","abs","round","lastTick","module","exports","Chart","defaultConfig","position","callback","formatters","logarithmic","LogarithmicScale","extend","determineDataLimits","me","opts","options","chart","data","datasets","isHorizontal","IDMatches","meta","xAxisID","id","yAxisID","hasStacks","stacked","undefined","each","dataset","datasetIndex","getDatasetMeta","isDatasetVisible","stack","valuesPerStack","key","type","join","rawValue","index","values","value","getRightValue","isNaN","hidden","valuesForType","length","minVal","maxVal","handleTickRangeOptions","tickOpts","DEFAULT_MIN","DEFAULT_MAX","buildTicks","reverse","start","end","convertTicksToLabels","tickValues","slice","prototype","call","getLabelForIndex","getPixelForTick","getPixelForValue","_getFirstTickValue","firstTickValue","offset","innerDimension","pixel","sign","width","right","left","height","top","bottom","getValueOrDefault","fontSize","defaults","global","defaultFontSize","getValueForPixel","registerScaleType"],"mappings":"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","sourcesContent":["'use strict';\n\nvar helpers = require('../helpers/index');\nvar Scale = require('../core/core.scale');\nvar scaleService = require('../core/core.scaleService');\nvar Ticks = require('../core/core.ticks');\n\n/**\n * Generate a set of logarithmic ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {Array<Number>} array of tick values\n */\nfunction generateTicks(generationOptions, dataRange) {\n\tvar ticks = [];\n\tvar valueOrDefault = helpers.valueOrDefault;\n\n\t// Figure out what the max number of ticks we can support it is based on the size of\n\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t// the graph\n\tvar tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n\n\tvar endExp = Math.floor(helpers.log10(dataRange.max));\n\tvar endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n\tvar exp, significand;\n\n\tif (tickVal === 0) {\n\t\texp = Math.floor(helpers.log10(dataRange.minNotZero));\n\t\tsignificand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n\n\t\tticks.push(tickVal);\n\t\ttickVal = significand * Math.pow(10, exp);\n\t} else {\n\t\texp = Math.floor(helpers.log10(tickVal));\n\t\tsignificand = Math.floor(tickVal / Math.pow(10, exp));\n\t}\n\tvar precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n\n\tdo {\n\t\tticks.push(tickVal);\n\n\t\t++significand;\n\t\tif (significand === 10) {\n\t\t\tsignificand = 1;\n\t\t\t++exp;\n\t\t\tprecision = exp >= 0 ? 1 : precision;\n\t\t}\n\n\t\ttickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n\t} while (exp < endExp || (exp === endExp && significand < endSignificand));\n\n\tvar lastTick = valueOrDefault(generationOptions.max, tickVal);\n\tticks.push(lastTick);\n\n\treturn ticks;\n}\n\n\nmodule.exports = function(Chart) {\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\n\t\t// label settings\n\t\tticks: {\n\t\t\tcallback: Ticks.formatters.logarithmic\n\t\t}\n\t};\n\n\tvar LogarithmicScale = Scale.extend({\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// Calculate Range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\t\t\tme.minNotZero = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\t\tvaluesPerStack[key] = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar values = valuesPerStack[key];\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t// invalid, hidden and negative values are ignored\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden || value < 0) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalues[index] = values[index] || 0;\n\t\t\t\t\t\t\tvalues[index] += value;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tif (valuesForType.length > 0) {\n\t\t\t\t\t\tvar minVal = helpers.min(valuesForType);\n\t\t\t\t\t\tvar maxVal = helpers.max(valuesForType);\n\t\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t// invalid, hidden and negative values are ignored\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden || value < 0) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n\t\t\t\t\t\t\t\tme.minNotZero = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max\n\t\t\tthis.handleTickRangeOptions();\n\t\t},\n\t\thandleTickRangeOptions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\t\tvar DEFAULT_MIN = 1;\n\t\t\tvar DEFAULT_MAX = 10;\n\n\t\t\tme.min = valueOrDefault(tickOpts.min, me.min);\n\t\t\tme.max = valueOrDefault(tickOpts.max, me.max);\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tif (me.min !== 0 && me.min !== null) {\n\t\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n\t\t\t\t\tme.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n\t\t\t\t} else {\n\t\t\t\t\tme.min = DEFAULT_MIN;\n\t\t\t\t\tme.max = DEFAULT_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (me.min === null) {\n\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.max)) - 1);\n\t\t\t}\n\t\t\tif (me.max === null) {\n\t\t\t\tme.max = me.min !== 0\n\t\t\t\t\t? Math.pow(10, Math.floor(helpers.log10(me.min)) + 1)\n\t\t\t\t\t: DEFAULT_MAX;\n\t\t\t}\n\t\t\tif (me.minNotZero === null) {\n\t\t\t\tif (me.min > 0) {\n\t\t\t\t\tme.minNotZero = me.min;\n\t\t\t\t} else if (me.max < 1) {\n\t\t\t\t\tme.minNotZero = Math.pow(10, Math.floor(helpers.log10(me.max)));\n\t\t\t\t} else {\n\t\t\t\t\tme.minNotZero = DEFAULT_MIN;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar reverse = !me.isHorizontal();\n\n\t\t\tvar generationOptions = {\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max\n\t\t\t};\n\t\t\tvar ticks = me.ticks = generateTicks(generationOptions, me);\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\treverse = !reverse;\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t\tif (reverse) {\n\t\t\t\tticks.reverse();\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tthis.tickValues = this.ticks.slice();\n\n\t\t\tScale.prototype.convertTicksToLabels.call(this);\n\t\t},\n\t\t// Get the correct tooltip label\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.tickValues[index]);\n\t\t},\n\t\t/**\n\t\t * Returns the value of the first tick.\n\t\t * @param {Number} value - The minimum not zero value.\n\t\t * @return {Number} The first tick value.\n\t\t * @private\n\t\t */\n\t\t_getFirstTickValue: function(value) {\n\t\t\tvar exp = Math.floor(helpers.log10(value));\n\t\t\tvar significand = Math.floor(value / Math.pow(10, exp));\n\n\t\t\treturn significand * Math.pow(10, exp);\n\t\t},\n\t\tgetPixelForValue: function(value) {\n\t\t\tvar me = this;\n\t\t\tvar reverse = me.options.ticks.reverse;\n\t\t\tvar log10 = helpers.log10;\n\t\t\tvar firstTickValue = me._getFirstTickValue(me.minNotZero);\n\t\t\tvar offset = 0;\n\t\t\tvar innerDimension, pixel, start, end, sign;\n\n\t\t\tvalue = +me.getRightValue(value);\n\t\t\tif (reverse) {\n\t\t\t\tstart = me.end;\n\t\t\t\tend = me.start;\n\t\t\t\tsign = -1;\n\t\t\t} else {\n\t\t\t\tstart = me.start;\n\t\t\t\tend = me.end;\n\t\t\t\tsign = 1;\n\t\t\t}\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tinnerDimension = me.width;\n\t\t\t\tpixel = reverse ? me.right : me.left;\n\t\t\t} else {\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tsign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)\n\t\t\t\tpixel = reverse ? me.top : me.bottom;\n\t\t\t}\n\t\t\tif (value !== start) {\n\t\t\t\tif (start === 0) { // include zero tick\n\t\t\t\t\toffset = helpers.getValueOrDefault(\n\t\t\t\t\t\tme.options.ticks.fontSize,\n\t\t\t\t\t\tChart.defaults.global.defaultFontSize\n\t\t\t\t\t);\n\t\t\t\t\tinnerDimension -= offset;\n\t\t\t\t\tstart = firstTickValue;\n\t\t\t\t}\n\t\t\t\tif (value !== 0) {\n\t\t\t\t\toffset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));\n\t\t\t\t}\n\t\t\t\tpixel += sign * offset;\n\t\t\t}\n\t\t\treturn pixel;\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar reverse = me.options.ticks.reverse;\n\t\t\tvar log10 = helpers.log10;\n\t\t\tvar firstTickValue = me._getFirstTickValue(me.minNotZero);\n\t\t\tvar innerDimension, start, end, value;\n\n\t\t\tif (reverse) {\n\t\t\t\tstart = me.end;\n\t\t\t\tend = me.start;\n\t\t\t} else {\n\t\t\t\tstart = me.start;\n\t\t\t\tend = me.end;\n\t\t\t}\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tinnerDimension = me.width;\n\t\t\t\tvalue = reverse ? me.right - pixel : pixel - me.left;\n\t\t\t} else {\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tvalue = reverse ? pixel - me.top : me.bottom - pixel;\n\t\t\t}\n\t\t\tif (value !== start) {\n\t\t\t\tif (start === 0) { // include zero tick\n\t\t\t\t\tvar offset = helpers.getValueOrDefault(\n\t\t\t\t\t\tme.options.ticks.fontSize,\n\t\t\t\t\t\tChart.defaults.global.defaultFontSize\n\t\t\t\t\t);\n\t\t\t\t\tvalue -= offset;\n\t\t\t\t\tinnerDimension -= offset;\n\t\t\t\t\tstart = firstTickValue;\n\t\t\t\t}\n\t\t\t\tvalue *= log10(end) - log10(start);\n\t\t\t\tvalue /= innerDimension;\n\t\t\t\tvalue = Math.pow(10, log10(start) + value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t});\n\n\tscaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\n};\n"]},"metadata":{},"sourceType":"script"}