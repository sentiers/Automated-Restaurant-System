{"ast":null,"code":"'use strict';\n\nvar defaults = require('../core/core.defaults');\n\nvar helpers = require('../helpers/index');\n\nvar scaleService = require('../core/core.scaleService');\n\nvar Ticks = require('../core/core.ticks');\n\nmodule.exports = function (Chart) {\n  var globalDefaults = defaults.global;\n  var defaultConfig = {\n    display: true,\n    // Boolean - Whether to animate scaling the chart from the centre\n    animate: true,\n    position: 'chartArea',\n    angleLines: {\n      display: true,\n      color: 'rgba(0, 0, 0, 0.1)',\n      lineWidth: 1\n    },\n    gridLines: {\n      circular: false\n    },\n    // label settings\n    ticks: {\n      // Boolean - Show a backdrop to the scale label\n      showLabelBackdrop: true,\n      // String - The colour of the label backdrop\n      backdropColor: 'rgba(255,255,255,0.75)',\n      // Number - The backdrop padding above & below the label in pixels\n      backdropPaddingY: 2,\n      // Number - The backdrop padding to the side of the label in pixels\n      backdropPaddingX: 2,\n      callback: Ticks.formatters.linear\n    },\n    pointLabels: {\n      // Boolean - if true, show point labels\n      display: true,\n      // Number - Point label font size in pixels\n      fontSize: 10,\n      // Function - Used to convert point labels\n      callback: function (label) {\n        return label;\n      }\n    }\n  };\n\n  function getValueCount(scale) {\n    var opts = scale.options;\n    return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;\n  }\n\n  function getPointLabelFontOptions(scale) {\n    var pointLabelOptions = scale.options.pointLabels;\n    var fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);\n    var fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);\n    var fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);\n    var font = helpers.fontString(fontSize, fontStyle, fontFamily);\n    return {\n      size: fontSize,\n      style: fontStyle,\n      family: fontFamily,\n      font: font\n    };\n  }\n\n  function measureLabelSize(ctx, fontSize, label) {\n    if (helpers.isArray(label)) {\n      return {\n        w: helpers.longestText(ctx, ctx.font, label),\n        h: label.length * fontSize + (label.length - 1) * 1.5 * fontSize\n      };\n    }\n\n    return {\n      w: ctx.measureText(label).width,\n      h: fontSize\n    };\n  }\n\n  function determineLimits(angle, pos, size, min, max) {\n    if (angle === min || angle === max) {\n      return {\n        start: pos - size / 2,\n        end: pos + size / 2\n      };\n    } else if (angle < min || angle > max) {\n      return {\n        start: pos - size - 5,\n        end: pos\n      };\n    }\n\n    return {\n      start: pos,\n      end: pos + size + 5\n    };\n  }\n  /**\n   * Helper function to fit a radial linear scale with point labels\n   */\n\n\n  function fitWithPointLabels(scale) {\n    /*\n     * Right, this is really confusing and there is a lot of maths going on here\n     * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n     *\n     * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n     *\n     * Solution:\n     *\n     * We assume the radius of the polygon is half the size of the canvas at first\n     * at each index we check if the text overlaps.\n     *\n     * Where it does, we store that angle and that index.\n     *\n     * After finding the largest index and angle we calculate how much we need to remove\n     * from the shape radius to move the point inwards by that x.\n     *\n     * We average the left and right distances to get the maximum shape radius that can fit in the box\n     * along with labels.\n     *\n     * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n     * on each side, removing that from the size, halving it and adding the left x protrusion width.\n     *\n     * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n     * and position it in the most space efficient manner\n     *\n     * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n     */\n    var plFont = getPointLabelFontOptions(scale); // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n    // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n\n    var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n    var furthestLimits = {\n      r: scale.width,\n      l: 0,\n      t: scale.height,\n      b: 0\n    };\n    var furthestAngles = {};\n    var i, textSize, pointPosition;\n    scale.ctx.font = plFont.font;\n    scale._pointLabelSizes = [];\n    var valueCount = getValueCount(scale);\n\n    for (i = 0; i < valueCount; i++) {\n      pointPosition = scale.getPointPosition(i, largestPossibleRadius);\n      textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');\n      scale._pointLabelSizes[i] = textSize; // Add quarter circle to make degree 0 mean top of circle\n\n      var angleRadians = scale.getIndexAngle(i);\n      var angle = helpers.toDegrees(angleRadians) % 360;\n      var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n      var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\n      if (hLimits.start < furthestLimits.l) {\n        furthestLimits.l = hLimits.start;\n        furthestAngles.l = angleRadians;\n      }\n\n      if (hLimits.end > furthestLimits.r) {\n        furthestLimits.r = hLimits.end;\n        furthestAngles.r = angleRadians;\n      }\n\n      if (vLimits.start < furthestLimits.t) {\n        furthestLimits.t = vLimits.start;\n        furthestAngles.t = angleRadians;\n      }\n\n      if (vLimits.end > furthestLimits.b) {\n        furthestLimits.b = vLimits.end;\n        furthestAngles.b = angleRadians;\n      }\n    }\n\n    scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);\n  }\n  /**\n   * Helper function to fit a radial linear scale with no point labels\n   */\n\n\n  function fit(scale) {\n    var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n    scale.drawingArea = Math.round(largestPossibleRadius);\n    scale.setCenterPoint(0, 0, 0, 0);\n  }\n\n  function getTextAlignForAngle(angle) {\n    if (angle === 0 || angle === 180) {\n      return 'center';\n    } else if (angle < 180) {\n      return 'left';\n    }\n\n    return 'right';\n  }\n\n  function fillText(ctx, text, position, fontSize) {\n    if (helpers.isArray(text)) {\n      var y = position.y;\n      var spacing = 1.5 * fontSize;\n\n      for (var i = 0; i < text.length; ++i) {\n        ctx.fillText(text[i], position.x, y);\n        y += spacing;\n      }\n    } else {\n      ctx.fillText(text, position.x, position.y);\n    }\n  }\n\n  function adjustPointPositionForLabelHeight(angle, textSize, position) {\n    if (angle === 90 || angle === 270) {\n      position.y -= textSize.h / 2;\n    } else if (angle > 270 || angle < 90) {\n      position.y -= textSize.h;\n    }\n  }\n\n  function drawPointLabels(scale) {\n    var ctx = scale.ctx;\n    var opts = scale.options;\n    var angleLineOpts = opts.angleLines;\n    var pointLabelOpts = opts.pointLabels;\n    ctx.lineWidth = angleLineOpts.lineWidth;\n    ctx.strokeStyle = angleLineOpts.color;\n    var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max); // Point Label Font\n\n    var plFont = getPointLabelFontOptions(scale);\n    ctx.textBaseline = 'top';\n\n    for (var i = getValueCount(scale) - 1; i >= 0; i--) {\n      if (angleLineOpts.display) {\n        var outerPosition = scale.getPointPosition(i, outerDistance);\n        ctx.beginPath();\n        ctx.moveTo(scale.xCenter, scale.yCenter);\n        ctx.lineTo(outerPosition.x, outerPosition.y);\n        ctx.stroke();\n        ctx.closePath();\n      }\n\n      if (pointLabelOpts.display) {\n        // Extra 3px out for some label spacing\n        var pointLabelPosition = scale.getPointPosition(i, outerDistance + 5); // Keep this in loop since we may support array properties here\n\n        var pointLabelFontColor = helpers.valueAtIndexOrDefault(pointLabelOpts.fontColor, i, globalDefaults.defaultFontColor);\n        ctx.font = plFont.font;\n        ctx.fillStyle = pointLabelFontColor;\n        var angleRadians = scale.getIndexAngle(i);\n        var angle = helpers.toDegrees(angleRadians);\n        ctx.textAlign = getTextAlignForAngle(angle);\n        adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n        fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);\n      }\n    }\n  }\n\n  function drawRadiusLine(scale, gridLineOpts, radius, index) {\n    var ctx = scale.ctx;\n    ctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);\n    ctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\n\n    if (scale.options.gridLines.circular) {\n      // Draw circular arcs between the points\n      ctx.beginPath();\n      ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n      ctx.closePath();\n      ctx.stroke();\n    } else {\n      // Draw straight lines connecting each index\n      var valueCount = getValueCount(scale);\n\n      if (valueCount === 0) {\n        return;\n      }\n\n      ctx.beginPath();\n      var pointPosition = scale.getPointPosition(0, radius);\n      ctx.moveTo(pointPosition.x, pointPosition.y);\n\n      for (var i = 1; i < valueCount; i++) {\n        pointPosition = scale.getPointPosition(i, radius);\n        ctx.lineTo(pointPosition.x, pointPosition.y);\n      }\n\n      ctx.closePath();\n      ctx.stroke();\n    }\n  }\n\n  function numberOrZero(param) {\n    return helpers.isNumber(param) ? param : 0;\n  }\n\n  var LinearRadialScale = Chart.LinearScaleBase.extend({\n    setDimensions: function () {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks; // Set the unconstrained dimension before label rotation\n\n      me.width = me.maxWidth;\n      me.height = me.maxHeight;\n      me.xCenter = Math.round(me.width / 2);\n      me.yCenter = Math.round(me.height / 2);\n      var minSize = helpers.min([me.height, me.width]);\n      var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n      me.drawingArea = opts.display ? minSize / 2 - (tickFontSize / 2 + tickOpts.backdropPaddingY) : minSize / 2;\n    },\n    determineDataLimits: function () {\n      var me = this;\n      var chart = me.chart;\n      var min = Number.POSITIVE_INFINITY;\n      var max = Number.NEGATIVE_INFINITY;\n      helpers.each(chart.data.datasets, function (dataset, datasetIndex) {\n        if (chart.isDatasetVisible(datasetIndex)) {\n          var meta = chart.getDatasetMeta(datasetIndex);\n          helpers.each(dataset.data, function (rawValue, index) {\n            var value = +me.getRightValue(rawValue);\n\n            if (isNaN(value) || meta.data[index].hidden) {\n              return;\n            }\n\n            min = Math.min(value, min);\n            max = Math.max(value, max);\n          });\n        }\n      });\n      me.min = min === Number.POSITIVE_INFINITY ? 0 : min;\n      me.max = max === Number.NEGATIVE_INFINITY ? 0 : max; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\n      me.handleTickRangeOptions();\n    },\n    getTickLimit: function () {\n      var tickOpts = this.options.ticks;\n      var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n      return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));\n    },\n    convertTicksToLabels: function () {\n      var me = this;\n      Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me); // Point labels\n\n      me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\n    },\n    getLabelForIndex: function (index, datasetIndex) {\n      return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n    },\n    fit: function () {\n      if (this.options.pointLabels.display) {\n        fitWithPointLabels(this);\n      } else {\n        fit(this);\n      }\n    },\n\n    /**\n     * Set radius reductions and determine new radius and center point\n     * @private\n     */\n    setReductions: function (largestPossibleRadius, furthestLimits, furthestAngles) {\n      var me = this;\n      var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n      var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n      var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n      var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);\n      radiusReductionLeft = numberOrZero(radiusReductionLeft);\n      radiusReductionRight = numberOrZero(radiusReductionRight);\n      radiusReductionTop = numberOrZero(radiusReductionTop);\n      radiusReductionBottom = numberOrZero(radiusReductionBottom);\n      me.drawingArea = Math.min(Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n      me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n    },\n    setCenterPoint: function (leftMovement, rightMovement, topMovement, bottomMovement) {\n      var me = this;\n      var maxRight = me.width - rightMovement - me.drawingArea;\n      var maxLeft = leftMovement + me.drawingArea;\n      var maxTop = topMovement + me.drawingArea;\n      var maxBottom = me.height - bottomMovement - me.drawingArea;\n      me.xCenter = Math.round((maxLeft + maxRight) / 2 + me.left);\n      me.yCenter = Math.round((maxTop + maxBottom) / 2 + me.top);\n    },\n    getIndexAngle: function (index) {\n      var angleMultiplier = Math.PI * 2 / getValueCount(this);\n      var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;\n      var startAngleRadians = startAngle * Math.PI * 2 / 360; // Start from the top instead of right, so remove a quarter of the circle\n\n      return index * angleMultiplier + startAngleRadians;\n    },\n    getDistanceFromCenterForValue: function (value) {\n      var me = this;\n\n      if (value === null) {\n        return 0; // null always in center\n      } // Take into account half font size + the yPadding of the top value\n\n\n      var scalingFactor = me.drawingArea / (me.max - me.min);\n\n      if (me.options.ticks.reverse) {\n        return (me.max - value) * scalingFactor;\n      }\n\n      return (value - me.min) * scalingFactor;\n    },\n    getPointPosition: function (index, distanceFromCenter) {\n      var me = this;\n      var thisAngle = me.getIndexAngle(index) - Math.PI / 2;\n      return {\n        x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,\n        y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter\n      };\n    },\n    getPointPositionForValue: function (index, value) {\n      return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n    },\n    getBasePosition: function () {\n      var me = this;\n      var min = me.min;\n      var max = me.max;\n      return me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);\n    },\n    draw: function () {\n      var me = this;\n      var opts = me.options;\n      var gridLineOpts = opts.gridLines;\n      var tickOpts = opts.ticks;\n      var valueOrDefault = helpers.valueOrDefault;\n\n      if (opts.display) {\n        var ctx = me.ctx;\n        var startAngle = this.getIndexAngle(0); // Tick Font\n\n        var tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n        var tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);\n        var tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);\n        var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n        helpers.each(me.ticks, function (label, index) {\n          // Don't draw a centre value (if it is minimum)\n          if (index > 0 || tickOpts.reverse) {\n            var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]); // Draw circular lines around the scale\n\n            if (gridLineOpts.display && index !== 0) {\n              drawRadiusLine(me, gridLineOpts, yCenterOffset, index);\n            }\n\n            if (tickOpts.display) {\n              var tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);\n              ctx.font = tickLabelFont;\n              ctx.save();\n              ctx.translate(me.xCenter, me.yCenter);\n              ctx.rotate(startAngle);\n\n              if (tickOpts.showLabelBackdrop) {\n                var labelWidth = ctx.measureText(label).width;\n                ctx.fillStyle = tickOpts.backdropColor;\n                ctx.fillRect(-labelWidth / 2 - tickOpts.backdropPaddingX, -yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFontSize + tickOpts.backdropPaddingY * 2);\n              }\n\n              ctx.textAlign = 'center';\n              ctx.textBaseline = 'middle';\n              ctx.fillStyle = tickFontColor;\n              ctx.fillText(label, 0, -yCenterOffset);\n              ctx.restore();\n            }\n          }\n        });\n\n        if (opts.angleLines.display || opts.pointLabels.display) {\n          drawPointLabels(me);\n        }\n      }\n    }\n  });\n  scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);\n};","map":{"version":3,"sources":["C:/Users/Administrator/.git/asdf/Source Files/node_modules/chart.js/src/scales/scale.radialLinear.js"],"names":["defaults","require","helpers","scaleService","Ticks","module","exports","Chart","globalDefaults","global","defaultConfig","display","animate","position","angleLines","color","lineWidth","gridLines","circular","ticks","showLabelBackdrop","backdropColor","backdropPaddingY","backdropPaddingX","callback","formatters","linear","pointLabels","fontSize","label","getValueCount","scale","opts","options","chart","data","labels","length","getPointLabelFontOptions","pointLabelOptions","valueOrDefault","defaultFontSize","fontStyle","defaultFontStyle","fontFamily","defaultFontFamily","font","fontString","size","style","family","measureLabelSize","ctx","isArray","w","longestText","h","measureText","width","determineLimits","angle","pos","min","max","start","end","fitWithPointLabels","plFont","largestPossibleRadius","Math","height","furthestLimits","r","l","t","b","furthestAngles","i","textSize","pointPosition","_pointLabelSizes","valueCount","getPointPosition","angleRadians","getIndexAngle","toDegrees","hLimits","x","vLimits","y","setReductions","fit","drawingArea","round","setCenterPoint","getTextAlignForAngle","fillText","text","spacing","adjustPointPositionForLabelHeight","drawPointLabels","angleLineOpts","pointLabelOpts","strokeStyle","outerDistance","getDistanceFromCenterForValue","reverse","textBaseline","outerPosition","beginPath","moveTo","xCenter","yCenter","lineTo","stroke","closePath","pointLabelPosition","pointLabelFontColor","valueAtIndexOrDefault","fontColor","defaultFontColor","fillStyle","textAlign","drawRadiusLine","gridLineOpts","radius","index","arc","PI","numberOrZero","param","isNumber","LinearRadialScale","LinearScaleBase","extend","setDimensions","me","tickOpts","maxWidth","maxHeight","minSize","tickFontSize","determineDataLimits","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","each","datasets","dataset","datasetIndex","isDatasetVisible","meta","getDatasetMeta","rawValue","value","getRightValue","isNaN","hidden","handleTickRangeOptions","getTickLimit","maxTicksLimit","ceil","convertTicksToLabels","prototype","call","map","getLabelForIndex","radiusReductionLeft","sin","radiusReductionRight","radiusReductionTop","cos","radiusReductionBottom","leftMovement","rightMovement","topMovement","bottomMovement","maxRight","maxLeft","maxTop","maxBottom","left","top","angleMultiplier","startAngle","startAngleRadians","scalingFactor","distanceFromCenter","thisAngle","getPointPositionForValue","getBasePosition","beginAtZero","draw","tickFontStyle","tickFontFamily","tickLabelFont","yCenterOffset","ticksAsNumbers","tickFontColor","save","translate","rotate","labelWidth","fillRect","restore","registerScaleType"],"mappings":"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","sourcesContent":["'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar helpers = require('../helpers/index');\nvar scaleService = require('../core/core.scaleService');\nvar Ticks = require('../core/core.ticks');\n\nmodule.exports = function(Chart) {\n\n\tvar globalDefaults = defaults.global;\n\n\tvar defaultConfig = {\n\t\tdisplay: true,\n\n\t\t// Boolean - Whether to animate scaling the chart from the centre\n\t\tanimate: true,\n\t\tposition: 'chartArea',\n\n\t\tangleLines: {\n\t\t\tdisplay: true,\n\t\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\t\tlineWidth: 1\n\t\t},\n\n\t\tgridLines: {\n\t\t\tcircular: false\n\t\t},\n\n\t\t// label settings\n\t\tticks: {\n\t\t\t// Boolean - Show a backdrop to the scale label\n\t\t\tshowLabelBackdrop: true,\n\n\t\t\t// String - The colour of the label backdrop\n\t\t\tbackdropColor: 'rgba(255,255,255,0.75)',\n\n\t\t\t// Number - The backdrop padding above & below the label in pixels\n\t\t\tbackdropPaddingY: 2,\n\n\t\t\t// Number - The backdrop padding to the side of the label in pixels\n\t\t\tbackdropPaddingX: 2,\n\n\t\t\tcallback: Ticks.formatters.linear\n\t\t},\n\n\t\tpointLabels: {\n\t\t\t// Boolean - if true, show point labels\n\t\t\tdisplay: true,\n\n\t\t\t// Number - Point label font size in pixels\n\t\t\tfontSize: 10,\n\n\t\t\t// Function - Used to convert point labels\n\t\t\tcallback: function(label) {\n\t\t\t\treturn label;\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction getValueCount(scale) {\n\t\tvar opts = scale.options;\n\t\treturn opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;\n\t}\n\n\tfunction getPointLabelFontOptions(scale) {\n\t\tvar pointLabelOptions = scale.options.pointLabels;\n\t\tvar fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);\n\t\tvar fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);\n\t\tvar fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);\n\t\tvar font = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\treturn {\n\t\t\tsize: fontSize,\n\t\t\tstyle: fontStyle,\n\t\t\tfamily: fontFamily,\n\t\t\tfont: font\n\t\t};\n\t}\n\n\tfunction measureLabelSize(ctx, fontSize, label) {\n\t\tif (helpers.isArray(label)) {\n\t\t\treturn {\n\t\t\t\tw: helpers.longestText(ctx, ctx.font, label),\n\t\t\t\th: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tw: ctx.measureText(label).width,\n\t\t\th: fontSize\n\t\t};\n\t}\n\n\tfunction determineLimits(angle, pos, size, min, max) {\n\t\tif (angle === min || angle === max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - (size / 2),\n\t\t\t\tend: pos + (size / 2)\n\t\t\t};\n\t\t} else if (angle < min || angle > max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - size - 5,\n\t\t\t\tend: pos\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tstart: pos,\n\t\t\tend: pos + size + 5\n\t\t};\n\t}\n\n\t/**\n\t * Helper function to fit a radial linear scale with point labels\n\t */\n\tfunction fitWithPointLabels(scale) {\n\t\t/*\n\t\t * Right, this is really confusing and there is a lot of maths going on here\n\t\t * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n\t\t *\n\t\t * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n\t\t *\n\t\t * Solution:\n\t\t *\n\t\t * We assume the radius of the polygon is half the size of the canvas at first\n\t\t * at each index we check if the text overlaps.\n\t\t *\n\t\t * Where it does, we store that angle and that index.\n\t\t *\n\t\t * After finding the largest index and angle we calculate how much we need to remove\n\t\t * from the shape radius to move the point inwards by that x.\n\t\t *\n\t\t * We average the left and right distances to get the maximum shape radius that can fit in the box\n\t\t * along with labels.\n\t\t *\n\t\t * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n\t\t * on each side, removing that from the size, halving it and adding the left x protrusion width.\n\t\t *\n\t\t * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n\t\t * and position it in the most space efficient manner\n\t\t *\n\t\t * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\t\t */\n\n\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n\t\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\tvar furthestLimits = {\n\t\t\tr: scale.width,\n\t\t\tl: 0,\n\t\t\tt: scale.height,\n\t\t\tb: 0\n\t\t};\n\t\tvar furthestAngles = {};\n\t\tvar i, textSize, pointPosition;\n\n\t\tscale.ctx.font = plFont.font;\n\t\tscale._pointLabelSizes = [];\n\n\t\tvar valueCount = getValueCount(scale);\n\t\tfor (i = 0; i < valueCount; i++) {\n\t\t\tpointPosition = scale.getPointPosition(i, largestPossibleRadius);\n\t\t\ttextSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');\n\t\t\tscale._pointLabelSizes[i] = textSize;\n\n\t\t\t// Add quarter circle to make degree 0 mean top of circle\n\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\tvar angle = helpers.toDegrees(angleRadians) % 360;\n\t\t\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n\t\t\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\n\t\t\tif (hLimits.start < furthestLimits.l) {\n\t\t\t\tfurthestLimits.l = hLimits.start;\n\t\t\t\tfurthestAngles.l = angleRadians;\n\t\t\t}\n\n\t\t\tif (hLimits.end > furthestLimits.r) {\n\t\t\t\tfurthestLimits.r = hLimits.end;\n\t\t\t\tfurthestAngles.r = angleRadians;\n\t\t\t}\n\n\t\t\tif (vLimits.start < furthestLimits.t) {\n\t\t\t\tfurthestLimits.t = vLimits.start;\n\t\t\t\tfurthestAngles.t = angleRadians;\n\t\t\t}\n\n\t\t\tif (vLimits.end > furthestLimits.b) {\n\t\t\t\tfurthestLimits.b = vLimits.end;\n\t\t\t\tfurthestAngles.b = angleRadians;\n\t\t\t}\n\t\t}\n\n\t\tscale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);\n\t}\n\n\t/**\n\t * Helper function to fit a radial linear scale with no point labels\n\t */\n\tfunction fit(scale) {\n\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\tscale.drawingArea = Math.round(largestPossibleRadius);\n\t\tscale.setCenterPoint(0, 0, 0, 0);\n\t}\n\n\tfunction getTextAlignForAngle(angle) {\n\t\tif (angle === 0 || angle === 180) {\n\t\t\treturn 'center';\n\t\t} else if (angle < 180) {\n\t\t\treturn 'left';\n\t\t}\n\n\t\treturn 'right';\n\t}\n\n\tfunction fillText(ctx, text, position, fontSize) {\n\t\tif (helpers.isArray(text)) {\n\t\t\tvar y = position.y;\n\t\t\tvar spacing = 1.5 * fontSize;\n\n\t\t\tfor (var i = 0; i < text.length; ++i) {\n\t\t\t\tctx.fillText(text[i], position.x, y);\n\t\t\t\ty += spacing;\n\t\t\t}\n\t\t} else {\n\t\t\tctx.fillText(text, position.x, position.y);\n\t\t}\n\t}\n\n\tfunction adjustPointPositionForLabelHeight(angle, textSize, position) {\n\t\tif (angle === 90 || angle === 270) {\n\t\t\tposition.y -= (textSize.h / 2);\n\t\t} else if (angle > 270 || angle < 90) {\n\t\t\tposition.y -= textSize.h;\n\t\t}\n\t}\n\n\tfunction drawPointLabels(scale) {\n\t\tvar ctx = scale.ctx;\n\t\tvar opts = scale.options;\n\t\tvar angleLineOpts = opts.angleLines;\n\t\tvar pointLabelOpts = opts.pointLabels;\n\n\t\tctx.lineWidth = angleLineOpts.lineWidth;\n\t\tctx.strokeStyle = angleLineOpts.color;\n\n\t\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\n\n\t\t// Point Label Font\n\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\tctx.textBaseline = 'top';\n\n\t\tfor (var i = getValueCount(scale) - 1; i >= 0; i--) {\n\t\t\tif (angleLineOpts.display) {\n\t\t\t\tvar outerPosition = scale.getPointPosition(i, outerDistance);\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(scale.xCenter, scale.yCenter);\n\t\t\t\tctx.lineTo(outerPosition.x, outerPosition.y);\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.closePath();\n\t\t\t}\n\n\t\t\tif (pointLabelOpts.display) {\n\t\t\t\t// Extra 3px out for some label spacing\n\t\t\t\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);\n\n\t\t\t\t// Keep this in loop since we may support array properties here\n\t\t\t\tvar pointLabelFontColor = helpers.valueAtIndexOrDefault(pointLabelOpts.fontColor, i, globalDefaults.defaultFontColor);\n\t\t\t\tctx.font = plFont.font;\n\t\t\t\tctx.fillStyle = pointLabelFontColor;\n\n\t\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\t\tvar angle = helpers.toDegrees(angleRadians);\n\t\t\t\tctx.textAlign = getTextAlignForAngle(angle);\n\t\t\t\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n\t\t\t\tfillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction drawRadiusLine(scale, gridLineOpts, radius, index) {\n\t\tvar ctx = scale.ctx;\n\t\tctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);\n\t\tctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\n\n\t\tif (scale.options.gridLines.circular) {\n\t\t\t// Draw circular arcs between the points\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t} else {\n\t\t\t// Draw straight lines connecting each index\n\t\t\tvar valueCount = getValueCount(scale);\n\n\t\t\tif (valueCount === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tctx.beginPath();\n\t\t\tvar pointPosition = scale.getPointPosition(0, radius);\n\t\t\tctx.moveTo(pointPosition.x, pointPosition.y);\n\n\t\t\tfor (var i = 1; i < valueCount; i++) {\n\t\t\t\tpointPosition = scale.getPointPosition(i, radius);\n\t\t\t\tctx.lineTo(pointPosition.x, pointPosition.y);\n\t\t\t}\n\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t}\n\t}\n\n\tfunction numberOrZero(param) {\n\t\treturn helpers.isNumber(param) ? param : 0;\n\t}\n\n\tvar LinearRadialScale = Chart.LinearScaleBase.extend({\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.height = me.maxHeight;\n\t\t\tme.xCenter = Math.round(me.width / 2);\n\t\t\tme.yCenter = Math.round(me.height / 2);\n\n\t\t\tvar minSize = helpers.min([me.height, me.width]);\n\t\t\tvar tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\tme.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);\n\t\t},\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar min = Number.POSITIVE_INFINITY;\n\t\t\tvar max = Number.NEGATIVE_INFINITY;\n\n\t\t\thelpers.each(chart.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\n\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmin = Math.min(value, min);\n\t\t\t\t\t\tmax = Math.max(value, max);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tme.min = (min === Number.POSITIVE_INFINITY ? 0 : min);\n\t\t\tme.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tme.handleTickRangeOptions();\n\t\t},\n\t\tgetTickLimit: function() {\n\t\t\tvar tickOpts = this.options.ticks;\n\t\t\tvar tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\treturn Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\n\t\t\tChart.LinearScaleBase.prototype.convertTicksToLabels.call(me);\n\n\t\t\t// Point labels\n\t\t\tme.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\n\t\t},\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tfit: function() {\n\t\t\tif (this.options.pointLabels.display) {\n\t\t\t\tfitWithPointLabels(this);\n\t\t\t} else {\n\t\t\t\tfit(this);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Set radius reductions and determine new radius and center point\n\t\t * @private\n\t\t */\n\t\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {\n\t\t\tvar me = this;\n\t\t\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n\t\t\tvar radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n\t\t\tvar radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n\t\t\tvar radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);\n\n\t\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\n\t\t\tradiusReductionRight = numberOrZero(radiusReductionRight);\n\t\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\n\t\t\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\n\n\t\t\tme.drawingArea = Math.min(\n\t\t\t\tMath.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\n\t\t\t\tMath.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n\t\t\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n\t\t},\n\t\tsetCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {\n\t\t\tvar me = this;\n\t\t\tvar maxRight = me.width - rightMovement - me.drawingArea;\n\t\t\tvar maxLeft = leftMovement + me.drawingArea;\n\t\t\tvar maxTop = topMovement + me.drawingArea;\n\t\t\tvar maxBottom = me.height - bottomMovement - me.drawingArea;\n\n\t\t\tme.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);\n\t\t\tme.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);\n\t\t},\n\n\t\tgetIndexAngle: function(index) {\n\t\t\tvar angleMultiplier = (Math.PI * 2) / getValueCount(this);\n\t\t\tvar startAngle = this.chart.options && this.chart.options.startAngle ?\n\t\t\t\tthis.chart.options.startAngle :\n\t\t\t\t0;\n\n\t\t\tvar startAngleRadians = startAngle * Math.PI * 2 / 360;\n\n\t\t\t// Start from the top instead of right, so remove a quarter of the circle\n\t\t\treturn index * angleMultiplier + startAngleRadians;\n\t\t},\n\t\tgetDistanceFromCenterForValue: function(value) {\n\t\t\tvar me = this;\n\n\t\t\tif (value === null) {\n\t\t\t\treturn 0; // null always in center\n\t\t\t}\n\n\t\t\t// Take into account half font size + the yPadding of the top value\n\t\t\tvar scalingFactor = me.drawingArea / (me.max - me.min);\n\t\t\tif (me.options.ticks.reverse) {\n\t\t\t\treturn (me.max - value) * scalingFactor;\n\t\t\t}\n\t\t\treturn (value - me.min) * scalingFactor;\n\t\t},\n\t\tgetPointPosition: function(index, distanceFromCenter) {\n\t\t\tvar me = this;\n\t\t\tvar thisAngle = me.getIndexAngle(index) - (Math.PI / 2);\n\t\t\treturn {\n\t\t\t\tx: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,\n\t\t\t\ty: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter\n\t\t\t};\n\t\t},\n\t\tgetPointPositionForValue: function(index, value) {\n\t\t\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n\t\t},\n\n\t\tgetBasePosition: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\n\t\t\treturn me.getPointPositionForValue(0,\n\t\t\t\tme.beginAtZero ? 0 :\n\t\t\t\tmin < 0 && max < 0 ? max :\n\t\t\t\tmin > 0 && max > 0 ? min :\n\t\t\t\t0);\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\n\t\t\tif (opts.display) {\n\t\t\t\tvar ctx = me.ctx;\n\t\t\t\tvar startAngle = this.getIndexAngle(0);\n\n\t\t\t\t// Tick Font\n\t\t\t\tvar tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\tvar tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\t\tvar tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n\n\t\t\t\thelpers.each(me.ticks, function(label, index) {\n\t\t\t\t\t// Don't draw a centre value (if it is minimum)\n\t\t\t\t\tif (index > 0 || tickOpts.reverse) {\n\t\t\t\t\t\tvar yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n\n\t\t\t\t\t\t// Draw circular lines around the scale\n\t\t\t\t\t\tif (gridLineOpts.display && index !== 0) {\n\t\t\t\t\t\t\tdrawRadiusLine(me, gridLineOpts, yCenterOffset, index);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (tickOpts.display) {\n\t\t\t\t\t\t\tvar tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\t\t\t\tctx.font = tickLabelFont;\n\n\t\t\t\t\t\t\tctx.save();\n\t\t\t\t\t\t\tctx.translate(me.xCenter, me.yCenter);\n\t\t\t\t\t\t\tctx.rotate(startAngle);\n\n\t\t\t\t\t\t\tif (tickOpts.showLabelBackdrop) {\n\t\t\t\t\t\t\t\tvar labelWidth = ctx.measureText(label).width;\n\t\t\t\t\t\t\t\tctx.fillStyle = tickOpts.backdropColor;\n\t\t\t\t\t\t\t\tctx.fillRect(\n\t\t\t\t\t\t\t\t\t-labelWidth / 2 - tickOpts.backdropPaddingX,\n\t\t\t\t\t\t\t\t\t-yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY,\n\t\t\t\t\t\t\t\t\tlabelWidth + tickOpts.backdropPaddingX * 2,\n\t\t\t\t\t\t\t\t\ttickFontSize + tickOpts.backdropPaddingY * 2\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tctx.textAlign = 'center';\n\t\t\t\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\t\t\t\tctx.fillStyle = tickFontColor;\n\t\t\t\t\t\t\tctx.fillText(label, 0, -yCenterOffset);\n\t\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (opts.angleLines.display || opts.pointLabels.display) {\n\t\t\t\t\tdrawPointLabels(me);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tscaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);\n};\n"]},"metadata":{},"sourceType":"script"}