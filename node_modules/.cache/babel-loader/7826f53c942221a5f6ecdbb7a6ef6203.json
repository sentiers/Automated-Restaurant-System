{"ast":null,"code":"'use strict';\n\nvar Scale = require('../core/core.scale');\n\nvar scaleService = require('../core/core.scaleService');\n\nmodule.exports = function () {\n  // Default config for a category scale\n  var defaultConfig = {\n    position: 'bottom'\n  };\n  var DatasetScale = Scale.extend({\n    /**\n    * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\n    * else fall back to data.labels\n    * @private\n    */\n    getLabels: function () {\n      var data = this.chart.data;\n      return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n    },\n    determineDataLimits: function () {\n      var me = this;\n      var labels = me.getLabels();\n      me.minIndex = 0;\n      me.maxIndex = labels.length - 1;\n      var findIndex;\n\n      if (me.options.ticks.min !== undefined) {\n        // user specified min value\n        findIndex = labels.indexOf(me.options.ticks.min);\n        me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n      }\n\n      if (me.options.ticks.max !== undefined) {\n        // user specified max value\n        findIndex = labels.indexOf(me.options.ticks.max);\n        me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n      }\n\n      me.min = labels[me.minIndex];\n      me.max = labels[me.maxIndex];\n    },\n    buildTicks: function () {\n      var me = this;\n      var labels = me.getLabels(); // If we are viewing some subset of labels, slice the original array\n\n      me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n    },\n    getLabelForIndex: function (index, datasetIndex) {\n      var me = this;\n      var data = me.chart.data;\n      var isHorizontal = me.isHorizontal();\n\n      if (data.yLabels && !isHorizontal) {\n        return me.getRightValue(data.datasets[datasetIndex].data[index]);\n      }\n\n      return me.ticks[index - me.minIndex];\n    },\n    // Used to get data value locations.  Value can either be an index or a numerical value\n    getPixelForValue: function (value, index) {\n      var me = this;\n      var offset = me.options.offset; // 1 is added because we need the length but we have the indexes\n\n      var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1), 1); // If value is a data object, then index is the index in the data array,\n      // not the index of the scale. We need to change that.\n\n      var valueCategory;\n\n      if (value !== undefined && value !== null) {\n        valueCategory = me.isHorizontal() ? value.x : value.y;\n      }\n\n      if (valueCategory !== undefined || value !== undefined && isNaN(index)) {\n        var labels = me.getLabels();\n        value = valueCategory || value;\n        var idx = labels.indexOf(value);\n        index = idx !== -1 ? idx : index;\n      }\n\n      if (me.isHorizontal()) {\n        var valueWidth = me.width / offsetAmt;\n        var widthOffset = valueWidth * (index - me.minIndex);\n\n        if (offset) {\n          widthOffset += valueWidth / 2;\n        }\n\n        return me.left + Math.round(widthOffset);\n      }\n\n      var valueHeight = me.height / offsetAmt;\n      var heightOffset = valueHeight * (index - me.minIndex);\n\n      if (offset) {\n        heightOffset += valueHeight / 2;\n      }\n\n      return me.top + Math.round(heightOffset);\n    },\n    getPixelForTick: function (index) {\n      return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);\n    },\n    getValueForPixel: function (pixel) {\n      var me = this;\n      var offset = me.options.offset;\n      var value;\n      var offsetAmt = Math.max(me._ticks.length - (offset ? 0 : 1), 1);\n      var horz = me.isHorizontal();\n      var valueDimension = (horz ? me.width : me.height) / offsetAmt;\n      pixel -= horz ? me.left : me.top;\n\n      if (offset) {\n        pixel -= valueDimension / 2;\n      }\n\n      if (pixel <= 0) {\n        value = 0;\n      } else {\n        value = Math.round(pixel / valueDimension);\n      }\n\n      return value + me.minIndex;\n    },\n    getBasePixel: function () {\n      return this.bottom;\n    }\n  });\n  scaleService.registerScaleType('category', DatasetScale, defaultConfig);\n};","map":{"version":3,"sources":["C:/Users/Administrator/.git/asdf/Source Files/node_modules/chart.js/src/scales/scale.category.js"],"names":["Scale","require","scaleService","module","exports","defaultConfig","position","DatasetScale","extend","getLabels","data","chart","options","labels","isHorizontal","xLabels","yLabels","determineDataLimits","me","minIndex","maxIndex","length","findIndex","ticks","min","undefined","indexOf","max","buildTicks","slice","getLabelForIndex","index","datasetIndex","getRightValue","datasets","getPixelForValue","value","offset","offsetAmt","Math","valueCategory","x","y","isNaN","idx","valueWidth","width","widthOffset","left","round","valueHeight","height","heightOffset","top","getPixelForTick","getValueForPixel","pixel","_ticks","horz","valueDimension","getBasePixel","bottom","registerScaleType"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Scale = require('../core/core.scale');\nvar scaleService = require('../core/core.scaleService');\n\nmodule.exports = function() {\n\n\t// Default config for a category scale\n\tvar defaultConfig = {\n\t\tposition: 'bottom'\n\t};\n\n\tvar DatasetScale = Scale.extend({\n\t\t/**\n\t\t* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\n\t\t* else fall back to data.labels\n\t\t* @private\n\t\t*/\n\t\tgetLabels: function() {\n\t\t\tvar data = this.chart.data;\n\t\t\treturn this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n\t\t},\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\tme.minIndex = 0;\n\t\t\tme.maxIndex = labels.length - 1;\n\t\t\tvar findIndex;\n\n\t\t\tif (me.options.ticks.min !== undefined) {\n\t\t\t\t// user specified min value\n\t\t\t\tfindIndex = labels.indexOf(me.options.ticks.min);\n\t\t\t\tme.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n\t\t\t}\n\n\t\t\tif (me.options.ticks.max !== undefined) {\n\t\t\t\t// user specified max value\n\t\t\t\tfindIndex = labels.indexOf(me.options.ticks.max);\n\t\t\t\tme.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n\t\t\t}\n\n\t\t\tme.min = labels[me.minIndex];\n\t\t\tme.max = labels[me.maxIndex];\n\t\t},\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\t// If we are viewing some subset of labels, slice the original array\n\t\t\tme.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n\t\t},\n\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar data = me.chart.data;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tif (data.yLabels && !isHorizontal) {\n\t\t\t\treturn me.getRightValue(data.datasets[datasetIndex].data[index]);\n\t\t\t}\n\t\t\treturn me.ticks[index - me.minIndex];\n\t\t},\n\n\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\tgetPixelForValue: function(value, index) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\t// 1 is added because we need the length but we have the indexes\n\t\t\tvar offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1)), 1);\n\n\t\t\t// If value is a data object, then index is the index in the data array,\n\t\t\t// not the index of the scale. We need to change that.\n\t\t\tvar valueCategory;\n\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\tvalueCategory = me.isHorizontal() ? value.x : value.y;\n\t\t\t}\n\t\t\tif (valueCategory !== undefined || (value !== undefined && isNaN(index))) {\n\t\t\t\tvar labels = me.getLabels();\n\t\t\t\tvalue = valueCategory || value;\n\t\t\t\tvar idx = labels.indexOf(value);\n\t\t\t\tindex = idx !== -1 ? idx : index;\n\t\t\t}\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar valueWidth = me.width / offsetAmt;\n\t\t\t\tvar widthOffset = (valueWidth * (index - me.minIndex));\n\n\t\t\t\tif (offset) {\n\t\t\t\t\twidthOffset += (valueWidth / 2);\n\t\t\t\t}\n\n\t\t\t\treturn me.left + Math.round(widthOffset);\n\t\t\t}\n\t\t\tvar valueHeight = me.height / offsetAmt;\n\t\t\tvar heightOffset = (valueHeight * (index - me.minIndex));\n\n\t\t\tif (offset) {\n\t\t\t\theightOffset += (valueHeight / 2);\n\t\t\t}\n\n\t\t\treturn me.top + Math.round(heightOffset);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.ticks[index], index + this.minIndex, null);\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\tvar value;\n\t\t\tvar offsetAmt = Math.max((me._ticks.length - (offset ? 0 : 1)), 1);\n\t\t\tvar horz = me.isHorizontal();\n\t\t\tvar valueDimension = (horz ? me.width : me.height) / offsetAmt;\n\n\t\t\tpixel -= horz ? me.left : me.top;\n\n\t\t\tif (offset) {\n\t\t\t\tpixel -= (valueDimension / 2);\n\t\t\t}\n\n\t\t\tif (pixel <= 0) {\n\t\t\t\tvalue = 0;\n\t\t\t} else {\n\t\t\t\tvalue = Math.round(pixel / valueDimension);\n\t\t\t}\n\n\t\t\treturn value + me.minIndex;\n\t\t},\n\t\tgetBasePixel: function() {\n\t\t\treturn this.bottom;\n\t\t}\n\t});\n\n\tscaleService.registerScaleType('category', DatasetScale, defaultConfig);\n};\n"]},"metadata":{},"sourceType":"script"}