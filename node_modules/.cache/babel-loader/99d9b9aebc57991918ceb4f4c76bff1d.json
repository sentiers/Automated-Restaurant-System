{"ast":null,"code":"var conversions = require(\"./conversions\");\n\nvar convert = function () {\n  return new Converter();\n};\n\nfor (var func in conversions) {\n  // export Raw versions\n  convert[func + \"Raw\"] = function (func) {\n    // accept array or plain args\n    return function (arg) {\n      if (typeof arg == \"number\") arg = Array.prototype.slice.call(arguments);\n      return conversions[func](arg);\n    };\n  }(func);\n\n  var pair = /(\\w+)2(\\w+)/.exec(func),\n      from = pair[1],\n      to = pair[2]; // export rgb2hsl and [\"rgb\"][\"hsl\"]\n\n  convert[from] = convert[from] || {};\n\n  convert[from][to] = convert[func] = function (func) {\n    return function (arg) {\n      if (typeof arg == \"number\") arg = Array.prototype.slice.call(arguments);\n      var val = conversions[func](arg);\n      if (typeof val == \"string\" || val === undefined) return val; // keyword\n\n      for (var i = 0; i < val.length; i++) val[i] = Math.round(val[i]);\n\n      return val;\n    };\n  }(func);\n}\n/* Converter does lazy conversion and caching */\n\n\nvar Converter = function () {\n  this.convs = {};\n};\n/* Either get the values for a space or\n  set the values for a space, depending on args */\n\n\nConverter.prototype.routeSpace = function (space, args) {\n  var values = args[0];\n\n  if (values === undefined) {\n    // color.rgb()\n    return this.getValues(space);\n  } // color.rgb(10, 10, 10)\n\n\n  if (typeof values == \"number\") {\n    values = Array.prototype.slice.call(args);\n  }\n\n  return this.setValues(space, values);\n};\n/* Set the values for a space, invalidating cache */\n\n\nConverter.prototype.setValues = function (space, values) {\n  this.space = space;\n  this.convs = {};\n  this.convs[space] = values;\n  return this;\n};\n/* Get the values for a space. If there's already\n  a conversion for the space, fetch it, otherwise\n  compute it */\n\n\nConverter.prototype.getValues = function (space) {\n  var vals = this.convs[space];\n\n  if (!vals) {\n    var fspace = this.space,\n        from = this.convs[fspace];\n    vals = convert[fspace][space](from);\n    this.convs[space] = vals;\n  }\n\n  return vals;\n};\n\n[\"rgb\", \"hsl\", \"hsv\", \"cmyk\", \"keyword\"].forEach(function (space) {\n  Converter.prototype[space] = function (vals) {\n    return this.routeSpace(space, arguments);\n  };\n});\nmodule.exports = convert;","map":{"version":3,"sources":["C:/Users/Administrator/.git/asdf/Source Files/node_modules/chartjs-color/node_modules/color-convert/index.js"],"names":["conversions","require","convert","Converter","func","arg","Array","prototype","slice","call","arguments","pair","exec","from","to","val","undefined","i","length","Math","round","convs","routeSpace","space","args","values","getValues","setValues","vals","fspace","forEach","module","exports"],"mappings":"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","sourcesContent":["var conversions = require(\"./conversions\");\n\nvar convert = function() {\n   return new Converter();\n}\n\nfor (var func in conversions) {\n  // export Raw versions\n  convert[func + \"Raw\"] =  (function(func) {\n    // accept array or plain args\n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      return conversions[func](arg);\n    }\n  })(func);\n\n  var pair = /(\\w+)2(\\w+)/.exec(func),\n      from = pair[1],\n      to = pair[2];\n\n  // export rgb2hsl and [\"rgb\"][\"hsl\"]\n  convert[from] = convert[from] || {};\n\n  convert[from][to] = convert[func] = (function(func) { \n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      \n      var val = conversions[func](arg);\n      if (typeof val == \"string\" || val === undefined)\n        return val; // keyword\n\n      for (var i = 0; i < val.length; i++)\n        val[i] = Math.round(val[i]);\n      return val;\n    }\n  })(func);\n}\n\n\n/* Converter does lazy conversion and caching */\nvar Converter = function() {\n   this.convs = {};\n};\n\n/* Either get the values for a space or\n  set the values for a space, depending on args */\nConverter.prototype.routeSpace = function(space, args) {\n   var values = args[0];\n   if (values === undefined) {\n      // color.rgb()\n      return this.getValues(space);\n   }\n   // color.rgb(10, 10, 10)\n   if (typeof values == \"number\") {\n      values = Array.prototype.slice.call(args);        \n   }\n\n   return this.setValues(space, values);\n};\n  \n/* Set the values for a space, invalidating cache */\nConverter.prototype.setValues = function(space, values) {\n   this.space = space;\n   this.convs = {};\n   this.convs[space] = values;\n   return this;\n};\n\n/* Get the values for a space. If there's already\n  a conversion for the space, fetch it, otherwise\n  compute it */\nConverter.prototype.getValues = function(space) {\n   var vals = this.convs[space];\n   if (!vals) {\n      var fspace = this.space,\n          from = this.convs[fspace];\n      vals = convert[fspace][space](from);\n\n      this.convs[space] = vals;\n   }\n  return vals;\n};\n\n[\"rgb\", \"hsl\", \"hsv\", \"cmyk\", \"keyword\"].forEach(function(space) {\n   Converter.prototype[space] = function(vals) {\n      return this.routeSpace(space, arguments);\n   }\n});\n\nmodule.exports = convert;"]},"metadata":{},"sourceType":"script"}