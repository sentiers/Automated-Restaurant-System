{"ast":null,"code":"'use strict';\n\nvar defaults = require('../core/core.defaults');\n\nvar helpers = require('../helpers/index');\n\nvar scaleService = require('../core/core.scaleService');\n\nvar Ticks = require('../core/core.ticks');\n\nmodule.exports = function (Chart) {\n  var defaultConfig = {\n    position: 'left',\n    ticks: {\n      callback: Ticks.formatters.linear\n    }\n  };\n  var LinearScale = Chart.LinearScaleBase.extend({\n    determineDataLimits: function () {\n      var me = this;\n      var opts = me.options;\n      var chart = me.chart;\n      var data = chart.data;\n      var datasets = data.datasets;\n      var isHorizontal = me.isHorizontal();\n      var DEFAULT_MIN = 0;\n      var DEFAULT_MAX = 1;\n\n      function IDMatches(meta) {\n        return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n      } // First Calculate the range\n\n\n      me.min = null;\n      me.max = null;\n      var hasStacks = opts.stacked;\n\n      if (hasStacks === undefined) {\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          if (hasStacks) {\n            return;\n          }\n\n          var meta = chart.getDatasetMeta(datasetIndex);\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {\n            hasStacks = true;\n          }\n        });\n      }\n\n      if (opts.stacked || hasStacks) {\n        var valuesPerStack = {};\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          var meta = chart.getDatasetMeta(datasetIndex);\n          var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n          opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');\n\n          if (valuesPerStack[key] === undefined) {\n            valuesPerStack[key] = {\n              positiveValues: [],\n              negativeValues: []\n            };\n          } // Store these per type\n\n\n          var positiveValues = valuesPerStack[key].positiveValues;\n          var negativeValues = valuesPerStack[key].negativeValues;\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n            helpers.each(dataset.data, function (rawValue, index) {\n              var value = +me.getRightValue(rawValue);\n\n              if (isNaN(value) || meta.data[index].hidden) {\n                return;\n              }\n\n              positiveValues[index] = positiveValues[index] || 0;\n              negativeValues[index] = negativeValues[index] || 0;\n\n              if (opts.relativePoints) {\n                positiveValues[index] = 100;\n              } else if (value < 0) {\n                negativeValues[index] += value;\n              } else {\n                positiveValues[index] += value;\n              }\n            });\n          }\n        });\n        helpers.each(valuesPerStack, function (valuesForType) {\n          var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\n          var minVal = helpers.min(values);\n          var maxVal = helpers.max(values);\n          me.min = me.min === null ? minVal : Math.min(me.min, minVal);\n          me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n        });\n      } else {\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          var meta = chart.getDatasetMeta(datasetIndex);\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n            helpers.each(dataset.data, function (rawValue, index) {\n              var value = +me.getRightValue(rawValue);\n\n              if (isNaN(value) || meta.data[index].hidden) {\n                return;\n              }\n\n              if (me.min === null) {\n                me.min = value;\n              } else if (value < me.min) {\n                me.min = value;\n              }\n\n              if (me.max === null) {\n                me.max = value;\n              } else if (value > me.max) {\n                me.max = value;\n              }\n            });\n          }\n        });\n      }\n\n      me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;\n      me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\n      this.handleTickRangeOptions();\n    },\n    getTickLimit: function () {\n      var maxTicks;\n      var me = this;\n      var tickOpts = me.options.ticks;\n\n      if (me.isHorizontal()) {\n        maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));\n      } else {\n        // The factor of 2 used to scale the font size has been experimentally determined.\n        var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);\n        maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));\n      }\n\n      return maxTicks;\n    },\n    // Called after the ticks are built. We need\n    handleDirectionalChanges: function () {\n      if (!this.isHorizontal()) {\n        // We are in a vertical orientation. The top value is the highest. So reverse the array\n        this.ticks.reverse();\n      }\n    },\n    getLabelForIndex: function (index, datasetIndex) {\n      return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n    },\n    // Utils\n    getPixelForValue: function (value) {\n      // This must be called after fit has been run so that\n      // this.left, this.top, this.right, and this.bottom have been defined\n      var me = this;\n      var start = me.start;\n      var rightValue = +me.getRightValue(value);\n      var pixel;\n      var range = me.end - start;\n\n      if (me.isHorizontal()) {\n        pixel = me.left + me.width / range * (rightValue - start);\n      } else {\n        pixel = me.bottom - me.height / range * (rightValue - start);\n      }\n\n      return pixel;\n    },\n    getValueForPixel: function (pixel) {\n      var me = this;\n      var isHorizontal = me.isHorizontal();\n      var innerDimension = isHorizontal ? me.width : me.height;\n      var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;\n      return me.start + (me.end - me.start) * offset;\n    },\n    getPixelForTick: function (index) {\n      return this.getPixelForValue(this.ticksAsNumbers[index]);\n    }\n  });\n  scaleService.registerScaleType('linear', LinearScale, defaultConfig);\n};","map":{"version":3,"sources":["C:/Users/Administrator/.git/asdf/Source Files/node_modules/chart.js/src/scales/scale.linear.js"],"names":["defaults","require","helpers","scaleService","Ticks","module","exports","Chart","defaultConfig","position","ticks","callback","formatters","linear","LinearScale","LinearScaleBase","extend","determineDataLimits","me","opts","options","chart","data","datasets","isHorizontal","DEFAULT_MIN","DEFAULT_MAX","IDMatches","meta","xAxisID","id","yAxisID","min","max","hasStacks","stacked","undefined","each","dataset","datasetIndex","getDatasetMeta","isDatasetVisible","stack","valuesPerStack","key","type","join","positiveValues","negativeValues","rawValue","index","value","getRightValue","isNaN","hidden","relativePoints","valuesForType","values","concat","minVal","maxVal","Math","isFinite","handleTickRangeOptions","getTickLimit","maxTicks","tickOpts","maxTicksLimit","ceil","width","tickFontSize","valueOrDefault","fontSize","global","defaultFontSize","height","handleDirectionalChanges","reverse","getLabelForIndex","getPixelForValue","start","rightValue","pixel","range","end","left","bottom","getValueForPixel","innerDimension","offset","getPixelForTick","ticksAsNumbers","registerScaleType"],"mappings":"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","sourcesContent":["'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar helpers = require('../helpers/index');\nvar scaleService = require('../core/core.scaleService');\nvar Ticks = require('../core/core.ticks');\n\nmodule.exports = function(Chart) {\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\t\tticks: {\n\t\t\tcallback: Ticks.formatters.linear\n\t\t}\n\t};\n\n\tvar LinearScale = Chart.LinearScaleBase.extend({\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar DEFAULT_MIN = 0;\n\t\t\tvar DEFAULT_MAX = 1;\n\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// First Calculate the range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\tvaluesPerStack[key] = {\n\t\t\t\t\t\t\tpositiveValues: [],\n\t\t\t\t\t\t\tnegativeValues: []\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Store these per type\n\t\t\t\t\tvar positiveValues = valuesPerStack[key].positiveValues;\n\t\t\t\t\tvar negativeValues = valuesPerStack[key].negativeValues;\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpositiveValues[index] = positiveValues[index] || 0;\n\t\t\t\t\t\t\tnegativeValues[index] = negativeValues[index] || 0;\n\n\t\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\t\tpositiveValues[index] = 100;\n\t\t\t\t\t\t\t} else if (value < 0) {\n\t\t\t\t\t\t\t\tnegativeValues[index] += value;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpositiveValues[index] += value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tvar values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\n\t\t\t\t\tvar minVal = helpers.min(values);\n\t\t\t\t\tvar maxVal = helpers.max(values);\n\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tme.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;\n\t\t\tme.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tthis.handleTickRangeOptions();\n\t\t},\n\t\tgetTickLimit: function() {\n\t\t\tvar maxTicks;\n\t\t\tvar me = this;\n\t\t\tvar tickOpts = me.options.ticks;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));\n\t\t\t} else {\n\t\t\t\t// The factor of 2 used to scale the font size has been experimentally determined.\n\t\t\t\tvar tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);\n\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));\n\t\t\t}\n\n\t\t\treturn maxTicks;\n\t\t},\n\t\t// Called after the ticks are built. We need\n\t\thandleDirectionalChanges: function() {\n\t\t\tif (!this.isHorizontal()) {\n\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\t\tthis.ticks.reverse();\n\t\t\t}\n\t\t},\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\t// Utils\n\t\tgetPixelForValue: function(value) {\n\t\t\t// This must be called after fit has been run so that\n\t\t\t// this.left, this.top, this.right, and this.bottom have been defined\n\t\t\tvar me = this;\n\t\t\tvar start = me.start;\n\n\t\t\tvar rightValue = +me.getRightValue(value);\n\t\t\tvar pixel;\n\t\t\tvar range = me.end - start;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tpixel = me.left + (me.width / range * (rightValue - start));\n\t\t\t} else {\n\t\t\t\tpixel = me.bottom - (me.height / range * (rightValue - start));\n\t\t\t}\n\t\t\treturn pixel;\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar innerDimension = isHorizontal ? me.width : me.height;\n\t\t\tvar offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;\n\t\t\treturn me.start + ((me.end - me.start) * offset);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.ticksAsNumbers[index]);\n\t\t}\n\t});\n\n\tscaleService.registerScaleType('linear', LinearScale, defaultConfig);\n};\n"]},"metadata":{},"sourceType":"script"}