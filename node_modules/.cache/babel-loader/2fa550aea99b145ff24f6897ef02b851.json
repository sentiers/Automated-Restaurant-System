{"ast":null,"code":"'use strict';\n\nvar helpers = require('../helpers/index');\n\nvar Scale = require('../core/core.scale');\n/**\n * Generate a set of linear ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {Array<Number>} array of tick values\n */\n\n\nfunction generateTicks(generationOptions, dataRange) {\n  var ticks = []; // To get a \"nice\" value for the tick spacing, we will use the appropriately named\n  // \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n  // for details.\n\n  var factor;\n  var precision;\n  var spacing;\n\n  if (generationOptions.stepSize && generationOptions.stepSize > 0) {\n    spacing = generationOptions.stepSize;\n  } else {\n    var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\n    spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\n    precision = generationOptions.precision;\n\n    if (precision !== undefined) {\n      // If the user specified a precision, round to that number of decimal places\n      factor = Math.pow(10, precision);\n      spacing = Math.ceil(spacing * factor) / factor;\n    }\n  }\n\n  var niceMin = Math.floor(dataRange.min / spacing) * spacing;\n  var niceMax = Math.ceil(dataRange.max / spacing) * spacing; // If min, max and stepSize is set and they make an evenly spaced scale use it.\n\n  if (!helpers.isNullOrUndef(generationOptions.min) && !helpers.isNullOrUndef(generationOptions.max) && generationOptions.stepSize) {\n    // If very close to our whole number, use it.\n    if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\n      niceMin = generationOptions.min;\n      niceMax = generationOptions.max;\n    }\n  }\n\n  var numSpaces = (niceMax - niceMin) / spacing; // If very close to our rounded value, use it.\n\n  if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n    numSpaces = Math.round(numSpaces);\n  } else {\n    numSpaces = Math.ceil(numSpaces);\n  }\n\n  precision = 1;\n\n  if (spacing < 1) {\n    precision = Math.pow(10, 1 - Math.floor(helpers.log10(spacing)));\n    niceMin = Math.round(niceMin * precision) / precision;\n    niceMax = Math.round(niceMax * precision) / precision;\n  }\n\n  ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\n\n  for (var j = 1; j < numSpaces; ++j) {\n    ticks.push(Math.round((niceMin + j * spacing) * precision) / precision);\n  }\n\n  ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\n  return ticks;\n}\n\nmodule.exports = function (Chart) {\n  var noop = helpers.noop;\n  Chart.LinearScaleBase = Scale.extend({\n    getRightValue: function (value) {\n      if (typeof value === 'string') {\n        return +value;\n      }\n\n      return Scale.prototype.getRightValue.call(this, value);\n    },\n    handleTickRangeOptions: function () {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks; // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n      // do nothing since that would make the chart weird. If the user really wants a weird chart\n      // axis, they can manually override it\n\n      if (tickOpts.beginAtZero) {\n        var minSign = helpers.sign(me.min);\n        var maxSign = helpers.sign(me.max);\n\n        if (minSign < 0 && maxSign < 0) {\n          // move the top up to 0\n          me.max = 0;\n        } else if (minSign > 0 && maxSign > 0) {\n          // move the bottom down to 0\n          me.min = 0;\n        }\n      }\n\n      var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;\n      var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;\n\n      if (tickOpts.min !== undefined) {\n        me.min = tickOpts.min;\n      } else if (tickOpts.suggestedMin !== undefined) {\n        if (me.min === null) {\n          me.min = tickOpts.suggestedMin;\n        } else {\n          me.min = Math.min(me.min, tickOpts.suggestedMin);\n        }\n      }\n\n      if (tickOpts.max !== undefined) {\n        me.max = tickOpts.max;\n      } else if (tickOpts.suggestedMax !== undefined) {\n        if (me.max === null) {\n          me.max = tickOpts.suggestedMax;\n        } else {\n          me.max = Math.max(me.max, tickOpts.suggestedMax);\n        }\n      }\n\n      if (setMin !== setMax) {\n        // We set the min or the max but not both.\n        // So ensure that our range is good\n        // Inverted or 0 length range can happen when\n        // ticks.min is set, and no datasets are visible\n        if (me.min >= me.max) {\n          if (setMin) {\n            me.max = me.min + 1;\n          } else {\n            me.min = me.max - 1;\n          }\n        }\n      }\n\n      if (me.min === me.max) {\n        me.max++;\n\n        if (!tickOpts.beginAtZero) {\n          me.min--;\n        }\n      }\n    },\n    getTickLimit: noop,\n    handleDirectionalChanges: noop,\n    buildTicks: function () {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks; // Figure out what the max number of ticks we can support it is based on the size of\n      // the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n      // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n      // the graph. Make sure we always have at least 2 ticks\n\n      var maxTicks = me.getTickLimit();\n      maxTicks = Math.max(2, maxTicks);\n      var numericGeneratorOptions = {\n        maxTicks: maxTicks,\n        min: tickOpts.min,\n        max: tickOpts.max,\n        precision: tickOpts.precision,\n        stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n      };\n      var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);\n      me.handleDirectionalChanges(); // At this point, we need to update our max and min given the tick values since we have expanded the\n      // range of the scale\n\n      me.max = helpers.max(ticks);\n      me.min = helpers.min(ticks);\n\n      if (tickOpts.reverse) {\n        ticks.reverse();\n        me.start = me.max;\n        me.end = me.min;\n      } else {\n        me.start = me.min;\n        me.end = me.max;\n      }\n    },\n    convertTicksToLabels: function () {\n      var me = this;\n      me.ticksAsNumbers = me.ticks.slice();\n      me.zeroLineIndex = me.ticks.indexOf(0);\n      Scale.prototype.convertTicksToLabels.call(me);\n    }\n  });\n};","map":{"version":3,"sources":["C:/Users/Administrator/.git/asdf/Source Files/node_modules/chart.js/src/scales/scale.linearbase.js"],"names":["helpers","require","Scale","generateTicks","generationOptions","dataRange","ticks","factor","precision","spacing","stepSize","niceRange","niceNum","max","min","maxTicks","undefined","Math","pow","ceil","niceMin","floor","niceMax","isNullOrUndef","almostWhole","numSpaces","almostEquals","round","log10","push","j","module","exports","Chart","noop","LinearScaleBase","extend","getRightValue","value","prototype","call","handleTickRangeOptions","me","opts","options","tickOpts","beginAtZero","minSign","sign","maxSign","setMin","suggestedMin","setMax","suggestedMax","getTickLimit","handleDirectionalChanges","buildTicks","numericGeneratorOptions","valueOrDefault","fixedStepSize","reverse","start","end","convertTicksToLabels","ticksAsNumbers","slice","zeroLineIndex","indexOf"],"mappings":"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","sourcesContent":["'use strict';\n\nvar helpers = require('../helpers/index');\nvar Scale = require('../core/core.scale');\n\n/**\n * Generate a set of linear ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {Array<Number>} array of tick values\n */\nfunction generateTicks(generationOptions, dataRange) {\n\tvar ticks = [];\n\t// To get a \"nice\" value for the tick spacing, we will use the appropriately named\n\t// \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n\t// for details.\n\n\tvar factor;\n\tvar precision;\n\tvar spacing;\n\n\tif (generationOptions.stepSize && generationOptions.stepSize > 0) {\n\t\tspacing = generationOptions.stepSize;\n\t} else {\n\t\tvar niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\n\t\tspacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\n\n\t\tprecision = generationOptions.precision;\n\t\tif (precision !== undefined) {\n\t\t\t// If the user specified a precision, round to that number of decimal places\n\t\t\tfactor = Math.pow(10, precision);\n\t\t\tspacing = Math.ceil(spacing * factor) / factor;\n\t\t}\n\t}\n\tvar niceMin = Math.floor(dataRange.min / spacing) * spacing;\n\tvar niceMax = Math.ceil(dataRange.max / spacing) * spacing;\n\n\t// If min, max and stepSize is set and they make an evenly spaced scale use it.\n\tif (!helpers.isNullOrUndef(generationOptions.min) && !helpers.isNullOrUndef(generationOptions.max) && generationOptions.stepSize) {\n\t\t// If very close to our whole number, use it.\n\t\tif (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\n\t\t\tniceMin = generationOptions.min;\n\t\t\tniceMax = generationOptions.max;\n\t\t}\n\t}\n\n\tvar numSpaces = (niceMax - niceMin) / spacing;\n\t// If very close to our rounded value, use it.\n\tif (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n\t\tnumSpaces = Math.round(numSpaces);\n\t} else {\n\t\tnumSpaces = Math.ceil(numSpaces);\n\t}\n\n\tprecision = 1;\n\tif (spacing < 1) {\n\t\tprecision = Math.pow(10, 1 - Math.floor(helpers.log10(spacing)));\n\t\tniceMin = Math.round(niceMin * precision) / precision;\n\t\tniceMax = Math.round(niceMax * precision) / precision;\n\t}\n\tticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\n\tfor (var j = 1; j < numSpaces; ++j) {\n\t\tticks.push(Math.round((niceMin + j * spacing) * precision) / precision);\n\t}\n\tticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\n\n\treturn ticks;\n}\n\nmodule.exports = function(Chart) {\n\n\tvar noop = helpers.noop;\n\n\tChart.LinearScaleBase = Scale.extend({\n\t\tgetRightValue: function(value) {\n\t\t\tif (typeof value === 'string') {\n\t\t\t\treturn +value;\n\t\t\t}\n\t\t\treturn Scale.prototype.getRightValue.call(this, value);\n\t\t},\n\n\t\thandleTickRangeOptions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n\t\t\t// do nothing since that would make the chart weird. If the user really wants a weird chart\n\t\t\t// axis, they can manually override it\n\t\t\tif (tickOpts.beginAtZero) {\n\t\t\t\tvar minSign = helpers.sign(me.min);\n\t\t\t\tvar maxSign = helpers.sign(me.max);\n\n\t\t\t\tif (minSign < 0 && maxSign < 0) {\n\t\t\t\t\t// move the top up to 0\n\t\t\t\t\tme.max = 0;\n\t\t\t\t} else if (minSign > 0 && maxSign > 0) {\n\t\t\t\t\t// move the bottom down to 0\n\t\t\t\t\tme.min = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;\n\t\t\tvar setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;\n\n\t\t\tif (tickOpts.min !== undefined) {\n\t\t\t\tme.min = tickOpts.min;\n\t\t\t} else if (tickOpts.suggestedMin !== undefined) {\n\t\t\t\tif (me.min === null) {\n\t\t\t\t\tme.min = tickOpts.suggestedMin;\n\t\t\t\t} else {\n\t\t\t\t\tme.min = Math.min(me.min, tickOpts.suggestedMin);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tickOpts.max !== undefined) {\n\t\t\t\tme.max = tickOpts.max;\n\t\t\t} else if (tickOpts.suggestedMax !== undefined) {\n\t\t\t\tif (me.max === null) {\n\t\t\t\t\tme.max = tickOpts.suggestedMax;\n\t\t\t\t} else {\n\t\t\t\t\tme.max = Math.max(me.max, tickOpts.suggestedMax);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (setMin !== setMax) {\n\t\t\t\t// We set the min or the max but not both.\n\t\t\t\t// So ensure that our range is good\n\t\t\t\t// Inverted or 0 length range can happen when\n\t\t\t\t// ticks.min is set, and no datasets are visible\n\t\t\t\tif (me.min >= me.max) {\n\t\t\t\t\tif (setMin) {\n\t\t\t\t\t\tme.max = me.min + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.min = me.max - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tme.max++;\n\n\t\t\t\tif (!tickOpts.beginAtZero) {\n\t\t\t\t\tme.min--;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tgetTickLimit: noop,\n\t\thandleDirectionalChanges: noop,\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t// the graph. Make sure we always have at least 2 ticks\n\t\t\tvar maxTicks = me.getTickLimit();\n\t\t\tmaxTicks = Math.max(2, maxTicks);\n\n\t\t\tvar numericGeneratorOptions = {\n\t\t\t\tmaxTicks: maxTicks,\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max,\n\t\t\t\tprecision: tickOpts.precision,\n\t\t\t\tstepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n\t\t\t};\n\t\t\tvar ticks = me.ticks = generateTicks(numericGeneratorOptions, me);\n\n\t\t\tme.handleDirectionalChanges();\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\tticks.reverse();\n\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tme.ticksAsNumbers = me.ticks.slice();\n\t\t\tme.zeroLineIndex = me.ticks.indexOf(0);\n\n\t\t\tScale.prototype.convertTicksToLabels.call(me);\n\t\t}\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}