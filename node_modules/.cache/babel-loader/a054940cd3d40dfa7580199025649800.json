{"ast":null,"code":"'use strict';\n\nvar defaults = require('../core/core.defaults');\n\nvar Element = require('../core/core.element');\n\nvar helpers = require('../helpers/index');\n\nvar globalDefaults = defaults.global;\n\ndefaults._set('global', {\n  elements: {\n    line: {\n      tension: 0.4,\n      backgroundColor: globalDefaults.defaultColor,\n      borderWidth: 3,\n      borderColor: globalDefaults.defaultColor,\n      borderCapStyle: 'butt',\n      borderDash: [],\n      borderDashOffset: 0.0,\n      borderJoinStyle: 'miter',\n      capBezierPoints: true,\n      fill: true // do we fill in the area between the line and its base axis\n\n    }\n  }\n});\n\nmodule.exports = Element.extend({\n  draw: function () {\n    var me = this;\n    var vm = me._view;\n    var ctx = me._chart.ctx;\n    var spanGaps = vm.spanGaps;\n\n    var points = me._children.slice(); // clone array\n\n\n    var globalOptionLineElements = globalDefaults.elements.line;\n    var lastDrawnIndex = -1;\n    var index, current, previous, currentVM; // If we are looping, adding the first point again\n\n    if (me._loop && points.length) {\n      points.push(points[0]);\n    }\n\n    ctx.save(); // Stroke Line Options\n\n    ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle; // IE 9 and 10 do not support line dash\n\n    if (ctx.setLineDash) {\n      ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n    }\n\n    ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\n    ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n    ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;\n    ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor; // Stroke Line\n\n    ctx.beginPath();\n    lastDrawnIndex = -1;\n\n    for (index = 0; index < points.length; ++index) {\n      current = points[index];\n      previous = helpers.previousItem(points, index);\n      currentVM = current._view; // First point moves to it's starting position no matter what\n\n      if (index === 0) {\n        if (!currentVM.skip) {\n          ctx.moveTo(currentVM.x, currentVM.y);\n          lastDrawnIndex = index;\n        }\n      } else {\n        previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\n        if (!currentVM.skip) {\n          if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {\n            // There was a gap and this is the first point after the gap\n            ctx.moveTo(currentVM.x, currentVM.y);\n          } else {\n            // Line to next point\n            helpers.canvas.lineTo(ctx, previous._view, current._view);\n          }\n\n          lastDrawnIndex = index;\n        }\n      }\n    }\n\n    ctx.stroke();\n    ctx.restore();\n  }\n});","map":{"version":3,"sources":["C:/Users/Administrator/.git/asdf/Source Files/node_modules/chart.js/src/elements/element.line.js"],"names":["defaults","require","Element","helpers","globalDefaults","global","_set","elements","line","tension","backgroundColor","defaultColor","borderWidth","borderColor","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","capBezierPoints","fill","module","exports","extend","draw","me","vm","_view","ctx","_chart","spanGaps","points","_children","slice","globalOptionLineElements","lastDrawnIndex","index","current","previous","currentVM","_loop","length","push","save","lineCap","setLineDash","lineDashOffset","lineJoin","lineWidth","strokeStyle","beginPath","previousItem","skip","moveTo","x","y","canvas","lineTo","stroke","restore"],"mappings":"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","sourcesContent":["'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\nvar helpers = require('../helpers/index');\n\nvar globalDefaults = defaults.global;\n\ndefaults._set('global', {\n\telements: {\n\t\tline: {\n\t\t\ttension: 0.4,\n\t\t\tbackgroundColor: globalDefaults.defaultColor,\n\t\t\tborderWidth: 3,\n\t\t\tborderColor: globalDefaults.defaultColor,\n\t\t\tborderCapStyle: 'butt',\n\t\t\tborderDash: [],\n\t\t\tborderDashOffset: 0.0,\n\t\t\tborderJoinStyle: 'miter',\n\t\t\tcapBezierPoints: true,\n\t\t\tfill: true, // do we fill in the area between the line and its base axis\n\t\t}\n\t}\n});\n\nmodule.exports = Element.extend({\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar vm = me._view;\n\t\tvar ctx = me._chart.ctx;\n\t\tvar spanGaps = vm.spanGaps;\n\t\tvar points = me._children.slice(); // clone array\n\t\tvar globalOptionLineElements = globalDefaults.elements.line;\n\t\tvar lastDrawnIndex = -1;\n\t\tvar index, current, previous, currentVM;\n\n\t\t// If we are looping, adding the first point again\n\t\tif (me._loop && points.length) {\n\t\t\tpoints.push(points[0]);\n\t\t}\n\n\t\tctx.save();\n\n\t\t// Stroke Line Options\n\t\tctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\n\n\t\t// IE 9 and 10 do not support line dash\n\t\tif (ctx.setLineDash) {\n\t\t\tctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n\t\t}\n\n\t\tctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\n\t\tctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n\t\tctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;\n\t\tctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\n\n\t\t// Stroke Line\n\t\tctx.beginPath();\n\t\tlastDrawnIndex = -1;\n\n\t\tfor (index = 0; index < points.length; ++index) {\n\t\t\tcurrent = points[index];\n\t\t\tprevious = helpers.previousItem(points, index);\n\t\t\tcurrentVM = current._view;\n\n\t\t\t// First point moves to it's starting position no matter what\n\t\t\tif (index === 0) {\n\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\n\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\tif ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {\n\t\t\t\t\t\t// There was a gap and this is the first point after the gap\n\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Line to next point\n\t\t\t\t\t\thelpers.canvas.lineTo(ctx, previous._view, current._view);\n\t\t\t\t\t}\n\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tctx.stroke();\n\t\tctx.restore();\n\t}\n});\n"]},"metadata":{},"sourceType":"script"}