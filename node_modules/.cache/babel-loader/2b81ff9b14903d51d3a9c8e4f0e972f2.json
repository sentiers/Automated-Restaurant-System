{"ast":null,"code":"/**\n * Plugin based on discussion from the following Chart.js issues:\n * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\n * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\n */\n'use strict';\n\nvar defaults = require('../core/core.defaults');\n\nvar elements = require('../elements/index');\n\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n  plugins: {\n    filler: {\n      propagate: true\n    }\n  }\n});\n\nvar mappers = {\n  dataset: function (source) {\n    var index = source.fill;\n    var chart = source.chart;\n    var meta = chart.getDatasetMeta(index);\n    var visible = meta && chart.isDatasetVisible(index);\n    var points = visible && meta.dataset._children || [];\n    var length = points.length || 0;\n    return !length ? null : function (point, i) {\n      return i < length && points[i]._view || null;\n    };\n  },\n  boundary: function (source) {\n    var boundary = source.boundary;\n    var x = boundary ? boundary.x : null;\n    var y = boundary ? boundary.y : null;\n    return function (point) {\n      return {\n        x: x === null ? point.x : x,\n        y: y === null ? point.y : y\n      };\n    };\n  }\n}; // @todo if (fill[0] === '#')\n\nfunction decodeFill(el, index, count) {\n  var model = el._model || {};\n  var fill = model.fill;\n  var target;\n\n  if (fill === undefined) {\n    fill = !!model.backgroundColor;\n  }\n\n  if (fill === false || fill === null) {\n    return false;\n  }\n\n  if (fill === true) {\n    return 'origin';\n  }\n\n  target = parseFloat(fill, 10);\n\n  if (isFinite(target) && Math.floor(target) === target) {\n    if (fill[0] === '-' || fill[0] === '+') {\n      target = index + target;\n    }\n\n    if (target === index || target < 0 || target >= count) {\n      return false;\n    }\n\n    return target;\n  }\n\n  switch (fill) {\n    // compatibility\n    case 'bottom':\n      return 'start';\n\n    case 'top':\n      return 'end';\n\n    case 'zero':\n      return 'origin';\n    // supported boundaries\n\n    case 'origin':\n    case 'start':\n    case 'end':\n      return fill;\n    // invalid fill values\n\n    default:\n      return false;\n  }\n}\n\nfunction computeBoundary(source) {\n  var model = source.el._model || {};\n  var scale = source.el._scale || {};\n  var fill = source.fill;\n  var target = null;\n  var horizontal;\n\n  if (isFinite(fill)) {\n    return null;\n  } // Backward compatibility: until v3, we still need to support boundary values set on\n  // the model (scaleTop, scaleBottom and scaleZero) because some external plugins and\n  // controllers might still use it (e.g. the Smith chart).\n\n\n  if (fill === 'start') {\n    target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;\n  } else if (fill === 'end') {\n    target = model.scaleTop === undefined ? scale.top : model.scaleTop;\n  } else if (model.scaleZero !== undefined) {\n    target = model.scaleZero;\n  } else if (scale.getBasePosition) {\n    target = scale.getBasePosition();\n  } else if (scale.getBasePixel) {\n    target = scale.getBasePixel();\n  }\n\n  if (target !== undefined && target !== null) {\n    if (target.x !== undefined && target.y !== undefined) {\n      return target;\n    }\n\n    if (typeof target === 'number' && isFinite(target)) {\n      horizontal = scale.isHorizontal();\n      return {\n        x: horizontal ? target : null,\n        y: horizontal ? null : target\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction resolveTarget(sources, index, propagate) {\n  var source = sources[index];\n  var fill = source.fill;\n  var visited = [index];\n  var target;\n\n  if (!propagate) {\n    return fill;\n  }\n\n  while (fill !== false && visited.indexOf(fill) === -1) {\n    if (!isFinite(fill)) {\n      return fill;\n    }\n\n    target = sources[fill];\n\n    if (!target) {\n      return false;\n    }\n\n    if (target.visible) {\n      return fill;\n    }\n\n    visited.push(fill);\n    fill = target.fill;\n  }\n\n  return false;\n}\n\nfunction createMapper(source) {\n  var fill = source.fill;\n  var type = 'dataset';\n\n  if (fill === false) {\n    return null;\n  }\n\n  if (!isFinite(fill)) {\n    type = 'boundary';\n  }\n\n  return mappers[type](source);\n}\n\nfunction isDrawable(point) {\n  return point && !point.skip;\n}\n\nfunction drawArea(ctx, curve0, curve1, len0, len1) {\n  var i;\n\n  if (!len0 || !len1) {\n    return;\n  } // building first area curve (normal)\n\n\n  ctx.moveTo(curve0[0].x, curve0[0].y);\n\n  for (i = 1; i < len0; ++i) {\n    helpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);\n  } // joining the two area curves\n\n\n  ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y); // building opposite area curve (reverse)\n\n  for (i = len1 - 1; i > 0; --i) {\n    helpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);\n  }\n}\n\nfunction doFill(ctx, points, mapper, view, color, loop) {\n  var count = points.length;\n  var span = view.spanGaps;\n  var curve0 = [];\n  var curve1 = [];\n  var len0 = 0;\n  var len1 = 0;\n  var i, ilen, index, p0, p1, d0, d1;\n  ctx.beginPath();\n\n  for (i = 0, ilen = count + !!loop; i < ilen; ++i) {\n    index = i % count;\n    p0 = points[index]._view;\n    p1 = mapper(p0, index, view);\n    d0 = isDrawable(p0);\n    d1 = isDrawable(p1);\n\n    if (d0 && d1) {\n      len0 = curve0.push(p0);\n      len1 = curve1.push(p1);\n    } else if (len0 && len1) {\n      if (!span) {\n        drawArea(ctx, curve0, curve1, len0, len1);\n        len0 = len1 = 0;\n        curve0 = [];\n        curve1 = [];\n      } else {\n        if (d0) {\n          curve0.push(p0);\n        }\n\n        if (d1) {\n          curve1.push(p1);\n        }\n      }\n    }\n  }\n\n  drawArea(ctx, curve0, curve1, len0, len1);\n  ctx.closePath();\n  ctx.fillStyle = color;\n  ctx.fill();\n}\n\nmodule.exports = {\n  id: 'filler',\n  afterDatasetsUpdate: function (chart, options) {\n    var count = (chart.data.datasets || []).length;\n    var propagate = options.propagate;\n    var sources = [];\n    var meta, i, el, source;\n\n    for (i = 0; i < count; ++i) {\n      meta = chart.getDatasetMeta(i);\n      el = meta.dataset;\n      source = null;\n\n      if (el && el._model && el instanceof elements.Line) {\n        source = {\n          visible: chart.isDatasetVisible(i),\n          fill: decodeFill(el, i, count),\n          chart: chart,\n          el: el\n        };\n      }\n\n      meta.$filler = source;\n      sources.push(source);\n    }\n\n    for (i = 0; i < count; ++i) {\n      source = sources[i];\n\n      if (!source) {\n        continue;\n      }\n\n      source.fill = resolveTarget(sources, i, propagate);\n      source.boundary = computeBoundary(source);\n      source.mapper = createMapper(source);\n    }\n  },\n  beforeDatasetDraw: function (chart, args) {\n    var meta = args.meta.$filler;\n\n    if (!meta) {\n      return;\n    }\n\n    var ctx = chart.ctx;\n    var el = meta.el;\n    var view = el._view;\n    var points = el._children || [];\n    var mapper = meta.mapper;\n    var color = view.backgroundColor || defaults.global.defaultColor;\n\n    if (mapper && color && points.length) {\n      helpers.canvas.clipArea(ctx, chart.chartArea);\n      doFill(ctx, points, mapper, view, color, el._loop);\n      helpers.canvas.unclipArea(ctx);\n    }\n  }\n};","map":{"version":3,"sources":["C:/Users/Administrator/.git/asdf/Source Files/node_modules/chart.js/src/plugins/plugin.filler.js"],"names":["defaults","require","elements","helpers","_set","plugins","filler","propagate","mappers","dataset","source","index","fill","chart","meta","getDatasetMeta","visible","isDatasetVisible","points","_children","length","point","i","_view","boundary","x","y","decodeFill","el","count","model","_model","target","undefined","backgroundColor","parseFloat","isFinite","Math","floor","computeBoundary","scale","_scale","horizontal","scaleBottom","bottom","scaleTop","top","scaleZero","getBasePosition","getBasePixel","isHorizontal","resolveTarget","sources","visited","indexOf","push","createMapper","type","isDrawable","skip","drawArea","ctx","curve0","curve1","len0","len1","moveTo","canvas","lineTo","doFill","mapper","view","color","loop","span","spanGaps","ilen","p0","p1","d0","d1","beginPath","closePath","fillStyle","module","exports","id","afterDatasetsUpdate","options","data","datasets","Line","$filler","beforeDatasetDraw","args","global","defaultColor","clipArea","chartArea","_loop","unclipArea"],"mappings":"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","sourcesContent":["/**\n * Plugin based on discussion from the following Chart.js issues:\n * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\n * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\n */\n\n'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n\tplugins: {\n\t\tfiller: {\n\t\t\tpropagate: true\n\t\t}\n\t}\n});\n\nvar mappers = {\n\tdataset: function(source) {\n\t\tvar index = source.fill;\n\t\tvar chart = source.chart;\n\t\tvar meta = chart.getDatasetMeta(index);\n\t\tvar visible = meta && chart.isDatasetVisible(index);\n\t\tvar points = (visible && meta.dataset._children) || [];\n\t\tvar length = points.length || 0;\n\n\t\treturn !length ? null : function(point, i) {\n\t\t\treturn (i < length && points[i]._view) || null;\n\t\t};\n\t},\n\n\tboundary: function(source) {\n\t\tvar boundary = source.boundary;\n\t\tvar x = boundary ? boundary.x : null;\n\t\tvar y = boundary ? boundary.y : null;\n\n\t\treturn function(point) {\n\t\t\treturn {\n\t\t\t\tx: x === null ? point.x : x,\n\t\t\t\ty: y === null ? point.y : y,\n\t\t\t};\n\t\t};\n\t}\n};\n\n// @todo if (fill[0] === '#')\nfunction decodeFill(el, index, count) {\n\tvar model = el._model || {};\n\tvar fill = model.fill;\n\tvar target;\n\n\tif (fill === undefined) {\n\t\tfill = !!model.backgroundColor;\n\t}\n\n\tif (fill === false || fill === null) {\n\t\treturn false;\n\t}\n\n\tif (fill === true) {\n\t\treturn 'origin';\n\t}\n\n\ttarget = parseFloat(fill, 10);\n\tif (isFinite(target) && Math.floor(target) === target) {\n\t\tif (fill[0] === '-' || fill[0] === '+') {\n\t\t\ttarget = index + target;\n\t\t}\n\n\t\tif (target === index || target < 0 || target >= count) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn target;\n\t}\n\n\tswitch (fill) {\n\t// compatibility\n\tcase 'bottom':\n\t\treturn 'start';\n\tcase 'top':\n\t\treturn 'end';\n\tcase 'zero':\n\t\treturn 'origin';\n\t// supported boundaries\n\tcase 'origin':\n\tcase 'start':\n\tcase 'end':\n\t\treturn fill;\n\t// invalid fill values\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nfunction computeBoundary(source) {\n\tvar model = source.el._model || {};\n\tvar scale = source.el._scale || {};\n\tvar fill = source.fill;\n\tvar target = null;\n\tvar horizontal;\n\n\tif (isFinite(fill)) {\n\t\treturn null;\n\t}\n\n\t// Backward compatibility: until v3, we still need to support boundary values set on\n\t// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and\n\t// controllers might still use it (e.g. the Smith chart).\n\n\tif (fill === 'start') {\n\t\ttarget = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;\n\t} else if (fill === 'end') {\n\t\ttarget = model.scaleTop === undefined ? scale.top : model.scaleTop;\n\t} else if (model.scaleZero !== undefined) {\n\t\ttarget = model.scaleZero;\n\t} else if (scale.getBasePosition) {\n\t\ttarget = scale.getBasePosition();\n\t} else if (scale.getBasePixel) {\n\t\ttarget = scale.getBasePixel();\n\t}\n\n\tif (target !== undefined && target !== null) {\n\t\tif (target.x !== undefined && target.y !== undefined) {\n\t\t\treturn target;\n\t\t}\n\n\t\tif (typeof target === 'number' && isFinite(target)) {\n\t\t\thorizontal = scale.isHorizontal();\n\t\t\treturn {\n\t\t\t\tx: horizontal ? target : null,\n\t\t\t\ty: horizontal ? null : target\n\t\t\t};\n\t\t}\n\t}\n\n\treturn null;\n}\n\nfunction resolveTarget(sources, index, propagate) {\n\tvar source = sources[index];\n\tvar fill = source.fill;\n\tvar visited = [index];\n\tvar target;\n\n\tif (!propagate) {\n\t\treturn fill;\n\t}\n\n\twhile (fill !== false && visited.indexOf(fill) === -1) {\n\t\tif (!isFinite(fill)) {\n\t\t\treturn fill;\n\t\t}\n\n\t\ttarget = sources[fill];\n\t\tif (!target) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (target.visible) {\n\t\t\treturn fill;\n\t\t}\n\n\t\tvisited.push(fill);\n\t\tfill = target.fill;\n\t}\n\n\treturn false;\n}\n\nfunction createMapper(source) {\n\tvar fill = source.fill;\n\tvar type = 'dataset';\n\n\tif (fill === false) {\n\t\treturn null;\n\t}\n\n\tif (!isFinite(fill)) {\n\t\ttype = 'boundary';\n\t}\n\n\treturn mappers[type](source);\n}\n\nfunction isDrawable(point) {\n\treturn point && !point.skip;\n}\n\nfunction drawArea(ctx, curve0, curve1, len0, len1) {\n\tvar i;\n\n\tif (!len0 || !len1) {\n\t\treturn;\n\t}\n\n\t// building first area curve (normal)\n\tctx.moveTo(curve0[0].x, curve0[0].y);\n\tfor (i = 1; i < len0; ++i) {\n\t\thelpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);\n\t}\n\n\t// joining the two area curves\n\tctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);\n\n\t// building opposite area curve (reverse)\n\tfor (i = len1 - 1; i > 0; --i) {\n\t\thelpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);\n\t}\n}\n\nfunction doFill(ctx, points, mapper, view, color, loop) {\n\tvar count = points.length;\n\tvar span = view.spanGaps;\n\tvar curve0 = [];\n\tvar curve1 = [];\n\tvar len0 = 0;\n\tvar len1 = 0;\n\tvar i, ilen, index, p0, p1, d0, d1;\n\n\tctx.beginPath();\n\n\tfor (i = 0, ilen = (count + !!loop); i < ilen; ++i) {\n\t\tindex = i % count;\n\t\tp0 = points[index]._view;\n\t\tp1 = mapper(p0, index, view);\n\t\td0 = isDrawable(p0);\n\t\td1 = isDrawable(p1);\n\n\t\tif (d0 && d1) {\n\t\t\tlen0 = curve0.push(p0);\n\t\t\tlen1 = curve1.push(p1);\n\t\t} else if (len0 && len1) {\n\t\t\tif (!span) {\n\t\t\t\tdrawArea(ctx, curve0, curve1, len0, len1);\n\t\t\t\tlen0 = len1 = 0;\n\t\t\t\tcurve0 = [];\n\t\t\t\tcurve1 = [];\n\t\t\t} else {\n\t\t\t\tif (d0) {\n\t\t\t\t\tcurve0.push(p0);\n\t\t\t\t}\n\t\t\t\tif (d1) {\n\t\t\t\t\tcurve1.push(p1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdrawArea(ctx, curve0, curve1, len0, len1);\n\n\tctx.closePath();\n\tctx.fillStyle = color;\n\tctx.fill();\n}\n\nmodule.exports = {\n\tid: 'filler',\n\n\tafterDatasetsUpdate: function(chart, options) {\n\t\tvar count = (chart.data.datasets || []).length;\n\t\tvar propagate = options.propagate;\n\t\tvar sources = [];\n\t\tvar meta, i, el, source;\n\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\tel = meta.dataset;\n\t\t\tsource = null;\n\n\t\t\tif (el && el._model && el instanceof elements.Line) {\n\t\t\t\tsource = {\n\t\t\t\t\tvisible: chart.isDatasetVisible(i),\n\t\t\t\t\tfill: decodeFill(el, i, count),\n\t\t\t\t\tchart: chart,\n\t\t\t\t\tel: el\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tmeta.$filler = source;\n\t\t\tsources.push(source);\n\t\t}\n\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tsource = sources[i];\n\t\t\tif (!source) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsource.fill = resolveTarget(sources, i, propagate);\n\t\t\tsource.boundary = computeBoundary(source);\n\t\t\tsource.mapper = createMapper(source);\n\t\t}\n\t},\n\n\tbeforeDatasetDraw: function(chart, args) {\n\t\tvar meta = args.meta.$filler;\n\t\tif (!meta) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar ctx = chart.ctx;\n\t\tvar el = meta.el;\n\t\tvar view = el._view;\n\t\tvar points = el._children || [];\n\t\tvar mapper = meta.mapper;\n\t\tvar color = view.backgroundColor || defaults.global.defaultColor;\n\n\t\tif (mapper && color && points.length) {\n\t\t\thelpers.canvas.clipArea(ctx, chart.chartArea);\n\t\t\tdoFill(ctx, points, mapper, view, color, el._loop);\n\t\t\thelpers.canvas.unclipArea(ctx);\n\t\t}\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}