{"ast":null,"code":"'use strict';\n\nvar defaults = require('../core/core.defaults');\n\nvar Element = require('../core/core.element');\n\ndefaults._set('global', {\n  elements: {\n    rectangle: {\n      backgroundColor: defaults.global.defaultColor,\n      borderColor: defaults.global.defaultColor,\n      borderSkipped: 'bottom',\n      borderWidth: 0\n    }\n  }\n});\n\nfunction isVertical(bar) {\n  return bar._view.width !== undefined;\n}\n/**\n * Helper function to get the bounds of the bar regardless of the orientation\n * @param bar {Chart.Element.Rectangle} the bar\n * @return {Bounds} bounds of the bar\n * @private\n */\n\n\nfunction getBarBounds(bar) {\n  var vm = bar._view;\n  var x1, x2, y1, y2;\n\n  if (isVertical(bar)) {\n    // vertical\n    var halfWidth = vm.width / 2;\n    x1 = vm.x - halfWidth;\n    x2 = vm.x + halfWidth;\n    y1 = Math.min(vm.y, vm.base);\n    y2 = Math.max(vm.y, vm.base);\n  } else {\n    // horizontal bar\n    var halfHeight = vm.height / 2;\n    x1 = Math.min(vm.x, vm.base);\n    x2 = Math.max(vm.x, vm.base);\n    y1 = vm.y - halfHeight;\n    y2 = vm.y + halfHeight;\n  }\n\n  return {\n    left: x1,\n    top: y1,\n    right: x2,\n    bottom: y2\n  };\n}\n\nmodule.exports = Element.extend({\n  draw: function () {\n    var ctx = this._chart.ctx;\n    var vm = this._view;\n    var left, right, top, bottom, signX, signY, borderSkipped;\n    var borderWidth = vm.borderWidth;\n\n    if (!vm.horizontal) {\n      // bar\n      left = vm.x - vm.width / 2;\n      right = vm.x + vm.width / 2;\n      top = vm.y;\n      bottom = vm.base;\n      signX = 1;\n      signY = bottom > top ? 1 : -1;\n      borderSkipped = vm.borderSkipped || 'bottom';\n    } else {\n      // horizontal bar\n      left = vm.base;\n      right = vm.x;\n      top = vm.y - vm.height / 2;\n      bottom = vm.y + vm.height / 2;\n      signX = right > left ? 1 : -1;\n      signY = 1;\n      borderSkipped = vm.borderSkipped || 'left';\n    } // Canvas doesn't allow us to stroke inside the width so we can\n    // adjust the sizes to fit if we're setting a stroke on the line\n\n\n    if (borderWidth) {\n      // borderWidth shold be less than bar width and bar height.\n      var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\n      borderWidth = borderWidth > barSize ? barSize : borderWidth;\n      var halfStroke = borderWidth / 2; // Adjust borderWidth when bar top position is near vm.base(zero).\n\n      var borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);\n      var borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);\n      var borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);\n      var borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0); // not become a vertical line?\n\n      if (borderLeft !== borderRight) {\n        top = borderTop;\n        bottom = borderBottom;\n      } // not become a horizontal line?\n\n\n      if (borderTop !== borderBottom) {\n        left = borderLeft;\n        right = borderRight;\n      }\n    }\n\n    ctx.beginPath();\n    ctx.fillStyle = vm.backgroundColor;\n    ctx.strokeStyle = vm.borderColor;\n    ctx.lineWidth = borderWidth; // Corner points, from bottom-left to bottom-right clockwise\n    // | 1 2 |\n    // | 0 3 |\n\n    var corners = [[left, bottom], [left, top], [right, top], [right, bottom]]; // Find first (starting) corner with fallback to 'bottom'\n\n    var borders = ['bottom', 'left', 'top', 'right'];\n    var startCorner = borders.indexOf(borderSkipped, 0);\n\n    if (startCorner === -1) {\n      startCorner = 0;\n    }\n\n    function cornerAt(index) {\n      return corners[(startCorner + index) % 4];\n    } // Draw rectangle from 'startCorner'\n\n\n    var corner = cornerAt(0);\n    ctx.moveTo(corner[0], corner[1]);\n\n    for (var i = 1; i < 4; i++) {\n      corner = cornerAt(i);\n      ctx.lineTo(corner[0], corner[1]);\n    }\n\n    ctx.fill();\n\n    if (borderWidth) {\n      ctx.stroke();\n    }\n  },\n  height: function () {\n    var vm = this._view;\n    return vm.base - vm.y;\n  },\n  inRange: function (mouseX, mouseY) {\n    var inRange = false;\n\n    if (this._view) {\n      var bounds = getBarBounds(this);\n      inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\n    }\n\n    return inRange;\n  },\n  inLabelRange: function (mouseX, mouseY) {\n    var me = this;\n\n    if (!me._view) {\n      return false;\n    }\n\n    var inRange = false;\n    var bounds = getBarBounds(me);\n\n    if (isVertical(me)) {\n      inRange = mouseX >= bounds.left && mouseX <= bounds.right;\n    } else {\n      inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;\n    }\n\n    return inRange;\n  },\n  inXRange: function (mouseX) {\n    var bounds = getBarBounds(this);\n    return mouseX >= bounds.left && mouseX <= bounds.right;\n  },\n  inYRange: function (mouseY) {\n    var bounds = getBarBounds(this);\n    return mouseY >= bounds.top && mouseY <= bounds.bottom;\n  },\n  getCenterPoint: function () {\n    var vm = this._view;\n    var x, y;\n\n    if (isVertical(this)) {\n      x = vm.x;\n      y = (vm.y + vm.base) / 2;\n    } else {\n      x = (vm.x + vm.base) / 2;\n      y = vm.y;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  },\n  getArea: function () {\n    var vm = this._view;\n    return vm.width * Math.abs(vm.y - vm.base);\n  },\n  tooltipPosition: function () {\n    var vm = this._view;\n    return {\n      x: vm.x,\n      y: vm.y\n    };\n  }\n});","map":{"version":3,"sources":["C:/Users/Administrator/.git/asdf/Source Files/node_modules/chart.js/src/elements/element.rectangle.js"],"names":["defaults","require","Element","_set","elements","rectangle","backgroundColor","global","defaultColor","borderColor","borderSkipped","borderWidth","isVertical","bar","_view","width","undefined","getBarBounds","vm","x1","x2","y1","y2","halfWidth","x","Math","min","y","base","max","halfHeight","height","left","top","right","bottom","module","exports","extend","draw","ctx","_chart","signX","signY","horizontal","barSize","abs","halfStroke","borderLeft","borderRight","borderTop","borderBottom","beginPath","fillStyle","strokeStyle","lineWidth","corners","borders","startCorner","indexOf","cornerAt","index","corner","moveTo","i","lineTo","fill","stroke","inRange","mouseX","mouseY","bounds","inLabelRange","me","inXRange","inYRange","getCenterPoint","getArea","tooltipPosition"],"mappings":"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","sourcesContent":["'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\n\ndefaults._set('global', {\n\telements: {\n\t\trectangle: {\n\t\t\tbackgroundColor: defaults.global.defaultColor,\n\t\t\tborderColor: defaults.global.defaultColor,\n\t\t\tborderSkipped: 'bottom',\n\t\t\tborderWidth: 0\n\t\t}\n\t}\n});\n\nfunction isVertical(bar) {\n\treturn bar._view.width !== undefined;\n}\n\n/**\n * Helper function to get the bounds of the bar regardless of the orientation\n * @param bar {Chart.Element.Rectangle} the bar\n * @return {Bounds} bounds of the bar\n * @private\n */\nfunction getBarBounds(bar) {\n\tvar vm = bar._view;\n\tvar x1, x2, y1, y2;\n\n\tif (isVertical(bar)) {\n\t\t// vertical\n\t\tvar halfWidth = vm.width / 2;\n\t\tx1 = vm.x - halfWidth;\n\t\tx2 = vm.x + halfWidth;\n\t\ty1 = Math.min(vm.y, vm.base);\n\t\ty2 = Math.max(vm.y, vm.base);\n\t} else {\n\t\t// horizontal bar\n\t\tvar halfHeight = vm.height / 2;\n\t\tx1 = Math.min(vm.x, vm.base);\n\t\tx2 = Math.max(vm.x, vm.base);\n\t\ty1 = vm.y - halfHeight;\n\t\ty2 = vm.y + halfHeight;\n\t}\n\n\treturn {\n\t\tleft: x1,\n\t\ttop: y1,\n\t\tright: x2,\n\t\tbottom: y2\n\t};\n}\n\nmodule.exports = Element.extend({\n\tdraw: function() {\n\t\tvar ctx = this._chart.ctx;\n\t\tvar vm = this._view;\n\t\tvar left, right, top, bottom, signX, signY, borderSkipped;\n\t\tvar borderWidth = vm.borderWidth;\n\n\t\tif (!vm.horizontal) {\n\t\t\t// bar\n\t\t\tleft = vm.x - vm.width / 2;\n\t\t\tright = vm.x + vm.width / 2;\n\t\t\ttop = vm.y;\n\t\t\tbottom = vm.base;\n\t\t\tsignX = 1;\n\t\t\tsignY = bottom > top ? 1 : -1;\n\t\t\tborderSkipped = vm.borderSkipped || 'bottom';\n\t\t} else {\n\t\t\t// horizontal bar\n\t\t\tleft = vm.base;\n\t\t\tright = vm.x;\n\t\t\ttop = vm.y - vm.height / 2;\n\t\t\tbottom = vm.y + vm.height / 2;\n\t\t\tsignX = right > left ? 1 : -1;\n\t\t\tsignY = 1;\n\t\t\tborderSkipped = vm.borderSkipped || 'left';\n\t\t}\n\n\t\t// Canvas doesn't allow us to stroke inside the width so we can\n\t\t// adjust the sizes to fit if we're setting a stroke on the line\n\t\tif (borderWidth) {\n\t\t\t// borderWidth shold be less than bar width and bar height.\n\t\t\tvar barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\n\t\t\tborderWidth = borderWidth > barSize ? barSize : borderWidth;\n\t\t\tvar halfStroke = borderWidth / 2;\n\t\t\t// Adjust borderWidth when bar top position is near vm.base(zero).\n\t\t\tvar borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);\n\t\t\tvar borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);\n\t\t\tvar borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);\n\t\t\tvar borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);\n\t\t\t// not become a vertical line?\n\t\t\tif (borderLeft !== borderRight) {\n\t\t\t\ttop = borderTop;\n\t\t\t\tbottom = borderBottom;\n\t\t\t}\n\t\t\t// not become a horizontal line?\n\t\t\tif (borderTop !== borderBottom) {\n\t\t\t\tleft = borderLeft;\n\t\t\t\tright = borderRight;\n\t\t\t}\n\t\t}\n\n\t\tctx.beginPath();\n\t\tctx.fillStyle = vm.backgroundColor;\n\t\tctx.strokeStyle = vm.borderColor;\n\t\tctx.lineWidth = borderWidth;\n\n\t\t// Corner points, from bottom-left to bottom-right clockwise\n\t\t// | 1 2 |\n\t\t// | 0 3 |\n\t\tvar corners = [\n\t\t\t[left, bottom],\n\t\t\t[left, top],\n\t\t\t[right, top],\n\t\t\t[right, bottom]\n\t\t];\n\n\t\t// Find first (starting) corner with fallback to 'bottom'\n\t\tvar borders = ['bottom', 'left', 'top', 'right'];\n\t\tvar startCorner = borders.indexOf(borderSkipped, 0);\n\t\tif (startCorner === -1) {\n\t\t\tstartCorner = 0;\n\t\t}\n\n\t\tfunction cornerAt(index) {\n\t\t\treturn corners[(startCorner + index) % 4];\n\t\t}\n\n\t\t// Draw rectangle from 'startCorner'\n\t\tvar corner = cornerAt(0);\n\t\tctx.moveTo(corner[0], corner[1]);\n\n\t\tfor (var i = 1; i < 4; i++) {\n\t\t\tcorner = cornerAt(i);\n\t\t\tctx.lineTo(corner[0], corner[1]);\n\t\t}\n\n\t\tctx.fill();\n\t\tif (borderWidth) {\n\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\theight: function() {\n\t\tvar vm = this._view;\n\t\treturn vm.base - vm.y;\n\t},\n\n\tinRange: function(mouseX, mouseY) {\n\t\tvar inRange = false;\n\n\t\tif (this._view) {\n\t\t\tvar bounds = getBarBounds(this);\n\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t}\n\n\t\treturn inRange;\n\t},\n\n\tinLabelRange: function(mouseX, mouseY) {\n\t\tvar me = this;\n\t\tif (!me._view) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar inRange = false;\n\t\tvar bounds = getBarBounds(me);\n\n\t\tif (isVertical(me)) {\n\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right;\n\t\t} else {\n\t\t\tinRange = mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t}\n\n\t\treturn inRange;\n\t},\n\n\tinXRange: function(mouseX) {\n\t\tvar bounds = getBarBounds(this);\n\t\treturn mouseX >= bounds.left && mouseX <= bounds.right;\n\t},\n\n\tinYRange: function(mouseY) {\n\t\tvar bounds = getBarBounds(this);\n\t\treturn mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t},\n\n\tgetCenterPoint: function() {\n\t\tvar vm = this._view;\n\t\tvar x, y;\n\t\tif (isVertical(this)) {\n\t\t\tx = vm.x;\n\t\t\ty = (vm.y + vm.base) / 2;\n\t\t} else {\n\t\t\tx = (vm.x + vm.base) / 2;\n\t\t\ty = vm.y;\n\t\t}\n\n\t\treturn {x: x, y: y};\n\t},\n\n\tgetArea: function() {\n\t\tvar vm = this._view;\n\t\treturn vm.width * Math.abs(vm.y - vm.base);\n\t},\n\n\ttooltipPosition: function() {\n\t\tvar vm = this._view;\n\t\treturn {\n\t\t\tx: vm.x,\n\t\t\ty: vm.y\n\t\t};\n\t}\n});\n"]},"metadata":{},"sourceType":"script"}