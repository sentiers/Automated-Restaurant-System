{"ast":null,"code":"'use strict';\n\nvar helpers = require('../helpers/index');\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\n\n\nmodule.exports = {\n  /**\n   * Namespace to hold formatters for different types of ticks\n   * @namespace Chart.Ticks.formatters\n   */\n  formatters: {\n    /**\n     * Formatter for value labels\n     * @method Chart.Ticks.formatters.values\n     * @param value the value to display\n     * @return {String|Array} the label to display\n     */\n    values: function (value) {\n      return helpers.isArray(value) ? value : '' + value;\n    },\n\n    /**\n     * Formatter for linear numeric ticks\n     * @method Chart.Ticks.formatters.linear\n     * @param tickValue {Number} the value to be formatted\n     * @param index {Number} the position of the tickValue parameter in the ticks array\n     * @param ticks {Array<Number>} the list of ticks being converted\n     * @return {String} string representation of the tickValue parameter\n     */\n    linear: function (tickValue, index, ticks) {\n      // If we have lots of ticks, don't use the ones\n      var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0]; // If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\n      if (Math.abs(delta) > 1) {\n        if (tickValue !== Math.floor(tickValue)) {\n          // not an integer\n          delta = tickValue - Math.floor(tickValue);\n        }\n      }\n\n      var logDelta = helpers.log10(Math.abs(delta));\n      var tickString = '';\n\n      if (tickValue !== 0) {\n        var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));\n\n        if (maxTick < 1e-4) {\n          // all ticks are small numbers; use scientific notation\n          var logTick = helpers.log10(Math.abs(tickValue));\n          tickString = tickValue.toExponential(Math.floor(logTick) - Math.floor(logDelta));\n        } else {\n          var numDecimal = -1 * Math.floor(logDelta);\n          numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\n          tickString = tickValue.toFixed(numDecimal);\n        }\n      } else {\n        tickString = '0'; // never show decimal places for 0\n      }\n\n      return tickString;\n    },\n    logarithmic: function (tickValue, index, ticks) {\n      var remain = tickValue / Math.pow(10, Math.floor(helpers.log10(tickValue)));\n\n      if (tickValue === 0) {\n        return '0';\n      } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n        return tickValue.toExponential();\n      }\n\n      return '';\n    }\n  }\n};","map":{"version":3,"sources":["C:/Users/Administrator/.git/asdf/Source Files/node_modules/chart.js/src/core/core.ticks.js"],"names":["helpers","require","module","exports","formatters","values","value","isArray","linear","tickValue","index","ticks","delta","length","Math","abs","floor","logDelta","log10","tickString","maxTick","max","logTick","toExponential","numDecimal","min","toFixed","logarithmic","remain","pow"],"mappings":"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","sourcesContent":["'use strict';\n\nvar helpers = require('../helpers/index');\n\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\nmodule.exports = {\n\t/**\n\t * Namespace to hold formatters for different types of ticks\n\t * @namespace Chart.Ticks.formatters\n\t */\n\tformatters: {\n\t\t/**\n\t\t * Formatter for value labels\n\t\t * @method Chart.Ticks.formatters.values\n\t\t * @param value the value to display\n\t\t * @return {String|Array} the label to display\n\t\t */\n\t\tvalues: function(value) {\n\t\t\treturn helpers.isArray(value) ? value : '' + value;\n\t\t},\n\n\t\t/**\n\t\t * Formatter for linear numeric ticks\n\t\t * @method Chart.Ticks.formatters.linear\n\t\t * @param tickValue {Number} the value to be formatted\n\t\t * @param index {Number} the position of the tickValue parameter in the ticks array\n\t\t * @param ticks {Array<Number>} the list of ticks being converted\n\t\t * @return {String} string representation of the tickValue parameter\n\t\t */\n\t\tlinear: function(tickValue, index, ticks) {\n\t\t\t// If we have lots of ticks, don't use the ones\n\t\t\tvar delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\n\n\t\t\t// If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\t\t\tif (Math.abs(delta) > 1) {\n\t\t\t\tif (tickValue !== Math.floor(tickValue)) {\n\t\t\t\t\t// not an integer\n\t\t\t\t\tdelta = tickValue - Math.floor(tickValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar logDelta = helpers.log10(Math.abs(delta));\n\t\t\tvar tickString = '';\n\n\t\t\tif (tickValue !== 0) {\n\t\t\t\tvar maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));\n\t\t\t\tif (maxTick < 1e-4) { // all ticks are small numbers; use scientific notation\n\t\t\t\t\tvar logTick = helpers.log10(Math.abs(tickValue));\n\t\t\t\t\ttickString = tickValue.toExponential(Math.floor(logTick) - Math.floor(logDelta));\n\t\t\t\t} else {\n\t\t\t\t\tvar numDecimal = -1 * Math.floor(logDelta);\n\t\t\t\t\tnumDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\t\t\t\t\ttickString = tickValue.toFixed(numDecimal);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttickString = '0'; // never show decimal places for 0\n\t\t\t}\n\n\t\t\treturn tickString;\n\t\t},\n\n\t\tlogarithmic: function(tickValue, index, ticks) {\n\t\t\tvar remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));\n\n\t\t\tif (tickValue === 0) {\n\t\t\t\treturn '0';\n\t\t\t} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n\t\t\t\treturn tickValue.toExponential();\n\t\t\t}\n\t\t\treturn '';\n\t\t}\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}