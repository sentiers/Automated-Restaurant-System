{"ast":null,"code":"/* global window: false */\n'use strict';\n\nvar defaults = require('./core.defaults');\n\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n  animation: {\n    duration: 1000,\n    easing: 'easeOutQuart',\n    onProgress: helpers.noop,\n    onComplete: helpers.noop\n  }\n});\n\nmodule.exports = {\n  frameDuration: 17,\n  animations: [],\n  dropFrames: 0,\n  request: null,\n\n  /**\n   * @param {Chart} chart - The chart to animate.\n   * @param {Chart.Animation} animation - The animation that we will animate.\n   * @param {Number} duration - The animation duration in ms.\n   * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions\n   */\n  addAnimation: function (chart, animation, duration, lazy) {\n    var animations = this.animations;\n    var i, ilen;\n    animation.chart = chart;\n\n    if (!lazy) {\n      chart.animating = true;\n    }\n\n    for (i = 0, ilen = animations.length; i < ilen; ++i) {\n      if (animations[i].chart === chart) {\n        animations[i] = animation;\n        return;\n      }\n    }\n\n    animations.push(animation); // If there are no animations queued, manually kickstart a digest, for lack of a better word\n\n    if (animations.length === 1) {\n      this.requestAnimationFrame();\n    }\n  },\n  cancelAnimation: function (chart) {\n    var index = helpers.findIndex(this.animations, function (animation) {\n      return animation.chart === chart;\n    });\n\n    if (index !== -1) {\n      this.animations.splice(index, 1);\n      chart.animating = false;\n    }\n  },\n  requestAnimationFrame: function () {\n    var me = this;\n\n    if (me.request === null) {\n      // Skip animation frame requests until the active one is executed.\n      // This can happen when processing mouse events, e.g. 'mousemove'\n      // and 'mouseout' events will trigger multiple renders.\n      me.request = helpers.requestAnimFrame.call(window, function () {\n        me.request = null;\n        me.startDigest();\n      });\n    }\n  },\n\n  /**\n   * @private\n   */\n  startDigest: function () {\n    var me = this;\n    var startTime = Date.now();\n    var framesToDrop = 0;\n\n    if (me.dropFrames > 1) {\n      framesToDrop = Math.floor(me.dropFrames);\n      me.dropFrames = me.dropFrames % 1;\n    }\n\n    me.advance(1 + framesToDrop);\n    var endTime = Date.now();\n    me.dropFrames += (endTime - startTime) / me.frameDuration; // Do we have more stuff to animate?\n\n    if (me.animations.length > 0) {\n      me.requestAnimationFrame();\n    }\n  },\n\n  /**\n   * @private\n   */\n  advance: function (count) {\n    var animations = this.animations;\n    var animation, chart;\n    var i = 0;\n\n    while (i < animations.length) {\n      animation = animations[i];\n      chart = animation.chart;\n      animation.currentStep = (animation.currentStep || 0) + count;\n      animation.currentStep = Math.min(animation.currentStep, animation.numSteps);\n      helpers.callback(animation.render, [chart, animation], chart);\n      helpers.callback(animation.onAnimationProgress, [animation], chart);\n\n      if (animation.currentStep >= animation.numSteps) {\n        helpers.callback(animation.onAnimationComplete, [animation], chart);\n        chart.animating = false;\n        animations.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n  }\n};","map":{"version":3,"sources":["C:/Users/Administrator/.git/asdf/Source Files/node_modules/chart.js/src/core/core.animations.js"],"names":["defaults","require","helpers","_set","animation","duration","easing","onProgress","noop","onComplete","module","exports","frameDuration","animations","dropFrames","request","addAnimation","chart","lazy","i","ilen","animating","length","push","requestAnimationFrame","cancelAnimation","index","findIndex","splice","me","requestAnimFrame","call","window","startDigest","startTime","Date","now","framesToDrop","Math","floor","advance","endTime","count","currentStep","min","numSteps","callback","render","onAnimationProgress","onAnimationComplete"],"mappings":"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","sourcesContent":["/* global window: false */\n'use strict';\n\nvar defaults = require('./core.defaults');\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n\tanimation: {\n\t\tduration: 1000,\n\t\teasing: 'easeOutQuart',\n\t\tonProgress: helpers.noop,\n\t\tonComplete: helpers.noop\n\t}\n});\n\nmodule.exports = {\n\tframeDuration: 17,\n\tanimations: [],\n\tdropFrames: 0,\n\trequest: null,\n\n\t/**\n\t * @param {Chart} chart - The chart to animate.\n\t * @param {Chart.Animation} animation - The animation that we will animate.\n\t * @param {Number} duration - The animation duration in ms.\n\t * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions\n\t */\n\taddAnimation: function(chart, animation, duration, lazy) {\n\t\tvar animations = this.animations;\n\t\tvar i, ilen;\n\n\t\tanimation.chart = chart;\n\n\t\tif (!lazy) {\n\t\t\tchart.animating = true;\n\t\t}\n\n\t\tfor (i = 0, ilen = animations.length; i < ilen; ++i) {\n\t\t\tif (animations[i].chart === chart) {\n\t\t\t\tanimations[i] = animation;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tanimations.push(animation);\n\n\t\t// If there are no animations queued, manually kickstart a digest, for lack of a better word\n\t\tif (animations.length === 1) {\n\t\t\tthis.requestAnimationFrame();\n\t\t}\n\t},\n\n\tcancelAnimation: function(chart) {\n\t\tvar index = helpers.findIndex(this.animations, function(animation) {\n\t\t\treturn animation.chart === chart;\n\t\t});\n\n\t\tif (index !== -1) {\n\t\t\tthis.animations.splice(index, 1);\n\t\t\tchart.animating = false;\n\t\t}\n\t},\n\n\trequestAnimationFrame: function() {\n\t\tvar me = this;\n\t\tif (me.request === null) {\n\t\t\t// Skip animation frame requests until the active one is executed.\n\t\t\t// This can happen when processing mouse events, e.g. 'mousemove'\n\t\t\t// and 'mouseout' events will trigger multiple renders.\n\t\t\tme.request = helpers.requestAnimFrame.call(window, function() {\n\t\t\t\tme.request = null;\n\t\t\t\tme.startDigest();\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * @private\n\t */\n\tstartDigest: function() {\n\t\tvar me = this;\n\t\tvar startTime = Date.now();\n\t\tvar framesToDrop = 0;\n\n\t\tif (me.dropFrames > 1) {\n\t\t\tframesToDrop = Math.floor(me.dropFrames);\n\t\t\tme.dropFrames = me.dropFrames % 1;\n\t\t}\n\n\t\tme.advance(1 + framesToDrop);\n\n\t\tvar endTime = Date.now();\n\n\t\tme.dropFrames += (endTime - startTime) / me.frameDuration;\n\n\t\t// Do we have more stuff to animate?\n\t\tif (me.animations.length > 0) {\n\t\t\tme.requestAnimationFrame();\n\t\t}\n\t},\n\n\t/**\n\t * @private\n\t */\n\tadvance: function(count) {\n\t\tvar animations = this.animations;\n\t\tvar animation, chart;\n\t\tvar i = 0;\n\n\t\twhile (i < animations.length) {\n\t\t\tanimation = animations[i];\n\t\t\tchart = animation.chart;\n\n\t\t\tanimation.currentStep = (animation.currentStep || 0) + count;\n\t\t\tanimation.currentStep = Math.min(animation.currentStep, animation.numSteps);\n\n\t\t\thelpers.callback(animation.render, [chart, animation], chart);\n\t\t\thelpers.callback(animation.onAnimationProgress, [animation], chart);\n\n\t\t\tif (animation.currentStep >= animation.numSteps) {\n\t\t\t\thelpers.callback(animation.onAnimationComplete, [animation], chart);\n\t\t\t\tchart.animating = false;\n\t\t\t\tanimations.splice(i, 1);\n\t\t\t} else {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}