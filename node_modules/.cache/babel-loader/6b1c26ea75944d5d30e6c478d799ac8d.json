{"ast":null,"code":"'use strict';\n\nvar defaults = require('../core/core.defaults');\n\nvar Element = require('../core/core.element');\n\nvar helpers = require('../helpers/index');\n\nvar layouts = require('../core/core.layouts');\n\nvar noop = helpers.noop;\n\ndefaults._set('global', {\n  legend: {\n    display: true,\n    position: 'top',\n    fullWidth: true,\n    reverse: false,\n    weight: 1000,\n    // a callback that will handle\n    onClick: function (e, legendItem) {\n      var index = legendItem.datasetIndex;\n      var ci = this.chart;\n      var meta = ci.getDatasetMeta(index); // See controller.isDatasetVisible comment\n\n      meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null; // We hid a dataset ... rerender the chart\n\n      ci.update();\n    },\n    onHover: null,\n    labels: {\n      boxWidth: 40,\n      padding: 10,\n      // Generates labels shown in the legend\n      // Valid properties to return:\n      // text : text to display\n      // fillStyle : fill of coloured box\n      // strokeStyle: stroke of coloured box\n      // hidden : if this legend item refers to a hidden item\n      // lineCap : cap style for line\n      // lineDash\n      // lineDashOffset :\n      // lineJoin :\n      // lineWidth :\n      generateLabels: function (chart) {\n        var data = chart.data;\n        return helpers.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {\n          return {\n            text: dataset.label,\n            fillStyle: !helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],\n            hidden: !chart.isDatasetVisible(i),\n            lineCap: dataset.borderCapStyle,\n            lineDash: dataset.borderDash,\n            lineDashOffset: dataset.borderDashOffset,\n            lineJoin: dataset.borderJoinStyle,\n            lineWidth: dataset.borderWidth,\n            strokeStyle: dataset.borderColor,\n            pointStyle: dataset.pointStyle,\n            // Below is extra data used for toggling the datasets\n            datasetIndex: i\n          };\n        }, this) : [];\n      }\n    }\n  },\n  legendCallback: function (chart) {\n    var text = [];\n    text.push('<ul class=\"' + chart.id + '-legend\">');\n\n    for (var i = 0; i < chart.data.datasets.length; i++) {\n      text.push('<li><span style=\"background-color:' + chart.data.datasets[i].backgroundColor + '\"></span>');\n\n      if (chart.data.datasets[i].label) {\n        text.push(chart.data.datasets[i].label);\n      }\n\n      text.push('</li>');\n    }\n\n    text.push('</ul>');\n    return text.join('');\n  }\n});\n/**\n * Helper function to get the box width based on the usePointStyle option\n * @param labelopts {Object} the label options on the legend\n * @param fontSize {Number} the label font size\n * @return {Number} width of the color box area\n */\n\n\nfunction getBoxWidth(labelOpts, fontSize) {\n  return labelOpts.usePointStyle ? fontSize * Math.SQRT2 : labelOpts.boxWidth;\n}\n/**\n * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\n */\n\n\nvar Legend = Element.extend({\n  initialize: function (config) {\n    helpers.extend(this, config); // Contains hit boxes for each dataset (in dataset order)\n\n    this.legendHitBoxes = []; // Are we in doughnut mode which has a different data type\n\n    this.doughnutMode = false;\n  },\n  // These methods are ordered by lifecycle. Utilities then follow.\n  // Any function defined here is inherited by all legend types.\n  // Any function can be extended by the legend type\n  beforeUpdate: noop,\n  update: function (maxWidth, maxHeight, margins) {\n    var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\n    me.beforeUpdate(); // Absorb the master measurements\n\n    me.maxWidth = maxWidth;\n    me.maxHeight = maxHeight;\n    me.margins = margins; // Dimensions\n\n    me.beforeSetDimensions();\n    me.setDimensions();\n    me.afterSetDimensions(); // Labels\n\n    me.beforeBuildLabels();\n    me.buildLabels();\n    me.afterBuildLabels(); // Fit\n\n    me.beforeFit();\n    me.fit();\n    me.afterFit(); //\n\n    me.afterUpdate();\n    return me.minSize;\n  },\n  afterUpdate: noop,\n  //\n  beforeSetDimensions: noop,\n  setDimensions: function () {\n    var me = this; // Set the unconstrained dimension before label rotation\n\n    if (me.isHorizontal()) {\n      // Reset position before calculating rotation\n      me.width = me.maxWidth;\n      me.left = 0;\n      me.right = me.width;\n    } else {\n      me.height = me.maxHeight; // Reset position before calculating rotation\n\n      me.top = 0;\n      me.bottom = me.height;\n    } // Reset padding\n\n\n    me.paddingLeft = 0;\n    me.paddingTop = 0;\n    me.paddingRight = 0;\n    me.paddingBottom = 0; // Reset minSize\n\n    me.minSize = {\n      width: 0,\n      height: 0\n    };\n  },\n  afterSetDimensions: noop,\n  //\n  beforeBuildLabels: noop,\n  buildLabels: function () {\n    var me = this;\n    var labelOpts = me.options.labels || {};\n    var legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];\n\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter(function (item) {\n        return labelOpts.filter(item, me.chart.data);\n      });\n    }\n\n    if (me.options.reverse) {\n      legendItems.reverse();\n    }\n\n    me.legendItems = legendItems;\n  },\n  afterBuildLabels: noop,\n  //\n  beforeFit: noop,\n  fit: function () {\n    var me = this;\n    var opts = me.options;\n    var labelOpts = opts.labels;\n    var display = opts.display;\n    var ctx = me.ctx;\n    var globalDefault = defaults.global;\n    var valueOrDefault = helpers.valueOrDefault;\n    var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);\n    var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);\n    var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);\n    var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily); // Reset hit boxes\n\n    var hitboxes = me.legendHitBoxes = [];\n    var minSize = me.minSize;\n    var isHorizontal = me.isHorizontal();\n\n    if (isHorizontal) {\n      minSize.width = me.maxWidth; // fill all the width\n\n      minSize.height = display ? 10 : 0;\n    } else {\n      minSize.width = display ? 10 : 0;\n      minSize.height = me.maxHeight; // fill all the height\n    } // Increase sizes here\n\n\n    if (display) {\n      ctx.font = labelFont;\n\n      if (isHorizontal) {\n        // Labels\n        // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n        var lineWidths = me.lineWidths = [0];\n        var totalHeight = me.legendItems.length ? fontSize + labelOpts.padding : 0;\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'top';\n        helpers.each(me.legendItems, function (legendItem, i) {\n          var boxWidth = getBoxWidth(labelOpts, fontSize);\n          var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n\n          if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\n            totalHeight += fontSize + labelOpts.padding;\n            lineWidths[lineWidths.length] = me.left;\n          } // Store the hitbox width and height here. Final position will be updated in `draw`\n\n\n          hitboxes[i] = {\n            left: 0,\n            top: 0,\n            width: width,\n            height: fontSize\n          };\n          lineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n        });\n        minSize.height += totalHeight;\n      } else {\n        var vPadding = labelOpts.padding;\n        var columnWidths = me.columnWidths = [];\n        var totalWidth = labelOpts.padding;\n        var currentColWidth = 0;\n        var currentColHeight = 0;\n        var itemHeight = fontSize + vPadding;\n        helpers.each(me.legendItems, function (legendItem, i) {\n          var boxWidth = getBoxWidth(labelOpts, fontSize);\n          var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width; // If too tall, go to new column\n\n          if (currentColHeight + itemHeight > minSize.height) {\n            totalWidth += currentColWidth + labelOpts.padding;\n            columnWidths.push(currentColWidth); // previous column width\n\n            currentColWidth = 0;\n            currentColHeight = 0;\n          } // Get max width\n\n\n          currentColWidth = Math.max(currentColWidth, itemWidth);\n          currentColHeight += itemHeight; // Store the hitbox width and height here. Final position will be updated in `draw`\n\n          hitboxes[i] = {\n            left: 0,\n            top: 0,\n            width: itemWidth,\n            height: fontSize\n          };\n        });\n        totalWidth += currentColWidth;\n        columnWidths.push(currentColWidth);\n        minSize.width += totalWidth;\n      }\n    }\n\n    me.width = minSize.width;\n    me.height = minSize.height;\n  },\n  afterFit: noop,\n  // Shared Methods\n  isHorizontal: function () {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  },\n  // Actually draw the legend on the canvas\n  draw: function () {\n    var me = this;\n    var opts = me.options;\n    var labelOpts = opts.labels;\n    var globalDefault = defaults.global;\n    var lineDefault = globalDefault.elements.line;\n    var legendWidth = me.width;\n    var lineWidths = me.lineWidths;\n\n    if (opts.display) {\n      var ctx = me.ctx;\n      var valueOrDefault = helpers.valueOrDefault;\n      var fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);\n      var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);\n      var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);\n      var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);\n      var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n      var cursor; // Canvas setup\n\n      ctx.textAlign = 'left';\n      ctx.textBaseline = 'middle';\n      ctx.lineWidth = 0.5;\n      ctx.strokeStyle = fontColor; // for strikethrough effect\n\n      ctx.fillStyle = fontColor; // render in correct colour\n\n      ctx.font = labelFont;\n      var boxWidth = getBoxWidth(labelOpts, fontSize);\n      var hitboxes = me.legendHitBoxes; // current position\n\n      var drawLegendBox = function (x, y, legendItem) {\n        if (isNaN(boxWidth) || boxWidth <= 0) {\n          return;\n        } // Set the ctx for the box\n\n\n        ctx.save();\n        ctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\n        ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n        ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n        ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n        ctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n        ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\n        var isLineWidthZero = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0;\n\n        if (ctx.setLineDash) {\n          // IE 9 and 10 do not support line dash\n          ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));\n        }\n\n        if (opts.labels && opts.labels.usePointStyle) {\n          // Recalculate x and y for drawPoint() because its expecting\n          // x and y to be center of figure (instead of top left)\n          var radius = fontSize * Math.SQRT2 / 2;\n          var offSet = radius / Math.SQRT2;\n          var centerX = x + offSet;\n          var centerY = y + offSet; // Draw pointStyle as legend symbol\n\n          helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n        } else {\n          // Draw box as legend symbol\n          if (!isLineWidthZero) {\n            ctx.strokeRect(x, y, boxWidth, fontSize);\n          }\n\n          ctx.fillRect(x, y, boxWidth, fontSize);\n        }\n\n        ctx.restore();\n      };\n\n      var fillText = function (x, y, legendItem, textWidth) {\n        var halfFontSize = fontSize / 2;\n        var xLeft = boxWidth + halfFontSize + x;\n        var yMiddle = y + halfFontSize;\n        ctx.fillText(legendItem.text, xLeft, yMiddle);\n\n        if (legendItem.hidden) {\n          // Strikethrough the text if hidden\n          ctx.beginPath();\n          ctx.lineWidth = 2;\n          ctx.moveTo(xLeft, yMiddle);\n          ctx.lineTo(xLeft + textWidth, yMiddle);\n          ctx.stroke();\n        }\n      }; // Horizontal\n\n\n      var isHorizontal = me.isHorizontal();\n\n      if (isHorizontal) {\n        cursor = {\n          x: me.left + (legendWidth - lineWidths[0]) / 2,\n          y: me.top + labelOpts.padding,\n          line: 0\n        };\n      } else {\n        cursor = {\n          x: me.left + labelOpts.padding,\n          y: me.top + labelOpts.padding,\n          line: 0\n        };\n      }\n\n      var itemHeight = fontSize + labelOpts.padding;\n      helpers.each(me.legendItems, function (legendItem, i) {\n        var textWidth = ctx.measureText(legendItem.text).width;\n        var width = boxWidth + fontSize / 2 + textWidth;\n        var x = cursor.x;\n        var y = cursor.y;\n\n        if (isHorizontal) {\n          if (x + width >= legendWidth) {\n            y = cursor.y += itemHeight;\n            cursor.line++;\n            x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2;\n          }\n        } else if (y + itemHeight > me.bottom) {\n          x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n          y = cursor.y = me.top + labelOpts.padding;\n          cursor.line++;\n        }\n\n        drawLegendBox(x, y, legendItem);\n        hitboxes[i].left = x;\n        hitboxes[i].top = y; // Fill the actual label\n\n        fillText(x, y, legendItem, textWidth);\n\n        if (isHorizontal) {\n          cursor.x += width + labelOpts.padding;\n        } else {\n          cursor.y += itemHeight;\n        }\n      });\n    }\n  },\n\n  /**\n   * Handle an event\n   * @private\n   * @param {IEvent} event - The event to handle\n   * @return {Boolean} true if a change occured\n   */\n  handleEvent: function (e) {\n    var me = this;\n    var opts = me.options;\n    var type = e.type === 'mouseup' ? 'click' : e.type;\n    var changed = false;\n\n    if (type === 'mousemove') {\n      if (!opts.onHover) {\n        return;\n      }\n    } else if (type === 'click') {\n      if (!opts.onClick) {\n        return;\n      }\n    } else {\n      return;\n    } // Chart event already has relative position in it\n\n\n    var x = e.x;\n    var y = e.y;\n\n    if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n      // See if we are touching one of the dataset boxes\n      var lh = me.legendHitBoxes;\n\n      for (var i = 0; i < lh.length; ++i) {\n        var hitBox = lh[i];\n\n        if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n          // Touching an element\n          if (type === 'click') {\n            // use e.native for backwards compatibility\n            opts.onClick.call(me, e.native, me.legendItems[i]);\n            changed = true;\n            break;\n          } else if (type === 'mousemove') {\n            // use e.native for backwards compatibility\n            opts.onHover.call(me, e.native, me.legendItems[i]);\n            changed = true;\n            break;\n          }\n        }\n      }\n    }\n\n    return changed;\n  }\n});\n\nfunction createNewLegendAndAttach(chart, legendOpts) {\n  var legend = new Legend({\n    ctx: chart.ctx,\n    options: legendOpts,\n    chart: chart\n  });\n  layouts.configure(chart, legend, legendOpts);\n  layouts.addBox(chart, legend);\n  chart.legend = legend;\n}\n\nmodule.exports = {\n  id: 'legend',\n\n  /**\n   * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making\n   * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of\n   * the plugin, which one will be re-exposed in the chart.js file.\n   * https://github.com/chartjs/Chart.js/pull/2640\n   * @private\n   */\n  _element: Legend,\n  beforeInit: function (chart) {\n    var legendOpts = chart.options.legend;\n\n    if (legendOpts) {\n      createNewLegendAndAttach(chart, legendOpts);\n    }\n  },\n  beforeUpdate: function (chart) {\n    var legendOpts = chart.options.legend;\n    var legend = chart.legend;\n\n    if (legendOpts) {\n      helpers.mergeIf(legendOpts, defaults.global.legend);\n\n      if (legend) {\n        layouts.configure(chart, legend, legendOpts);\n        legend.options = legendOpts;\n      } else {\n        createNewLegendAndAttach(chart, legendOpts);\n      }\n    } else if (legend) {\n      layouts.removeBox(chart, legend);\n      delete chart.legend;\n    }\n  },\n  afterEvent: function (chart, e) {\n    var legend = chart.legend;\n\n    if (legend) {\n      legend.handleEvent(e);\n    }\n  }\n};","map":{"version":3,"sources":["C:/Users/Administrator/.git/asdf/Source Files/node_modules/chart.js/src/plugins/plugin.legend.js"],"names":["defaults","require","Element","helpers","layouts","noop","_set","legend","display","position","fullWidth","reverse","weight","onClick","e","legendItem","index","datasetIndex","ci","chart","meta","getDatasetMeta","hidden","data","datasets","update","onHover","labels","boxWidth","padding","generateLabels","isArray","map","dataset","i","text","label","fillStyle","backgroundColor","isDatasetVisible","lineCap","borderCapStyle","lineDash","borderDash","lineDashOffset","borderDashOffset","lineJoin","borderJoinStyle","lineWidth","borderWidth","strokeStyle","borderColor","pointStyle","legendCallback","push","id","length","join","getBoxWidth","labelOpts","fontSize","usePointStyle","Math","SQRT2","Legend","extend","initialize","config","legendHitBoxes","doughnutMode","beforeUpdate","maxWidth","maxHeight","margins","me","beforeSetDimensions","setDimensions","afterSetDimensions","beforeBuildLabels","buildLabels","afterBuildLabels","beforeFit","fit","afterFit","afterUpdate","minSize","isHorizontal","width","left","right","height","top","bottom","paddingLeft","paddingTop","paddingRight","paddingBottom","options","legendItems","callback","filter","item","opts","ctx","globalDefault","global","valueOrDefault","defaultFontSize","fontStyle","defaultFontStyle","fontFamily","defaultFontFamily","labelFont","fontString","hitboxes","font","lineWidths","totalHeight","textAlign","textBaseline","each","measureText","vPadding","columnWidths","totalWidth","currentColWidth","currentColHeight","itemHeight","itemWidth","max","draw","lineDefault","elements","line","legendWidth","fontColor","defaultFontColor","cursor","drawLegendBox","x","y","isNaN","save","defaultColor","isLineWidthZero","setLineDash","radius","offSet","centerX","centerY","canvas","drawPoint","strokeRect","fillRect","restore","fillText","textWidth","halfFontSize","xLeft","yMiddle","beginPath","moveTo","lineTo","stroke","handleEvent","type","changed","lh","hitBox","call","native","createNewLegendAndAttach","legendOpts","configure","addBox","module","exports","_element","beforeInit","mergeIf","removeBox","afterEvent"],"mappings":"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","sourcesContent":["'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\nvar helpers = require('../helpers/index');\nvar layouts = require('../core/core.layouts');\n\nvar noop = helpers.noop;\n\ndefaults._set('global', {\n\tlegend: {\n\t\tdisplay: true,\n\t\tposition: 'top',\n\t\tfullWidth: true,\n\t\treverse: false,\n\t\tweight: 1000,\n\n\t\t// a callback that will handle\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.datasetIndex;\n\t\t\tvar ci = this.chart;\n\t\t\tvar meta = ci.getDatasetMeta(index);\n\n\t\t\t// See controller.isDatasetVisible comment\n\t\t\tmeta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;\n\n\t\t\t// We hid a dataset ... rerender the chart\n\t\t\tci.update();\n\t\t},\n\n\t\tonHover: null,\n\n\t\tlabels: {\n\t\t\tboxWidth: 40,\n\t\t\tpadding: 10,\n\t\t\t// Generates labels shown in the legend\n\t\t\t// Valid properties to return:\n\t\t\t// text : text to display\n\t\t\t// fillStyle : fill of coloured box\n\t\t\t// strokeStyle: stroke of coloured box\n\t\t\t// hidden : if this legend item refers to a hidden item\n\t\t\t// lineCap : cap style for line\n\t\t\t// lineDash\n\t\t\t// lineDashOffset :\n\t\t\t// lineJoin :\n\t\t\t// lineWidth :\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\treturn helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: dataset.label,\n\t\t\t\t\t\tfillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),\n\t\t\t\t\t\thidden: !chart.isDatasetVisible(i),\n\t\t\t\t\t\tlineCap: dataset.borderCapStyle,\n\t\t\t\t\t\tlineDash: dataset.borderDash,\n\t\t\t\t\t\tlineDashOffset: dataset.borderDashOffset,\n\t\t\t\t\t\tlineJoin: dataset.borderJoinStyle,\n\t\t\t\t\t\tlineWidth: dataset.borderWidth,\n\t\t\t\t\t\tstrokeStyle: dataset.borderColor,\n\t\t\t\t\t\tpointStyle: dataset.pointStyle,\n\n\t\t\t\t\t\t// Below is extra data used for toggling the datasets\n\t\t\t\t\t\tdatasetIndex: i\n\t\t\t\t\t};\n\t\t\t\t}, this) : [];\n\t\t\t}\n\t\t}\n\t},\n\n\tlegendCallback: function(chart) {\n\t\tvar text = [];\n\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\t\tfor (var i = 0; i < chart.data.datasets.length; i++) {\n\t\t\ttext.push('<li><span style=\"background-color:' + chart.data.datasets[i].backgroundColor + '\"></span>');\n\t\t\tif (chart.data.datasets[i].label) {\n\t\t\t\ttext.push(chart.data.datasets[i].label);\n\t\t\t}\n\t\t\ttext.push('</li>');\n\t\t}\n\t\ttext.push('</ul>');\n\t\treturn text.join('');\n\t}\n});\n\n/**\n * Helper function to get the box width based on the usePointStyle option\n * @param labelopts {Object} the label options on the legend\n * @param fontSize {Number} the label font size\n * @return {Number} width of the color box area\n */\nfunction getBoxWidth(labelOpts, fontSize) {\n\treturn labelOpts.usePointStyle ?\n\t\tfontSize * Math.SQRT2 :\n\t\tlabelOpts.boxWidth;\n}\n\n/**\n * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\n */\nvar Legend = Element.extend({\n\n\tinitialize: function(config) {\n\t\thelpers.extend(this, config);\n\n\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\tthis.legendHitBoxes = [];\n\n\t\t// Are we in doughnut mode which has a different data type\n\t\tthis.doughnutMode = false;\n\t},\n\n\t// These methods are ordered by lifecycle. Utilities then follow.\n\t// Any function defined here is inherited by all legend types.\n\t// Any function can be extended by the legend type\n\n\tbeforeUpdate: noop,\n\tupdate: function(maxWidth, maxHeight, margins) {\n\t\tvar me = this;\n\n\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\tme.beforeUpdate();\n\n\t\t// Absorb the master measurements\n\t\tme.maxWidth = maxWidth;\n\t\tme.maxHeight = maxHeight;\n\t\tme.margins = margins;\n\n\t\t// Dimensions\n\t\tme.beforeSetDimensions();\n\t\tme.setDimensions();\n\t\tme.afterSetDimensions();\n\t\t// Labels\n\t\tme.beforeBuildLabels();\n\t\tme.buildLabels();\n\t\tme.afterBuildLabels();\n\n\t\t// Fit\n\t\tme.beforeFit();\n\t\tme.fit();\n\t\tme.afterFit();\n\t\t//\n\t\tme.afterUpdate();\n\n\t\treturn me.minSize;\n\t},\n\tafterUpdate: noop,\n\n\t//\n\n\tbeforeSetDimensions: noop,\n\tsetDimensions: function() {\n\t\tvar me = this;\n\t\t// Set the unconstrained dimension before label rotation\n\t\tif (me.isHorizontal()) {\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.left = 0;\n\t\t\tme.right = me.width;\n\t\t} else {\n\t\t\tme.height = me.maxHeight;\n\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.top = 0;\n\t\t\tme.bottom = me.height;\n\t\t}\n\n\t\t// Reset padding\n\t\tme.paddingLeft = 0;\n\t\tme.paddingTop = 0;\n\t\tme.paddingRight = 0;\n\t\tme.paddingBottom = 0;\n\n\t\t// Reset minSize\n\t\tme.minSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\t},\n\tafterSetDimensions: noop,\n\n\t//\n\n\tbeforeBuildLabels: noop,\n\tbuildLabels: function() {\n\t\tvar me = this;\n\t\tvar labelOpts = me.options.labels || {};\n\t\tvar legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];\n\n\t\tif (labelOpts.filter) {\n\t\t\tlegendItems = legendItems.filter(function(item) {\n\t\t\t\treturn labelOpts.filter(item, me.chart.data);\n\t\t\t});\n\t\t}\n\n\t\tif (me.options.reverse) {\n\t\t\tlegendItems.reverse();\n\t\t}\n\n\t\tme.legendItems = legendItems;\n\t},\n\tafterBuildLabels: noop,\n\n\t//\n\n\tbeforeFit: noop,\n\tfit: function() {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar labelOpts = opts.labels;\n\t\tvar display = opts.display;\n\n\t\tvar ctx = me.ctx;\n\n\t\tvar globalDefault = defaults.global;\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\tvar fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);\n\t\tvar fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);\n\t\tvar fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);\n\t\tvar labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\t// Reset hit boxes\n\t\tvar hitboxes = me.legendHitBoxes = [];\n\n\t\tvar minSize = me.minSize;\n\t\tvar isHorizontal = me.isHorizontal();\n\n\t\tif (isHorizontal) {\n\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\tminSize.height = display ? 10 : 0;\n\t\t} else {\n\t\t\tminSize.width = display ? 10 : 0;\n\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t}\n\n\t\t// Increase sizes here\n\t\tif (display) {\n\t\t\tctx.font = labelFont;\n\n\t\t\tif (isHorizontal) {\n\t\t\t\t// Labels\n\n\t\t\t\t// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n\t\t\t\tvar lineWidths = me.lineWidths = [0];\n\t\t\t\tvar totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;\n\n\t\t\t\tctx.textAlign = 'left';\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\tvar width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\tif (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\n\t\t\t\t\t\ttotalHeight += fontSize + (labelOpts.padding);\n\t\t\t\t\t\tlineWidths[lineWidths.length] = me.left;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\twidth: width,\n\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t};\n\n\t\t\t\t\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n\t\t\t\t});\n\n\t\t\t\tminSize.height += totalHeight;\n\n\t\t\t} else {\n\t\t\t\tvar vPadding = labelOpts.padding;\n\t\t\t\tvar columnWidths = me.columnWidths = [];\n\t\t\t\tvar totalWidth = labelOpts.padding;\n\t\t\t\tvar currentColWidth = 0;\n\t\t\t\tvar currentColHeight = 0;\n\t\t\t\tvar itemHeight = fontSize + vPadding;\n\n\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\tvar itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\t// If too tall, go to new column\n\t\t\t\t\tif (currentColHeight + itemHeight > minSize.height) {\n\t\t\t\t\t\ttotalWidth += currentColWidth + labelOpts.padding;\n\t\t\t\t\t\tcolumnWidths.push(currentColWidth); // previous column width\n\n\t\t\t\t\t\tcurrentColWidth = 0;\n\t\t\t\t\t\tcurrentColHeight = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get max width\n\t\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\n\t\t\t\t\tcurrentColHeight += itemHeight;\n\n\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\twidth: itemWidth,\n\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\ttotalWidth += currentColWidth;\n\t\t\t\tcolumnWidths.push(currentColWidth);\n\t\t\t\tminSize.width += totalWidth;\n\t\t\t}\n\t\t}\n\n\t\tme.width = minSize.width;\n\t\tme.height = minSize.height;\n\t},\n\tafterFit: noop,\n\n\t// Shared Methods\n\tisHorizontal: function() {\n\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t},\n\n\t// Actually draw the legend on the canvas\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar labelOpts = opts.labels;\n\t\tvar globalDefault = defaults.global;\n\t\tvar lineDefault = globalDefault.elements.line;\n\t\tvar legendWidth = me.width;\n\t\tvar lineWidths = me.lineWidths;\n\n\t\tif (opts.display) {\n\t\t\tvar ctx = me.ctx;\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\t\tvar fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);\n\t\t\tvar fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);\n\t\t\tvar fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);\n\t\t\tvar fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);\n\t\t\tvar labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\t\t\tvar cursor;\n\n\t\t\t// Canvas setup\n\t\t\tctx.textAlign = 'left';\n\t\t\tctx.textBaseline = 'middle';\n\t\t\tctx.lineWidth = 0.5;\n\t\t\tctx.strokeStyle = fontColor; // for strikethrough effect\n\t\t\tctx.fillStyle = fontColor; // render in correct colour\n\t\t\tctx.font = labelFont;\n\n\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\tvar hitboxes = me.legendHitBoxes;\n\n\t\t\t// current position\n\t\t\tvar drawLegendBox = function(x, y, legendItem) {\n\t\t\t\tif (isNaN(boxWidth) || boxWidth <= 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Set the ctx for the box\n\t\t\t\tctx.save();\n\n\t\t\t\tctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\n\t\t\t\tctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n\t\t\t\tctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n\t\t\t\tctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n\t\t\t\tctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n\t\t\t\tctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\n\t\t\t\tvar isLineWidthZero = (valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);\n\n\t\t\t\tif (ctx.setLineDash) {\n\t\t\t\t\t// IE 9 and 10 do not support line dash\n\t\t\t\t\tctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));\n\t\t\t\t}\n\n\t\t\t\tif (opts.labels && opts.labels.usePointStyle) {\n\t\t\t\t\t// Recalculate x and y for drawPoint() because its expecting\n\t\t\t\t\t// x and y to be center of figure (instead of top left)\n\t\t\t\t\tvar radius = fontSize * Math.SQRT2 / 2;\n\t\t\t\t\tvar offSet = radius / Math.SQRT2;\n\t\t\t\t\tvar centerX = x + offSet;\n\t\t\t\t\tvar centerY = y + offSet;\n\n\t\t\t\t\t// Draw pointStyle as legend symbol\n\t\t\t\t\thelpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n\t\t\t\t} else {\n\t\t\t\t\t// Draw box as legend symbol\n\t\t\t\t\tif (!isLineWidthZero) {\n\t\t\t\t\t\tctx.strokeRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t}\n\t\t\t\t\tctx.fillRect(x, y, boxWidth, fontSize);\n\t\t\t\t}\n\n\t\t\t\tctx.restore();\n\t\t\t};\n\t\t\tvar fillText = function(x, y, legendItem, textWidth) {\n\t\t\t\tvar halfFontSize = fontSize / 2;\n\t\t\t\tvar xLeft = boxWidth + halfFontSize + x;\n\t\t\t\tvar yMiddle = y + halfFontSize;\n\n\t\t\t\tctx.fillText(legendItem.text, xLeft, yMiddle);\n\n\t\t\t\tif (legendItem.hidden) {\n\t\t\t\t\t// Strikethrough the text if hidden\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\tctx.moveTo(xLeft, yMiddle);\n\t\t\t\t\tctx.lineTo(xLeft + textWidth, yMiddle);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Horizontal\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tif (isHorizontal) {\n\t\t\t\tcursor = {\n\t\t\t\t\tx: me.left + ((legendWidth - lineWidths[0]) / 2),\n\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\tline: 0\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tcursor = {\n\t\t\t\t\tx: me.left + labelOpts.padding,\n\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\tline: 0\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar itemHeight = fontSize + labelOpts.padding;\n\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\tvar textWidth = ctx.measureText(legendItem.text).width;\n\t\t\t\tvar width = boxWidth + (fontSize / 2) + textWidth;\n\t\t\t\tvar x = cursor.x;\n\t\t\t\tvar y = cursor.y;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tif (x + width >= legendWidth) {\n\t\t\t\t\t\ty = cursor.y += itemHeight;\n\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t\tx = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);\n\t\t\t\t\t}\n\t\t\t\t} else if (y + itemHeight > me.bottom) {\n\t\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n\t\t\t\t\ty = cursor.y = me.top + labelOpts.padding;\n\t\t\t\t\tcursor.line++;\n\t\t\t\t}\n\n\t\t\t\tdrawLegendBox(x, y, legendItem);\n\n\t\t\t\thitboxes[i].left = x;\n\t\t\t\thitboxes[i].top = y;\n\n\t\t\t\t// Fill the actual label\n\t\t\t\tfillText(x, y, legendItem, textWidth);\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tcursor.x += width + (labelOpts.padding);\n\t\t\t\t} else {\n\t\t\t\t\tcursor.y += itemHeight;\n\t\t\t\t}\n\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Handle an event\n\t * @private\n\t * @param {IEvent} event - The event to handle\n\t * @return {Boolean} true if a change occured\n\t */\n\thandleEvent: function(e) {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar type = e.type === 'mouseup' ? 'click' : e.type;\n\t\tvar changed = false;\n\n\t\tif (type === 'mousemove') {\n\t\t\tif (!opts.onHover) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (type === 'click') {\n\t\t\tif (!opts.onClick) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\t// Chart event already has relative position in it\n\t\tvar x = e.x;\n\t\tvar y = e.y;\n\n\t\tif (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n\t\t\t// See if we are touching one of the dataset boxes\n\t\t\tvar lh = me.legendHitBoxes;\n\t\t\tfor (var i = 0; i < lh.length; ++i) {\n\t\t\t\tvar hitBox = lh[i];\n\n\t\t\t\tif (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n\t\t\t\t\t// Touching an element\n\t\t\t\t\tif (type === 'click') {\n\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\topts.onClick.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (type === 'mousemove') {\n\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\topts.onHover.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn changed;\n\t}\n});\n\nfunction createNewLegendAndAttach(chart, legendOpts) {\n\tvar legend = new Legend({\n\t\tctx: chart.ctx,\n\t\toptions: legendOpts,\n\t\tchart: chart\n\t});\n\n\tlayouts.configure(chart, legend, legendOpts);\n\tlayouts.addBox(chart, legend);\n\tchart.legend = legend;\n}\n\nmodule.exports = {\n\tid: 'legend',\n\n\t/**\n\t * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making\n\t * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of\n\t * the plugin, which one will be re-exposed in the chart.js file.\n\t * https://github.com/chartjs/Chart.js/pull/2640\n\t * @private\n\t */\n\t_element: Legend,\n\n\tbeforeInit: function(chart) {\n\t\tvar legendOpts = chart.options.legend;\n\n\t\tif (legendOpts) {\n\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t}\n\t},\n\n\tbeforeUpdate: function(chart) {\n\t\tvar legendOpts = chart.options.legend;\n\t\tvar legend = chart.legend;\n\n\t\tif (legendOpts) {\n\t\t\thelpers.mergeIf(legendOpts, defaults.global.legend);\n\n\t\t\tif (legend) {\n\t\t\t\tlayouts.configure(chart, legend, legendOpts);\n\t\t\t\tlegend.options = legendOpts;\n\t\t\t} else {\n\t\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t\t}\n\t\t} else if (legend) {\n\t\t\tlayouts.removeBox(chart, legend);\n\t\t\tdelete chart.legend;\n\t\t}\n\t},\n\n\tafterEvent: function(chart, e) {\n\t\tvar legend = chart.legend;\n\t\tif (legend) {\n\t\t\tlegend.handleEvent(e);\n\t\t}\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}