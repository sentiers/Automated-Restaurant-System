{"ast":null,"code":"/* global window: false */\n'use strict';\n\nvar moment = require('moment');\n\nmoment = typeof moment === 'function' ? moment : window.moment;\n\nvar defaults = require('../core/core.defaults');\n\nvar helpers = require('../helpers/index');\n\nvar Scale = require('../core/core.scale');\n\nvar scaleService = require('../core/core.scaleService'); // Integer constants are from the ES6 spec.\n\n\nvar MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;\nvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\nvar INTERVALS = {\n  millisecond: {\n    common: true,\n    size: 1,\n    steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n  },\n  second: {\n    common: true,\n    size: 1000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  minute: {\n    common: true,\n    size: 60000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  hour: {\n    common: true,\n    size: 3600000,\n    steps: [1, 2, 3, 6, 12]\n  },\n  day: {\n    common: true,\n    size: 86400000,\n    steps: [1, 2, 5]\n  },\n  week: {\n    common: false,\n    size: 604800000,\n    steps: [1, 2, 3, 4]\n  },\n  month: {\n    common: true,\n    size: 2.628e9,\n    steps: [1, 2, 3]\n  },\n  quarter: {\n    common: false,\n    size: 7.884e9,\n    steps: [1, 2, 3, 4]\n  },\n  year: {\n    common: true,\n    size: 3.154e10\n  }\n};\nvar UNITS = Object.keys(INTERVALS);\n\nfunction sorter(a, b) {\n  return a - b;\n}\n\nfunction arrayUnique(items) {\n  var hash = {};\n  var out = [];\n  var i, ilen, item;\n\n  for (i = 0, ilen = items.length; i < ilen; ++i) {\n    item = items[i];\n\n    if (!hash[item]) {\n      hash[item] = true;\n      out.push(item);\n    }\n  }\n\n  return out;\n}\n/**\n * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\n * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\n * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\n * extremity (left + width or top + height). Note that it would be more optimized to directly\n * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\n * to create the lookup table. The table ALWAYS contains at least two items: min and max.\n *\n * @param {Number[]} timestamps - timestamps sorted from lowest to highest.\n * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min\n * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.\n * If 'series', timestamps will be positioned at the same distance from each other. In this\n * case, only timestamps that break the time linearity are registered, meaning that in the\n * best case, all timestamps are linear, the table contains only min and max.\n */\n\n\nfunction buildLookupTable(timestamps, min, max, distribution) {\n  if (distribution === 'linear' || !timestamps.length) {\n    return [{\n      time: min,\n      pos: 0\n    }, {\n      time: max,\n      pos: 1\n    }];\n  }\n\n  var table = [];\n  var items = [min];\n  var i, ilen, prev, curr, next;\n\n  for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n    curr = timestamps[i];\n\n    if (curr > min && curr < max) {\n      items.push(curr);\n    }\n  }\n\n  items.push(max);\n\n  for (i = 0, ilen = items.length; i < ilen; ++i) {\n    next = items[i + 1];\n    prev = items[i - 1];\n    curr = items[i]; // only add points that breaks the scale linearity\n\n    if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {\n      table.push({\n        time: curr,\n        pos: i / (ilen - 1)\n      });\n    }\n  }\n\n  return table;\n} // @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/\n\n\nfunction lookup(table, key, value) {\n  var lo = 0;\n  var hi = table.length - 1;\n  var mid, i0, i1;\n\n  while (lo >= 0 && lo <= hi) {\n    mid = lo + hi >> 1;\n    i0 = table[mid - 1] || null;\n    i1 = table[mid];\n\n    if (!i0) {\n      // given value is outside table (before first item)\n      return {\n        lo: null,\n        hi: i1\n      };\n    } else if (i1[key] < value) {\n      lo = mid + 1;\n    } else if (i0[key] > value) {\n      hi = mid - 1;\n    } else {\n      return {\n        lo: i0,\n        hi: i1\n      };\n    }\n  } // given value is outside table (after last item)\n\n\n  return {\n    lo: i1,\n    hi: null\n  };\n}\n/**\n * Linearly interpolates the given source `value` using the table items `skey` values and\n * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\n * returns the position for a timestamp equal to 42. If value is out of bounds, values at\n * index [0, 1] or [n - 1, n] are used for the interpolation.\n */\n\n\nfunction interpolate(table, skey, sval, tkey) {\n  var range = lookup(table, skey, sval); // Note: the lookup table ALWAYS contains at least 2 items (min and max)\n\n  var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;\n  var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;\n  var span = next[skey] - prev[skey];\n  var ratio = span ? (sval - prev[skey]) / span : 0;\n  var offset = (next[tkey] - prev[tkey]) * ratio;\n  return prev[tkey] + offset;\n}\n/**\n * Convert the given value to a moment object using the given time options.\n * @see http://momentjs.com/docs/#/parsing/\n */\n\n\nfunction momentify(value, options) {\n  var parser = options.parser;\n  var format = options.parser || options.format;\n\n  if (typeof parser === 'function') {\n    return parser(value);\n  }\n\n  if (typeof value === 'string' && typeof format === 'string') {\n    return moment(value, format);\n  }\n\n  if (!(value instanceof moment)) {\n    value = moment(value);\n  }\n\n  if (value.isValid()) {\n    return value;\n  } // Labels are in an incompatible moment format and no `parser` has been provided.\n  // The user might still use the deprecated `format` option to convert his inputs.\n\n\n  if (typeof format === 'function') {\n    return format(value);\n  }\n\n  return value;\n}\n\nfunction parse(input, scale) {\n  if (helpers.isNullOrUndef(input)) {\n    return null;\n  }\n\n  var options = scale.options.time;\n  var value = momentify(scale.getRightValue(input), options);\n\n  if (!value.isValid()) {\n    return null;\n  }\n\n  if (options.round) {\n    value.startOf(options.round);\n  }\n\n  return value.valueOf();\n}\n/**\n * Returns the number of unit to skip to be able to display up to `capacity` number of ticks\n * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.\n */\n\n\nfunction determineStepSize(min, max, unit, capacity) {\n  var range = max - min;\n  var interval = INTERVALS[unit];\n  var milliseconds = interval.size;\n  var steps = interval.steps;\n  var i, ilen, factor;\n\n  if (!steps) {\n    return Math.ceil(range / (capacity * milliseconds));\n  }\n\n  for (i = 0, ilen = steps.length; i < ilen; ++i) {\n    factor = steps[i];\n\n    if (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n      break;\n    }\n  }\n\n  return factor;\n}\n/**\n * Figures out what unit results in an appropriate number of auto-generated ticks\n */\n\n\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  var ilen = UNITS.length;\n  var i, interval, factor;\n\n  for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    interval = INTERVALS[UNITS[i]];\n    factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;\n\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n\n  return UNITS[ilen - 1];\n}\n/**\n * Figures out what unit to format a set of ticks with\n */\n\n\nfunction determineUnitForFormatting(ticks, minUnit, min, max) {\n  var duration = moment.duration(moment(max).diff(moment(min)));\n  var ilen = UNITS.length;\n  var i, unit;\n\n  for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {\n    unit = UNITS[i];\n\n    if (INTERVALS[unit].common && duration.as(unit) >= ticks.length) {\n      return unit;\n    }\n  }\n\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\nfunction determineMajorUnit(unit) {\n  for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\n/**\n * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n * `minor` unit, aligned on the `major` unit and using the given scale time `options`.\n * Important: this method can return ticks outside the min and max range, it's the\n * responsibility of the calling code to clamp values if needed.\n */\n\n\nfunction generate(min, max, capacity, options) {\n  var timeOpts = options.time;\n  var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n  var major = determineMajorUnit(minor);\n  var stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);\n  var weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n  var majorTicksEnabled = options.ticks.major.enabled;\n  var interval = INTERVALS[minor];\n  var first = moment(min);\n  var last = moment(max);\n  var ticks = [];\n  var time;\n\n  if (!stepSize) {\n    stepSize = determineStepSize(min, max, minor, capacity);\n  } // For 'week' unit, handle the first day of week option\n\n\n  if (weekday) {\n    first = first.isoWeekday(weekday);\n    last = last.isoWeekday(weekday);\n  } // Align first/last ticks on unit\n\n\n  first = first.startOf(weekday ? 'day' : minor);\n  last = last.startOf(weekday ? 'day' : minor); // Make sure that the last tick include max\n\n  if (last < max) {\n    last.add(1, minor);\n  }\n\n  time = moment(first);\n\n  if (majorTicksEnabled && major && !weekday && !timeOpts.round) {\n    // Align the first tick on the previous `minor` unit aligned on the `major` unit:\n    // we first aligned time on the previous `major` unit then add the number of full\n    // stepSize there is between first and the previous major time.\n    time.startOf(major);\n    time.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n  }\n\n  for (; time < last; time.add(stepSize, minor)) {\n    ticks.push(+time);\n  }\n\n  ticks.push(+time);\n  return ticks;\n}\n/**\n * Returns the right and left offsets from edges in the form of {left, right}.\n * Offsets are added when the `offset` option is true.\n */\n\n\nfunction computeOffsets(table, ticks, min, max, options) {\n  var left = 0;\n  var right = 0;\n  var upper, lower;\n\n  if (options.offset && ticks.length) {\n    if (!options.time.min) {\n      upper = ticks.length > 1 ? ticks[1] : max;\n      lower = ticks[0];\n      left = (interpolate(table, 'time', upper, 'pos') - interpolate(table, 'time', lower, 'pos')) / 2;\n    }\n\n    if (!options.time.max) {\n      upper = ticks[ticks.length - 1];\n      lower = ticks.length > 1 ? ticks[ticks.length - 2] : min;\n      right = (interpolate(table, 'time', upper, 'pos') - interpolate(table, 'time', lower, 'pos')) / 2;\n    }\n  }\n\n  return {\n    left: left,\n    right: right\n  };\n}\n\nfunction ticksFromTimestamps(values, majorUnit) {\n  var ticks = [];\n  var i, ilen, value, major;\n\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    value = values[i];\n    major = majorUnit ? value === +moment(value).startOf(majorUnit) : false;\n    ticks.push({\n      value: value,\n      major: major\n    });\n  }\n\n  return ticks;\n}\n\nfunction determineLabelFormat(data, timeOpts) {\n  var i, momentDate, hasTime;\n  var ilen = data.length; // find the label with the most parts (milliseconds, minutes, etc.)\n  // format all labels with the same level of detail as the most specific label\n\n  for (i = 0; i < ilen; i++) {\n    momentDate = momentify(data[i], timeOpts);\n\n    if (momentDate.millisecond() !== 0) {\n      return 'MMM D, YYYY h:mm:ss.SSS a';\n    }\n\n    if (momentDate.second() !== 0 || momentDate.minute() !== 0 || momentDate.hour() !== 0) {\n      hasTime = true;\n    }\n  }\n\n  if (hasTime) {\n    return 'MMM D, YYYY h:mm:ss a';\n  }\n\n  return 'MMM D, YYYY';\n}\n\nmodule.exports = function () {\n  var defaultConfig = {\n    position: 'bottom',\n\n    /**\n     * Data distribution along the scale:\n     * - 'linear': data are spread according to their time (distances can vary),\n     * - 'series': data are spread at the same distance from each other.\n     * @see https://github.com/chartjs/Chart.js/pull/4507\n     * @since 2.7.0\n     */\n    distribution: 'linear',\n\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 2.7.0\n     */\n    bounds: 'data',\n    time: {\n      parser: false,\n      // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n      format: false,\n      // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\n      unit: false,\n      // false == automatic or override with week, month, year, etc.\n      round: false,\n      // none, or override with week, month, year, etc.\n      displayFormat: false,\n      // DEPRECATED\n      isoWeekday: false,\n      // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\n      minUnit: 'millisecond',\n      // defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\n      displayFormats: {\n        millisecond: 'h:mm:ss.SSS a',\n        // 11:20:01.123 AM,\n        second: 'h:mm:ss a',\n        // 11:20:01 AM\n        minute: 'h:mm a',\n        // 11:20 AM\n        hour: 'hA',\n        // 5PM\n        day: 'MMM D',\n        // Sep 4\n        week: 'll',\n        // Week 46, or maybe \"[W]WW - YYYY\" ?\n        month: 'MMM YYYY',\n        // Sept 2015\n        quarter: '[Q]Q - YYYY',\n        // Q3\n        year: 'YYYY' // 2015\n\n      }\n    },\n    ticks: {\n      autoSkip: false,\n\n      /**\n       * Ticks generation input values:\n       * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n       * - 'labels': generates ticks from user given `data.labels` values ONLY.\n       * @see https://github.com/chartjs/Chart.js/pull/4507\n       * @since 2.7.0\n       */\n      source: 'auto',\n      major: {\n        enabled: false\n      }\n    }\n  };\n  var TimeScale = Scale.extend({\n    initialize: function () {\n      if (!moment) {\n        throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');\n      }\n\n      this.mergeTicksOptions();\n      Scale.prototype.initialize.call(this);\n    },\n    update: function () {\n      var me = this;\n      var options = me.options; // DEPRECATIONS: output a message only one time per update\n\n      if (options.time && options.time.format) {\n        console.warn('options.time.format is deprecated and replaced by options.time.parser.');\n      }\n\n      return Scale.prototype.update.apply(me, arguments);\n    },\n\n    /**\n     * Allows data to be referenced via 't' attribute\n     */\n    getRightValue: function (rawValue) {\n      if (rawValue && rawValue.t !== undefined) {\n        rawValue = rawValue.t;\n      }\n\n      return Scale.prototype.getRightValue.call(this, rawValue);\n    },\n    determineDataLimits: function () {\n      var me = this;\n      var chart = me.chart;\n      var timeOpts = me.options.time;\n      var unit = timeOpts.unit || 'day';\n      var min = MAX_INTEGER;\n      var max = MIN_INTEGER;\n      var timestamps = [];\n      var datasets = [];\n      var labels = [];\n      var i, j, ilen, jlen, data, timestamp; // Convert labels to timestamps\n\n      for (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {\n        labels.push(parse(chart.data.labels[i], me));\n      } // Convert data to timestamps\n\n\n      for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          data = chart.data.datasets[i].data; // Let's consider that all data have the same format.\n\n          if (helpers.isObject(data[0])) {\n            datasets[i] = [];\n\n            for (j = 0, jlen = data.length; j < jlen; ++j) {\n              timestamp = parse(data[j], me);\n              timestamps.push(timestamp);\n              datasets[i][j] = timestamp;\n            }\n          } else {\n            timestamps.push.apply(timestamps, labels);\n            datasets[i] = labels.slice(0);\n          }\n        } else {\n          datasets[i] = [];\n        }\n      }\n\n      if (labels.length) {\n        // Sort labels **after** data have been converted\n        labels = arrayUnique(labels).sort(sorter);\n        min = Math.min(min, labels[0]);\n        max = Math.max(max, labels[labels.length - 1]);\n      }\n\n      if (timestamps.length) {\n        timestamps = arrayUnique(timestamps).sort(sorter);\n        min = Math.min(min, timestamps[0]);\n        max = Math.max(max, timestamps[timestamps.length - 1]);\n      }\n\n      min = parse(timeOpts.min, me) || min;\n      max = parse(timeOpts.max, me) || max; // In case there is no valid min/max, set limits based on unit time option\n\n      min = min === MAX_INTEGER ? +moment().startOf(unit) : min;\n      max = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max; // Make sure that max is strictly higher than min (required by the lookup table)\n\n      me.min = Math.min(min, max);\n      me.max = Math.max(min + 1, max); // PRIVATE\n\n      me._horizontal = me.isHorizontal();\n      me._table = [];\n      me._timestamps = {\n        data: timestamps,\n        datasets: datasets,\n        labels: labels\n      };\n    },\n    buildTicks: function () {\n      var me = this;\n      var min = me.min;\n      var max = me.max;\n      var options = me.options;\n      var timeOpts = options.time;\n      var timestamps = [];\n      var ticks = [];\n      var i, ilen, timestamp;\n\n      switch (options.ticks.source) {\n        case 'data':\n          timestamps = me._timestamps.data;\n          break;\n\n        case 'labels':\n          timestamps = me._timestamps.labels;\n          break;\n\n        case 'auto':\n        default:\n          timestamps = generate(min, max, me.getLabelCapacity(min), options);\n      }\n\n      if (options.bounds === 'ticks' && timestamps.length) {\n        min = timestamps[0];\n        max = timestamps[timestamps.length - 1];\n      } // Enforce limits with user min/max options\n\n\n      min = parse(timeOpts.min, me) || min;\n      max = parse(timeOpts.max, me) || max; // Remove ticks outside the min/max range\n\n      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n        timestamp = timestamps[i];\n\n        if (timestamp >= min && timestamp <= max) {\n          ticks.push(timestamp);\n        }\n      }\n\n      me.min = min;\n      me.max = max; // PRIVATE\n\n      me._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);\n      me._majorUnit = determineMajorUnit(me._unit);\n      me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\n      me._offsets = computeOffsets(me._table, ticks, min, max, options);\n      me._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);\n      return ticksFromTimestamps(ticks, me._majorUnit);\n    },\n    getLabelForIndex: function (index, datasetIndex) {\n      var me = this;\n      var data = me.chart.data;\n      var timeOpts = me.options.time;\n      var label = data.labels && index < data.labels.length ? data.labels[index] : '';\n      var value = data.datasets[datasetIndex].data[index];\n\n      if (helpers.isObject(value)) {\n        label = me.getRightValue(value);\n      }\n\n      if (timeOpts.tooltipFormat) {\n        return momentify(label, timeOpts).format(timeOpts.tooltipFormat);\n      }\n\n      if (typeof label === 'string') {\n        return label;\n      }\n\n      return momentify(label, timeOpts).format(me._labelFormat);\n    },\n\n    /**\n     * Function to format an individual tick mark\n     * @private\n     */\n    tickFormatFunction: function (tick, index, ticks, formatOverride) {\n      var me = this;\n      var options = me.options;\n      var time = tick.valueOf();\n      var formats = options.time.displayFormats;\n      var minorFormat = formats[me._unit];\n      var majorUnit = me._majorUnit;\n      var majorFormat = formats[majorUnit];\n      var majorTime = tick.clone().startOf(majorUnit).valueOf();\n      var majorTickOpts = options.ticks.major;\n      var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;\n      var label = tick.format(formatOverride ? formatOverride : major ? majorFormat : minorFormat);\n      var tickOpts = major ? majorTickOpts : options.ticks.minor;\n      var formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);\n      return formatter ? formatter(label, index, ticks) : label;\n    },\n    convertTicksToLabels: function (ticks) {\n      var labels = [];\n      var i, ilen;\n\n      for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n        labels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));\n      }\n\n      return labels;\n    },\n\n    /**\n     * @private\n     */\n    getPixelForOffset: function (time) {\n      var me = this;\n      var size = me._horizontal ? me.width : me.height;\n      var start = me._horizontal ? me.left : me.top;\n      var pos = interpolate(me._table, 'time', time, 'pos');\n      return start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);\n    },\n    getPixelForValue: function (value, index, datasetIndex) {\n      var me = this;\n      var time = null;\n\n      if (index !== undefined && datasetIndex !== undefined) {\n        time = me._timestamps.datasets[datasetIndex][index];\n      }\n\n      if (time === null) {\n        time = parse(value, me);\n      }\n\n      if (time !== null) {\n        return me.getPixelForOffset(time);\n      }\n    },\n    getPixelForTick: function (index) {\n      var ticks = this.getTicks();\n      return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;\n    },\n    getValueForPixel: function (pixel) {\n      var me = this;\n      var size = me._horizontal ? me.width : me.height;\n      var start = me._horizontal ? me.left : me.top;\n      var pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;\n      var time = interpolate(me._table, 'pos', pos, 'time');\n      return moment(time);\n    },\n\n    /**\n     * Crude approximation of what the label width might be\n     * @private\n     */\n    getLabelWidth: function (label) {\n      var me = this;\n      var ticksOpts = me.options.ticks;\n      var tickLabelWidth = me.ctx.measureText(label).width;\n      var angle = helpers.toRadians(ticksOpts.maxRotation);\n      var cosRotation = Math.cos(angle);\n      var sinRotation = Math.sin(angle);\n      var tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);\n      return tickLabelWidth * cosRotation + tickFontSize * sinRotation;\n    },\n\n    /**\n     * @private\n     */\n    getLabelCapacity: function (exampleTime) {\n      var me = this;\n      var formatOverride = me.options.time.displayFormats.millisecond; // Pick the longest format for guestimation\n\n      var exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);\n      var tickLabelWidth = me.getLabelWidth(exampleLabel);\n      var innerWidth = me.isHorizontal() ? me.width : me.height;\n      var capacity = Math.floor(innerWidth / tickLabelWidth);\n      return capacity > 0 ? capacity : 1;\n    }\n  });\n  scaleService.registerScaleType('time', TimeScale, defaultConfig);\n};","map":{"version":3,"sources":["C:/Users/Administrator/.git/asdf/Source Files/node_modules/chart.js/src/scales/scale.time.js"],"names":["moment","require","window","defaults","helpers","Scale","scaleService","MIN_INTEGER","Number","MIN_SAFE_INTEGER","MAX_INTEGER","MAX_SAFE_INTEGER","INTERVALS","millisecond","common","size","steps","second","minute","hour","day","week","month","quarter","year","UNITS","Object","keys","sorter","a","b","arrayUnique","items","hash","out","i","ilen","item","length","push","buildLookupTable","timestamps","min","max","distribution","time","pos","table","prev","curr","next","undefined","Math","round","lookup","key","value","lo","hi","mid","i0","i1","interpolate","skey","sval","tkey","range","span","ratio","offset","momentify","options","parser","format","isValid","parse","input","scale","isNullOrUndef","getRightValue","startOf","valueOf","determineStepSize","unit","capacity","interval","milliseconds","factor","ceil","determineUnitForAutoTicks","minUnit","indexOf","determineUnitForFormatting","ticks","duration","diff","as","determineMajorUnit","generate","timeOpts","minor","major","stepSize","valueOrDefault","unitStepSize","weekday","isoWeekday","majorTicksEnabled","enabled","first","last","add","computeOffsets","left","right","upper","lower","ticksFromTimestamps","values","majorUnit","determineLabelFormat","data","momentDate","hasTime","module","exports","defaultConfig","position","bounds","displayFormat","displayFormats","autoSkip","source","TimeScale","extend","initialize","Error","mergeTicksOptions","prototype","call","update","me","console","warn","apply","arguments","rawValue","t","determineDataLimits","chart","datasets","labels","j","jlen","timestamp","isDatasetVisible","isObject","slice","sort","endOf","_horizontal","isHorizontal","_table","_timestamps","buildTicks","getLabelCapacity","_unit","_majorUnit","_offsets","_labelFormat","getLabelForIndex","index","datasetIndex","label","tooltipFormat","tickFormatFunction","tick","formatOverride","formats","minorFormat","majorFormat","majorTime","clone","majorTickOpts","tickOpts","formatter","callback","userCallback","convertTicksToLabels","getPixelForOffset","width","height","start","top","getPixelForValue","getPixelForTick","getTicks","getValueForPixel","pixel","getLabelWidth","ticksOpts","tickLabelWidth","ctx","measureText","angle","toRadians","maxRotation","cosRotation","cos","sinRotation","sin","tickFontSize","fontSize","global","defaultFontSize","exampleTime","exampleLabel","innerWidth","floor","registerScaleType"],"mappings":"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","sourcesContent":["/* global window: false */\n'use strict';\n\nvar moment = require('moment');\nmoment = typeof moment === 'function' ? moment : window.moment;\n\nvar defaults = require('../core/core.defaults');\nvar helpers = require('../helpers/index');\nvar Scale = require('../core/core.scale');\nvar scaleService = require('../core/core.scaleService');\n\n// Integer constants are from the ES6 spec.\nvar MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;\nvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\nvar INTERVALS = {\n\tmillisecond: {\n\t\tcommon: true,\n\t\tsize: 1,\n\t\tsteps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n\t},\n\tsecond: {\n\t\tcommon: true,\n\t\tsize: 1000,\n\t\tsteps: [1, 2, 5, 10, 15, 30]\n\t},\n\tminute: {\n\t\tcommon: true,\n\t\tsize: 60000,\n\t\tsteps: [1, 2, 5, 10, 15, 30]\n\t},\n\thour: {\n\t\tcommon: true,\n\t\tsize: 3600000,\n\t\tsteps: [1, 2, 3, 6, 12]\n\t},\n\tday: {\n\t\tcommon: true,\n\t\tsize: 86400000,\n\t\tsteps: [1, 2, 5]\n\t},\n\tweek: {\n\t\tcommon: false,\n\t\tsize: 604800000,\n\t\tsteps: [1, 2, 3, 4]\n\t},\n\tmonth: {\n\t\tcommon: true,\n\t\tsize: 2.628e9,\n\t\tsteps: [1, 2, 3]\n\t},\n\tquarter: {\n\t\tcommon: false,\n\t\tsize: 7.884e9,\n\t\tsteps: [1, 2, 3, 4]\n\t},\n\tyear: {\n\t\tcommon: true,\n\t\tsize: 3.154e10\n\t}\n};\n\nvar UNITS = Object.keys(INTERVALS);\n\nfunction sorter(a, b) {\n\treturn a - b;\n}\n\nfunction arrayUnique(items) {\n\tvar hash = {};\n\tvar out = [];\n\tvar i, ilen, item;\n\n\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\titem = items[i];\n\t\tif (!hash[item]) {\n\t\t\thash[item] = true;\n\t\t\tout.push(item);\n\t\t}\n\t}\n\n\treturn out;\n}\n\n/**\n * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\n * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\n * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\n * extremity (left + width or top + height). Note that it would be more optimized to directly\n * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\n * to create the lookup table. The table ALWAYS contains at least two items: min and max.\n *\n * @param {Number[]} timestamps - timestamps sorted from lowest to highest.\n * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min\n * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.\n * If 'series', timestamps will be positioned at the same distance from each other. In this\n * case, only timestamps that break the time linearity are registered, meaning that in the\n * best case, all timestamps are linear, the table contains only min and max.\n */\nfunction buildLookupTable(timestamps, min, max, distribution) {\n\tif (distribution === 'linear' || !timestamps.length) {\n\t\treturn [\n\t\t\t{time: min, pos: 0},\n\t\t\t{time: max, pos: 1}\n\t\t];\n\t}\n\n\tvar table = [];\n\tvar items = [min];\n\tvar i, ilen, prev, curr, next;\n\n\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n\t\tcurr = timestamps[i];\n\t\tif (curr > min && curr < max) {\n\t\t\titems.push(curr);\n\t\t}\n\t}\n\n\titems.push(max);\n\n\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\tnext = items[i + 1];\n\t\tprev = items[i - 1];\n\t\tcurr = items[i];\n\n\t\t// only add points that breaks the scale linearity\n\t\tif (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {\n\t\t\ttable.push({time: curr, pos: i / (ilen - 1)});\n\t\t}\n\t}\n\n\treturn table;\n}\n\n// @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/\nfunction lookup(table, key, value) {\n\tvar lo = 0;\n\tvar hi = table.length - 1;\n\tvar mid, i0, i1;\n\n\twhile (lo >= 0 && lo <= hi) {\n\t\tmid = (lo + hi) >> 1;\n\t\ti0 = table[mid - 1] || null;\n\t\ti1 = table[mid];\n\n\t\tif (!i0) {\n\t\t\t// given value is outside table (before first item)\n\t\t\treturn {lo: null, hi: i1};\n\t\t} else if (i1[key] < value) {\n\t\t\tlo = mid + 1;\n\t\t} else if (i0[key] > value) {\n\t\t\thi = mid - 1;\n\t\t} else {\n\t\t\treturn {lo: i0, hi: i1};\n\t\t}\n\t}\n\n\t// given value is outside table (after last item)\n\treturn {lo: i1, hi: null};\n}\n\n/**\n * Linearly interpolates the given source `value` using the table items `skey` values and\n * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\n * returns the position for a timestamp equal to 42. If value is out of bounds, values at\n * index [0, 1] or [n - 1, n] are used for the interpolation.\n */\nfunction interpolate(table, skey, sval, tkey) {\n\tvar range = lookup(table, skey, sval);\n\n\t// Note: the lookup table ALWAYS contains at least 2 items (min and max)\n\tvar prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;\n\tvar next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;\n\n\tvar span = next[skey] - prev[skey];\n\tvar ratio = span ? (sval - prev[skey]) / span : 0;\n\tvar offset = (next[tkey] - prev[tkey]) * ratio;\n\n\treturn prev[tkey] + offset;\n}\n\n/**\n * Convert the given value to a moment object using the given time options.\n * @see http://momentjs.com/docs/#/parsing/\n */\nfunction momentify(value, options) {\n\tvar parser = options.parser;\n\tvar format = options.parser || options.format;\n\n\tif (typeof parser === 'function') {\n\t\treturn parser(value);\n\t}\n\n\tif (typeof value === 'string' && typeof format === 'string') {\n\t\treturn moment(value, format);\n\t}\n\n\tif (!(value instanceof moment)) {\n\t\tvalue = moment(value);\n\t}\n\n\tif (value.isValid()) {\n\t\treturn value;\n\t}\n\n\t// Labels are in an incompatible moment format and no `parser` has been provided.\n\t// The user might still use the deprecated `format` option to convert his inputs.\n\tif (typeof format === 'function') {\n\t\treturn format(value);\n\t}\n\n\treturn value;\n}\n\nfunction parse(input, scale) {\n\tif (helpers.isNullOrUndef(input)) {\n\t\treturn null;\n\t}\n\n\tvar options = scale.options.time;\n\tvar value = momentify(scale.getRightValue(input), options);\n\tif (!value.isValid()) {\n\t\treturn null;\n\t}\n\n\tif (options.round) {\n\t\tvalue.startOf(options.round);\n\t}\n\n\treturn value.valueOf();\n}\n\n/**\n * Returns the number of unit to skip to be able to display up to `capacity` number of ticks\n * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.\n */\nfunction determineStepSize(min, max, unit, capacity) {\n\tvar range = max - min;\n\tvar interval = INTERVALS[unit];\n\tvar milliseconds = interval.size;\n\tvar steps = interval.steps;\n\tvar i, ilen, factor;\n\n\tif (!steps) {\n\t\treturn Math.ceil(range / (capacity * milliseconds));\n\t}\n\n\tfor (i = 0, ilen = steps.length; i < ilen; ++i) {\n\t\tfactor = steps[i];\n\t\tif (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn factor;\n}\n\n/**\n * Figures out what unit results in an appropriate number of auto-generated ticks\n */\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n\tvar ilen = UNITS.length;\n\tvar i, interval, factor;\n\n\tfor (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n\t\tinterval = INTERVALS[UNITS[i]];\n\t\tfactor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;\n\n\t\tif (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n\t\t\treturn UNITS[i];\n\t\t}\n\t}\n\n\treturn UNITS[ilen - 1];\n}\n\n/**\n * Figures out what unit to format a set of ticks with\n */\nfunction determineUnitForFormatting(ticks, minUnit, min, max) {\n\tvar duration = moment.duration(moment(max).diff(moment(min)));\n\tvar ilen = UNITS.length;\n\tvar i, unit;\n\n\tfor (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {\n\t\tunit = UNITS[i];\n\t\tif (INTERVALS[unit].common && duration.as(unit) >= ticks.length) {\n\t\t\treturn unit;\n\t\t}\n\t}\n\n\treturn UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\nfunction determineMajorUnit(unit) {\n\tfor (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n\t\tif (INTERVALS[UNITS[i]].common) {\n\t\t\treturn UNITS[i];\n\t\t}\n\t}\n}\n\n/**\n * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n * `minor` unit, aligned on the `major` unit and using the given scale time `options`.\n * Important: this method can return ticks outside the min and max range, it's the\n * responsibility of the calling code to clamp values if needed.\n */\nfunction generate(min, max, capacity, options) {\n\tvar timeOpts = options.time;\n\tvar minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n\tvar major = determineMajorUnit(minor);\n\tvar stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);\n\tvar weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n\tvar majorTicksEnabled = options.ticks.major.enabled;\n\tvar interval = INTERVALS[minor];\n\tvar first = moment(min);\n\tvar last = moment(max);\n\tvar ticks = [];\n\tvar time;\n\n\tif (!stepSize) {\n\t\tstepSize = determineStepSize(min, max, minor, capacity);\n\t}\n\n\t// For 'week' unit, handle the first day of week option\n\tif (weekday) {\n\t\tfirst = first.isoWeekday(weekday);\n\t\tlast = last.isoWeekday(weekday);\n\t}\n\n\t// Align first/last ticks on unit\n\tfirst = first.startOf(weekday ? 'day' : minor);\n\tlast = last.startOf(weekday ? 'day' : minor);\n\n\t// Make sure that the last tick include max\n\tif (last < max) {\n\t\tlast.add(1, minor);\n\t}\n\n\ttime = moment(first);\n\n\tif (majorTicksEnabled && major && !weekday && !timeOpts.round) {\n\t\t// Align the first tick on the previous `minor` unit aligned on the `major` unit:\n\t\t// we first aligned time on the previous `major` unit then add the number of full\n\t\t// stepSize there is between first and the previous major time.\n\t\ttime.startOf(major);\n\t\ttime.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n\t}\n\n\tfor (; time < last; time.add(stepSize, minor)) {\n\t\tticks.push(+time);\n\t}\n\n\tticks.push(+time);\n\n\treturn ticks;\n}\n\n/**\n * Returns the right and left offsets from edges in the form of {left, right}.\n * Offsets are added when the `offset` option is true.\n */\nfunction computeOffsets(table, ticks, min, max, options) {\n\tvar left = 0;\n\tvar right = 0;\n\tvar upper, lower;\n\n\tif (options.offset && ticks.length) {\n\t\tif (!options.time.min) {\n\t\t\tupper = ticks.length > 1 ? ticks[1] : max;\n\t\t\tlower = ticks[0];\n\t\t\tleft = (\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\n\t\t\t) / 2;\n\t\t}\n\t\tif (!options.time.max) {\n\t\t\tupper = ticks[ticks.length - 1];\n\t\t\tlower = ticks.length > 1 ? ticks[ticks.length - 2] : min;\n\t\t\tright = (\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\n\t\t\t) / 2;\n\t\t}\n\t}\n\n\treturn {left: left, right: right};\n}\n\nfunction ticksFromTimestamps(values, majorUnit) {\n\tvar ticks = [];\n\tvar i, ilen, value, major;\n\n\tfor (i = 0, ilen = values.length; i < ilen; ++i) {\n\t\tvalue = values[i];\n\t\tmajor = majorUnit ? value === +moment(value).startOf(majorUnit) : false;\n\n\t\tticks.push({\n\t\t\tvalue: value,\n\t\t\tmajor: major\n\t\t});\n\t}\n\n\treturn ticks;\n}\n\nfunction determineLabelFormat(data, timeOpts) {\n\tvar i, momentDate, hasTime;\n\tvar ilen = data.length;\n\n\t// find the label with the most parts (milliseconds, minutes, etc.)\n\t// format all labels with the same level of detail as the most specific label\n\tfor (i = 0; i < ilen; i++) {\n\t\tmomentDate = momentify(data[i], timeOpts);\n\t\tif (momentDate.millisecond() !== 0) {\n\t\t\treturn 'MMM D, YYYY h:mm:ss.SSS a';\n\t\t}\n\t\tif (momentDate.second() !== 0 || momentDate.minute() !== 0 || momentDate.hour() !== 0) {\n\t\t\thasTime = true;\n\t\t}\n\t}\n\tif (hasTime) {\n\t\treturn 'MMM D, YYYY h:mm:ss a';\n\t}\n\treturn 'MMM D, YYYY';\n}\n\nmodule.exports = function() {\n\n\tvar defaultConfig = {\n\t\tposition: 'bottom',\n\n\t\t/**\n\t\t * Data distribution along the scale:\n\t\t * - 'linear': data are spread according to their time (distances can vary),\n\t\t * - 'series': data are spread at the same distance from each other.\n\t\t * @see https://github.com/chartjs/Chart.js/pull/4507\n\t\t * @since 2.7.0\n\t\t */\n\t\tdistribution: 'linear',\n\n\t\t/**\n\t\t * Scale boundary strategy (bypassed by min/max time options)\n\t\t * - `data`: make sure data are fully visible, ticks outside are removed\n\t\t * - `ticks`: make sure ticks are fully visible, data outside are truncated\n\t\t * @see https://github.com/chartjs/Chart.js/pull/4556\n\t\t * @since 2.7.0\n\t\t */\n\t\tbounds: 'data',\n\n\t\ttime: {\n\t\t\tparser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n\t\t\tformat: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\n\t\t\tunit: false, // false == automatic or override with week, month, year, etc.\n\t\t\tround: false, // none, or override with week, month, year, etc.\n\t\t\tdisplayFormat: false, // DEPRECATED\n\t\t\tisoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\n\t\t\tminUnit: 'millisecond',\n\n\t\t\t// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\n\t\t\tdisplayFormats: {\n\t\t\t\tmillisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,\n\t\t\t\tsecond: 'h:mm:ss a', // 11:20:01 AM\n\t\t\t\tminute: 'h:mm a', // 11:20 AM\n\t\t\t\thour: 'hA', // 5PM\n\t\t\t\tday: 'MMM D', // Sep 4\n\t\t\t\tweek: 'll', // Week 46, or maybe \"[W]WW - YYYY\" ?\n\t\t\t\tmonth: 'MMM YYYY', // Sept 2015\n\t\t\t\tquarter: '[Q]Q - YYYY', // Q3\n\t\t\t\tyear: 'YYYY' // 2015\n\t\t\t},\n\t\t},\n\t\tticks: {\n\t\t\tautoSkip: false,\n\n\t\t\t/**\n\t\t\t * Ticks generation input values:\n\t\t\t * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n\t\t\t * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n\t\t\t * - 'labels': generates ticks from user given `data.labels` values ONLY.\n\t\t\t * @see https://github.com/chartjs/Chart.js/pull/4507\n\t\t\t * @since 2.7.0\n\t\t\t */\n\t\t\tsource: 'auto',\n\n\t\t\tmajor: {\n\t\t\t\tenabled: false\n\t\t\t}\n\t\t}\n\t};\n\n\tvar TimeScale = Scale.extend({\n\t\tinitialize: function() {\n\t\t\tif (!moment) {\n\t\t\t\tthrow new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');\n\t\t\t}\n\n\t\t\tthis.mergeTicksOptions();\n\n\t\t\tScale.prototype.initialize.call(this);\n\t\t},\n\n\t\tupdate: function() {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\n\t\t\t// DEPRECATIONS: output a message only one time per update\n\t\t\tif (options.time && options.time.format) {\n\t\t\t\tconsole.warn('options.time.format is deprecated and replaced by options.time.parser.');\n\t\t\t}\n\n\t\t\treturn Scale.prototype.update.apply(me, arguments);\n\t\t},\n\n\t\t/**\n\t\t * Allows data to be referenced via 't' attribute\n\t\t */\n\t\tgetRightValue: function(rawValue) {\n\t\t\tif (rawValue && rawValue.t !== undefined) {\n\t\t\t\trawValue = rawValue.t;\n\t\t\t}\n\t\t\treturn Scale.prototype.getRightValue.call(this, rawValue);\n\t\t},\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar timeOpts = me.options.time;\n\t\t\tvar unit = timeOpts.unit || 'day';\n\t\t\tvar min = MAX_INTEGER;\n\t\t\tvar max = MIN_INTEGER;\n\t\t\tvar timestamps = [];\n\t\t\tvar datasets = [];\n\t\t\tvar labels = [];\n\t\t\tvar i, j, ilen, jlen, data, timestamp;\n\n\t\t\t// Convert labels to timestamps\n\t\t\tfor (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {\n\t\t\t\tlabels.push(parse(chart.data.labels[i], me));\n\t\t\t}\n\n\t\t\t// Convert data to timestamps\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tif (chart.isDatasetVisible(i)) {\n\t\t\t\t\tdata = chart.data.datasets[i].data;\n\n\t\t\t\t\t// Let's consider that all data have the same format.\n\t\t\t\t\tif (helpers.isObject(data[0])) {\n\t\t\t\t\t\tdatasets[i] = [];\n\n\t\t\t\t\t\tfor (j = 0, jlen = data.length; j < jlen; ++j) {\n\t\t\t\t\t\t\ttimestamp = parse(data[j], me);\n\t\t\t\t\t\t\ttimestamps.push(timestamp);\n\t\t\t\t\t\t\tdatasets[i][j] = timestamp;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttimestamps.push.apply(timestamps, labels);\n\t\t\t\t\t\tdatasets[i] = labels.slice(0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdatasets[i] = [];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (labels.length) {\n\t\t\t\t// Sort labels **after** data have been converted\n\t\t\t\tlabels = arrayUnique(labels).sort(sorter);\n\t\t\t\tmin = Math.min(min, labels[0]);\n\t\t\t\tmax = Math.max(max, labels[labels.length - 1]);\n\t\t\t}\n\n\t\t\tif (timestamps.length) {\n\t\t\t\ttimestamps = arrayUnique(timestamps).sort(sorter);\n\t\t\t\tmin = Math.min(min, timestamps[0]);\n\t\t\t\tmax = Math.max(max, timestamps[timestamps.length - 1]);\n\t\t\t}\n\n\t\t\tmin = parse(timeOpts.min, me) || min;\n\t\t\tmax = parse(timeOpts.max, me) || max;\n\n\t\t\t// In case there is no valid min/max, set limits based on unit time option\n\t\t\tmin = min === MAX_INTEGER ? +moment().startOf(unit) : min;\n\t\t\tmax = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max;\n\n\t\t\t// Make sure that max is strictly higher than min (required by the lookup table)\n\t\t\tme.min = Math.min(min, max);\n\t\t\tme.max = Math.max(min + 1, max);\n\n\t\t\t// PRIVATE\n\t\t\tme._horizontal = me.isHorizontal();\n\t\t\tme._table = [];\n\t\t\tme._timestamps = {\n\t\t\t\tdata: timestamps,\n\t\t\t\tdatasets: datasets,\n\t\t\t\tlabels: labels\n\t\t\t};\n\t\t},\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\t\t\tvar options = me.options;\n\t\t\tvar timeOpts = options.time;\n\t\t\tvar timestamps = [];\n\t\t\tvar ticks = [];\n\t\t\tvar i, ilen, timestamp;\n\n\t\t\tswitch (options.ticks.source) {\n\t\t\tcase 'data':\n\t\t\t\ttimestamps = me._timestamps.data;\n\t\t\t\tbreak;\n\t\t\tcase 'labels':\n\t\t\t\ttimestamps = me._timestamps.labels;\n\t\t\t\tbreak;\n\t\t\tcase 'auto':\n\t\t\tdefault:\n\t\t\t\ttimestamps = generate(min, max, me.getLabelCapacity(min), options);\n\t\t\t}\n\n\t\t\tif (options.bounds === 'ticks' && timestamps.length) {\n\t\t\t\tmin = timestamps[0];\n\t\t\t\tmax = timestamps[timestamps.length - 1];\n\t\t\t}\n\n\t\t\t// Enforce limits with user min/max options\n\t\t\tmin = parse(timeOpts.min, me) || min;\n\t\t\tmax = parse(timeOpts.max, me) || max;\n\n\t\t\t// Remove ticks outside the min/max range\n\t\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n\t\t\t\ttimestamp = timestamps[i];\n\t\t\t\tif (timestamp >= min && timestamp <= max) {\n\t\t\t\t\tticks.push(timestamp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.min = min;\n\t\t\tme.max = max;\n\n\t\t\t// PRIVATE\n\t\t\tme._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);\n\t\t\tme._majorUnit = determineMajorUnit(me._unit);\n\t\t\tme._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\n\t\t\tme._offsets = computeOffsets(me._table, ticks, min, max, options);\n\t\t\tme._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);\n\n\t\t\treturn ticksFromTimestamps(ticks, me._majorUnit);\n\t\t},\n\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar data = me.chart.data;\n\t\t\tvar timeOpts = me.options.time;\n\t\t\tvar label = data.labels && index < data.labels.length ? data.labels[index] : '';\n\t\t\tvar value = data.datasets[datasetIndex].data[index];\n\n\t\t\tif (helpers.isObject(value)) {\n\t\t\t\tlabel = me.getRightValue(value);\n\t\t\t}\n\t\t\tif (timeOpts.tooltipFormat) {\n\t\t\t\treturn momentify(label, timeOpts).format(timeOpts.tooltipFormat);\n\t\t\t}\n\t\t\tif (typeof label === 'string') {\n\t\t\t\treturn label;\n\t\t\t}\n\n\t\t\treturn momentify(label, timeOpts).format(me._labelFormat);\n\t\t},\n\n\t\t/**\n\t\t * Function to format an individual tick mark\n\t\t * @private\n\t\t */\n\t\ttickFormatFunction: function(tick, index, ticks, formatOverride) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar time = tick.valueOf();\n\t\t\tvar formats = options.time.displayFormats;\n\t\t\tvar minorFormat = formats[me._unit];\n\t\t\tvar majorUnit = me._majorUnit;\n\t\t\tvar majorFormat = formats[majorUnit];\n\t\t\tvar majorTime = tick.clone().startOf(majorUnit).valueOf();\n\t\t\tvar majorTickOpts = options.ticks.major;\n\t\t\tvar major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;\n\t\t\tvar label = tick.format(formatOverride ? formatOverride : major ? majorFormat : minorFormat);\n\t\t\tvar tickOpts = major ? majorTickOpts : options.ticks.minor;\n\t\t\tvar formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);\n\n\t\t\treturn formatter ? formatter(label, index, ticks) : label;\n\t\t},\n\n\t\tconvertTicksToLabels: function(ticks) {\n\t\t\tvar labels = [];\n\t\t\tvar i, ilen;\n\n\t\t\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\t\t\tlabels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));\n\t\t\t}\n\n\t\t\treturn labels;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetPixelForOffset: function(time) {\n\t\t\tvar me = this;\n\t\t\tvar size = me._horizontal ? me.width : me.height;\n\t\t\tvar start = me._horizontal ? me.left : me.top;\n\t\t\tvar pos = interpolate(me._table, 'time', time, 'pos');\n\n\t\t\treturn start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);\n\t\t},\n\n\t\tgetPixelForValue: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar time = null;\n\n\t\t\tif (index !== undefined && datasetIndex !== undefined) {\n\t\t\t\ttime = me._timestamps.datasets[datasetIndex][index];\n\t\t\t}\n\n\t\t\tif (time === null) {\n\t\t\t\ttime = parse(value, me);\n\t\t\t}\n\n\t\t\tif (time !== null) {\n\t\t\t\treturn me.getPixelForOffset(time);\n\t\t\t}\n\t\t},\n\n\t\tgetPixelForTick: function(index) {\n\t\t\tvar ticks = this.getTicks();\n\t\t\treturn index >= 0 && index < ticks.length ?\n\t\t\t\tthis.getPixelForOffset(ticks[index].value) :\n\t\t\t\tnull;\n\t\t},\n\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar size = me._horizontal ? me.width : me.height;\n\t\t\tvar start = me._horizontal ? me.left : me.top;\n\t\t\tvar pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;\n\t\t\tvar time = interpolate(me._table, 'pos', pos, 'time');\n\n\t\t\treturn moment(time);\n\t\t},\n\n\t\t/**\n\t\t * Crude approximation of what the label width might be\n\t\t * @private\n\t\t */\n\t\tgetLabelWidth: function(label) {\n\t\t\tvar me = this;\n\t\t\tvar ticksOpts = me.options.ticks;\n\t\t\tvar tickLabelWidth = me.ctx.measureText(label).width;\n\t\t\tvar angle = helpers.toRadians(ticksOpts.maxRotation);\n\t\t\tvar cosRotation = Math.cos(angle);\n\t\t\tvar sinRotation = Math.sin(angle);\n\t\t\tvar tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);\n\n\t\t\treturn (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetLabelCapacity: function(exampleTime) {\n\t\t\tvar me = this;\n\n\t\t\tvar formatOverride = me.options.time.displayFormats.millisecond;\t// Pick the longest format for guestimation\n\n\t\t\tvar exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);\n\t\t\tvar tickLabelWidth = me.getLabelWidth(exampleLabel);\n\t\t\tvar innerWidth = me.isHorizontal() ? me.width : me.height;\n\n\t\t\tvar capacity = Math.floor(innerWidth / tickLabelWidth);\n\t\t\treturn capacity > 0 ? capacity : 1;\n\t\t}\n\t});\n\n\tscaleService.registerScaleType('time', TimeScale, defaultConfig);\n};\n"]},"metadata":{},"sourceType":"script"}